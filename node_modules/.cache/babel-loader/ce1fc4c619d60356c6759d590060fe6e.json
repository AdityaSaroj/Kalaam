{"remainingRequest":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/babel-loader/lib/index.js!/Users/jonny/Documents/Work/test/BharatBackup/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/jonny/Documents/Work/test/BharatBackup/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/jonny/Documents/Work/test/BharatBackup/src/components/HelloWorld.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/jonny/Documents/Work/test/BharatBackup/src/components/HelloWorld.vue","mtime":1588269515460},{"path":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5qb2luIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnBhcnNlLWludCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCI7Ci8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCi8vCmltcG9ydCB7IFNvdXJjZURhdGFSZXBsYWNlZm9yRWFzeVBhcnNpbmcgfSBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvZnVuY3Rpb25zJzsKaW1wb3J0ICogYXMgVHlwZUNoZWNrIGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9UeXBlQ2hlY2tpbmcnOwppbXBvcnQgKiBhcyBBZHZhbmNlZFR5cGVDaGVjayBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvQWR2YW5jZWRUeXBlQ2hlY2tpbmcnOwppbXBvcnQgKiBhcyBCdWlsZE9wZXJhdGlvbiBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvQnVpbGRPcGVyYXRpb25zJzsKaW1wb3J0IHsgUHVzaEFycmF5LCBQdXNoQ2FsY3VsYXRpb24sIFB1c2hDb25kaXRpb25hbEtleXdvcmQsIFB1c2hDb25kaXRpb24sIFB1c2hGb3JMb29wLCBQdXNoV2hpbGVMb29wLCBQdXNoV2hpbGVMb29wQ29uZGl0aW9uLCBQdXNoRm9yTG9vcEFydWd1bWVudHMsIFB1c2hFeHByZXNzaW9uLCBQdXNoS2V5d29yZCwgUHVzaE51bWJlciwgUHVzaE9wZXJhdG9yLCBQdXNoUmVhbFRpbWVQcmludE9wZXJhdGlvbiwgUHVzaFN0cmluZywgUHVzaFN0cmluZ2FuZFZhbHVlT3BlcmF0aW9uLCBQdXNoVmFyaWFibGUsIFB1c2hFbXB0eUFycmF5SW5pdCB9IGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9QdXNoRnVuY3Rpb25zJzsKaW1wb3J0IHsgUmVtb3ZlQnJhY2tldHMsIGlzQXJyYXlPcGVyYXRpb24sIENyZWF0ZUFycmF5RWxlbWVudCwgQ2FsY3VsYXRlVmFsdWVzLCBHZXRBcnJheW9yU3RyaW5nRWxlbWVudCwgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQsIFByaW50QXJyYXlFbGVtZW50LCBoYW5kbGVtdWx0Q29uZGl0aW9ucywgU3BsaXRFbGVtZW50c0FycmF5LCBTZXRWYWx1ZXMsIFB1c2hTZXRBcnJheUluZGV4VmFsdWUsIFVwZGF0ZVVwZGF0ZWRfdG9rZW5zd2l0aFZhbHVlcywgR2V0Q29uZGl0aW9uVmFsdWUsIEZvckxvb3BBcnJheW9yU3RyaW5nT3V0cHV0LCBBc3NpZ25vclVwZGF0ZVZhbHVlcywgSGFuZGxlQ29uZGl0aW9ucyB9IGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9NaXNjSW1wb3J0YW50RnVuY3Rpb25zJzsKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICJIZWxsb1dvcmxkIiwKICBwcm9wczogewogICAgbXNnOiBTdHJpbmcKICB9LAogIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBjb2RlOiAnTmFtZT0iU3dhbmFuZCBLYWRhbSIgTmFtZT0iU3dhbmFuZCBLYWRhbSBpcyBnb2F0IiBBcnJheT1bIDIwLDMwLCJzd2FuYW5kIl0gQWdlPTIwMjAtMTk5NiBhZ2VvbmU9MjAgYWdldHdvPTMwIHg9YWdlb25lK2FnZXR3byBDaXR5PSJQdW5lIiDgpKrgpY3gpLDgpL/gpILgpJ8gKHgpICDgpKrgpY3gpLDgpL/gpILgpJ8gKE5hbWUpICDgpKrgpY3gpLDgpL/gpILgpJ8gKCJZb3UgbGl2ZSwgeW91IGxlYXJuIikgIOCkquCljeCksOCkv+CkguCknyAoQWdlKSAg4KSF4KSX4KSwIChhZ2VvbmU+YWdldHdvKSB74KSq4KWN4KSw4KS/4KSC4KSfICgiY29uZGl0aW9uIHdvcmtlZCIpfSDgpKrgpY3gpLDgpL/gpILgpJ8gKEFycmF5WzJdICsgQWdlICsgImlzIHlvdW5nIGFnZSIgKyBBZ2UpIOCkheCkl+CksCAoYWdlb25lPT0yMCkge+CkquCljeCksOCkv+CkguCknyAoImNvbmRpdGlvbiAyIHdvcmtlZCIpIHk9eCthZ2VvbmUg4KSq4KWN4KSw4KS/4KSC4KSfICh5KSB9JywKICAgICAgb3V0cHV0OiAnJywKICAgICAgZXJyb3I6IFtdLAogICAgICBPcGVyYXRpb25PYmplY3RzOiBbXSwKICAgICAgbGluZWJ5bGluZU91dHB1dDogJycsCiAgICAgIFRpbWVUYWtlbjogJycKICAgIH07CiAgfSwKICBtZXRob2RzOiB7CiAgICBSVU46IGZ1bmN0aW9uIFJVTigpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpOyAvL3RvIHN0b3AgYWNjdW11bGF0aW5nIG91dHB1dCBvbiBzdWNjZXNpdmUgUlVOCgogICAgICB0aGlzLm91dHB1dCA9ICcnOwogICAgICB0aGlzLmxpbmVieWxpbmVPdXRwdXQgPSB0aGlzLm91dHB1dC5zcGxpdCgiXG4iKTsKICAgICAgdGhpcy5lcnJvciA9IFtdOwogICAgICB0aGlzLk9wZXJhdGlvbk9iamVjdHMgPSBbXTsKICAgICAgdmFyIHNvdXJjZWRhdGEgPSB0aGlzLmNvZGU7CiAgICAgIHZhciBjbGVhbmVkX3NvdXJjZWRhdGEgPSBbXTsKICAgICAgdmFyIGkgPSAwOwogICAgICB2YXIgdG9rZW5zID0gW107CiAgICAgIHZhciBtaXhlZGltcHVyaXR5ID0gW107CiAgICAgIHZhciB1cGRhdGVkX3Rva2VucyA9IFtdOwogICAgICB2YXIgdmFyaWFibGVzX2FycmF5ID0gW107CiAgICAgIHZhciBhc3NpZ25lZF92YXJpYWJsZXMgPSBbXTsKICAgICAgdmFyIHRlcm1zID0gW107CiAgICAgIHZhciB0ZXJtczIgPSBbXTsKICAgICAgdmFyIG9wZXJhdGlvbiA9ICcnOwogICAgICB2YXIgQ2FsY3VsYXRpb25TdGFjayA9IFtdOwogICAgICB2YXIgZm91bmRUb2tlbiA9ICcnOwogICAgICB2YXIgUmVJbnRpYWxpemVkVmFyaWFibGVzID0gW107IC8vcHJlcGFyaW5nIHNvdXJjZWRhdGEgZm9yIGVhc3kgcGFyc2luZyBieSBoYW5kbGluZyBuZXcgbGluZXMsIGVudGVycyBldGMuCiAgICAgIC8vY2xlYW5pbmcgdXAgdGhlIGRhdGEgdG8gZ2V0IG15IHZlcnNpb24gb2Ygc291cmNlZGF0YS4gaXQncyBiZXR0ZXIgdG8gZ2V0IHZlcnNpb24gc3VpdGFibGUgZm9yIG1lIGJlY2F1c2UgdXNlcnMgY2FuIHR5cGUgd2hhdCB0aGV5IHdpc2ggYnV0IEkgbmVlZCB0byBtYWludGFpbiAKICAgICAgLy9pbnRlZ3JpdHkgb2YgcHJvZ3JhbSBpbiBldmVyeSBwb3NzaWJsZSBjb25kaXRpby4gU28uIEkgY3JlYXRlZCBteSBvd24gY29uZGl0aW9uIGJlbG93CgogICAgICBmdW5jdGlvbiBHZXRDbGVhblNvdXJjZWRhdGEoc291cmNlZGF0YSwgY2xlYW5lZF9zb3VyY2VkYXRhLCBpbXB1cml0aWVzKSB7CiAgICAgICAgc291cmNlZGF0YSA9IFNvdXJjZURhdGFSZXBsYWNlZm9yRWFzeVBhcnNpbmcoc291cmNlZGF0YSk7CiAgICAgICAgc291cmNlZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpKSB7CiAgICAgICAgICAvL2ZpbmRpbmcgdGhlIGVsZW1lbnRzIHdoaWNoIGhhcyA9IiBpbiBpdCBzbyB0aGF0IHRvIHNlcHJhdGUgdGhlbSBlLmcuIGFubmE9InN3YW5hbmQiIGFsc28gZmluZGluZyB0aGUgZWxlbWVudHMgd2hpY2ggc3RhcnRzIHdpdGggPS4gZS5nICI9Nzg3ODc4OTAiCiAgICAgICAgICBpZiAoKGVsZW1lbnQuaW5kZXhPZignPSInKSA+IC0xIHx8IGVsZW1lbnQuaW5kZXhPZignPScpID4gMCB8fCBlbGVtZW50LmNoYXJBdCgwKSA9PSAiPSIpICYmIGVsZW1lbnQgIT0gJz09JykgewogICAgICAgICAgICBpbXB1cml0aWVzLnB1c2goZWxlbWVudCk7IC8vcHVzaCBzdWNoIGVsZW1lbnQgYXMgaW1wdXJpdHkgaW4gaW1wdXJpdGllcwoKICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gZWxlbWVudC5zcGxpdCgiPSIpOwogICAgICAgICAgICB2YXIgaW5kZXggPSBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOwogICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGFbaW5kZXhdID0gZWxlbWVudHNbMF07CiAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YVtpbmRleCArIDFdID0gIj0iOwogICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGFbaW5kZXggKyAyXSA9IGVsZW1lbnRzWzFdOwogICAgICAgICAgfSAvL2FzIGxvbmcgYXMgZWxlbWVudCBpcyBwdXJlLCBwdXNoIGl0IHRvIG5ldyBhbmQgY2xlYW4gdmVyc2lvbiBvZiBzb3VyY2VkYXRhCgoKICAgICAgICAgIGlmICghaW1wdXJpdGllcy5pbmNsdWRlcyhlbGVtZW50KSkgewogICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGEucHVzaChlbGVtZW50KTsKICAgICAgICAgIH0gLy8KCiAgICAgICAgfSk7IC8vcmVtb3ZpbmcgZW1wdHkgIiIgdmFsdWVzIGZvciBmaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZWRhdGEKICAgICAgICAvL1NFQ1RJT04gRkluYWwgc291cmNlZGF0YSBjbGVhbmluZwoKICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGEgPSBjbGVhbmVkX3NvdXJjZWRhdGEuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICByZXR1cm4gaXRlbSAhPT0gIiI7CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIGNsZWFuZWRfc291cmNlZGF0YTsKICAgICAgfQoKICAgICAgdmFyIFJlc3VsdCA9IEdldENsZWFuU291cmNlZGF0YShzb3VyY2VkYXRhLCBjbGVhbmVkX3NvdXJjZWRhdGEsIG1peGVkaW1wdXJpdHkpOwogICAgICBjbGVhbmVkX3NvdXJjZWRhdGEgPSBSZXN1bHQ7CiAgICAgIGNvbnNvbGUubG9nKCdjbGVhbmVkX3NvdXJjZWRhdGE6ICcsIGNsZWFuZWRfc291cmNlZGF0YSk7IC8vU0VDVElPTiAtIFN0YXJ0IG9mIEJoYXJhdCBQYXJzZXIKICAgICAgLy9DaGVja2luZyBmb3IgdHlwZSBvZiBjaGFyYWN0ZXJzCgogICAgICB2YXIgaXNWYXJpYWJsZSA9IFR5cGVDaGVjay5pc1ZhcmlhYmxlKCk7CiAgICAgIHZhciBpc051bWJlciA9IFR5cGVDaGVjay5pc051bWJlcigpOwogICAgICB2YXIgaXNPcGVyYXRvciA9IFR5cGVDaGVjay5pc09wZXJhdG9yKCk7CiAgICAgIHZhciBpc0tleXdvcmQgPSBUeXBlQ2hlY2suaXNLZXl3b3JkKCk7CiAgICAgIHZhciBpc0NvbmRpdGlvbmFsS2V5d29yZCA9IFR5cGVDaGVjay5pc0NvbmRpdGlvbmFsS2V5d29yZCgpOwogICAgICB2YXIgaXNGb3JMb29wID0gVHlwZUNoZWNrLmlzRm9yTG9vcCgpOwogICAgICB2YXIgaXNXaGlsZUxvb3AgPSBUeXBlQ2hlY2suaXNXaGlsZUxvb3AoKTsgLy9uZWVkcyB3b3JrCgogICAgICB2YXIgaXNFeHByZXNzaW9uID0gVHlwZUNoZWNrLmlzRXhwcmVzc2lvbigpOwogICAgICB2YXIgaXNBcnJheSA9IFR5cGVDaGVjay5pc0FycmF5KCk7CiAgICAgIHZhciBpc1NldEFycmF5SW5kZXhWYWx1ZSA9IFR5cGVDaGVjay5pc1NldEFycmF5SW5kZXhWYWx1ZSgpOwogICAgICB2YXIgaXNFbXB0eUFycmF5SW5pdCA9IFR5cGVDaGVjay5pc0VtcHR5QXJyYXlJbml0KCk7CiAgICAgIHZhciBpc1N0cmluZyA9IFR5cGVDaGVjay5pc1N0cmluZygpOwogICAgICB2YXIgaXNQdXJlRXZhbCA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzUHVyZUV2YWwoKTsgLy9pZiBwYXJzZXIgZW5jb3VudGVycyBhbnl0aGluZyBsaWtlICgiIG9yICgsIHRoZW4gdGhhdCdzIGEgcmVhbHRpbWUgcHJpbnQuIAogICAgICAvL2J1aWxkc3RyaW5nIHdpbGwgYmUgYXBwbGllZCBub3cgdG8gY3JlYXRlIGEgc3RyaW5nIGFuZCBwdXNoIGl0IGludG8gdG9rZW5zCgogICAgICB2YXIgaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcgPSBBZHZhbmNlZFR5cGVDaGVjay5pc1JlYWxUaW1lUHJpbnRNdWx0aXBsZVN0cmluZygpOwogICAgICB2YXIgaXNTdHJpbmdhbmRWYWx1ZSA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzU3RyaW5nYW5kVmFsdWUoKTsKICAgICAgdmFyIGlzQ2FsY3VsYXRpb24gPSBBZHZhbmNlZFR5cGVDaGVjay5pc0NhbGN1bGF0aW9uKCk7CiAgICAgIHZhciBpc0RpcmVjdFByaW50QXJpdGhtZXRpYyA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzRGlyZWN0UHJpbnRBcml0aG1ldGljKCk7IC8vIHRvIHNvbHZlIFthLG4sbixhXSBpbnRvIFthbm5hXQogICAgICAvL1NFQ1RJT04gQnVpbGQgT3BlcmF0aW9ucyAKCiAgICAgIHZhciBCdWlsZFN0cmluZyA9IEJ1aWxkT3BlcmF0aW9uLkJ1aWxkU3RyaW5nKCk7CiAgICAgIHZhciBCdWlsZEFycmF5ID0gQnVpbGRPcGVyYXRpb24uQnVpbGRBcnJheSgpOwogICAgICB2YXIgQnVpbGRDb25kaXRpb24gPSBCdWlsZE9wZXJhdGlvbi5CdWlsZENvbmRpdGlvbigpOyAvL2NvdW50aW5nIGhvdyBtYW55IHRpbWVzIGRvIHdlIGhhdmUgJiYsIHx8IGNvbmRpdGlvbiBwcmVzZW50CgogICAgICBmdW5jdGlvbiBDb3VudChpdGVtLCBlbGVtZW50KSB7CiAgICAgICAgdmFyIGNvdW50ID0gMDsKCiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZW1lbnQubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICBpZiAoZWxlbWVudC5jaGFyQXQoX2kpID09IGl0ZW0gJiYgZWxlbWVudC5jaGFyQXQoX2kgKyAxKSA9PSBpdGVtKSB7CiAgICAgICAgICAgIGNvdW50ICs9IDE7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gY291bnQ7CiAgICAgIH0gLy9UaGlzIHdpbGwgcnVuIGZvciBldmVyeSBwcmludCBzdGF0ZW1lbnQgZW5jb3VudGVyZWQgaW4gdGhlIHByb2dyYW0sIG5vdCBqdXN0IGZvciBsb29wcwoKCiAgICAgIGZ1bmN0aW9uIElmVG9rZW5QcmludChUb2tlbnMsIGosIGdsb2JhbCwgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IpIHsKICAgICAgICB2YXIgdG9rZW4gPSBUb2tlbnNbal0udmFsdWU7CiAgICAgICAgdmFyIE5leHRUb2tlblZhbHVlID0gVG9rZW5zW2ogKyAxXS52YWx1ZTsKICAgICAgICB2YXIgU3RyaW5nVmFyID0gW107CiAgICAgICAgdmFyIGIgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSk7CgogICAgICAgIGlmIChpc1ZhcmlhYmxlKGIpKSB7CiAgICAgICAgICB2YXJpYWJsZXNfYXJyYXkucHVzaChiKTsgLy8gCiAgICAgICAgfSAvL1NFQ1RJT04gLSBPdXRwdXR0aW5nIHRoZSBjb2RlCiAgICAgICAgLy8gZmluZGluZyB0aGUgcmVsdmFudCB2YWx1ZSBhbmQgdGhlbiBvdXRwdXQgaXQgYXMgSFRNTAogICAgICAgIC8vVGhpcyBsb29wIGlzIG9ubHkgZm9yIHByaW50aW5nIGRpcmVjdCB2YWx1ZXMgbGlrZSBwcmludChuYW1lKSwgcHJpbnQoYXJyYXkpCgoKICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKGZ1bmN0aW9uIChlbCwgaSkgewogICAgICAgICAgLy9USElTIElTIFRIRSBSRUFMIEdBTUUKICAgICAgICAgIGlmIChlbC5uYW1lID09IGIpIHsKICAgICAgICAgICAgLy9mb3IgY2FsY3VsYXRpb25zIGxpa2UgeD1hZ2VvbmUrYWdldHdvCiAgICAgICAgICAgIC8vSWYgd2UgaGF2ZSBhbHJlYWR5IGNhbHVjdWxhdGVkIHZhbHVlLCB1c2UgdGhhdCBvciBlbHNlIG1vdmUgZm9yd2FyZAogICAgICAgICAgICBpZiAoYXNzaWduZWRfdmFyaWFibGVzLmluY2x1ZGVzKGVsKSkgewogICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgZWwudmFsdWUgKyAiXG4iOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGlmIChpc051bWJlcihlbC52YWx1ZSkpIHsKICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgZWwudmFsdWUgKyAiXG4iOwogICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwpOwogICAgICAgICAgICAgIH0gLy9vcGVyYXRpb25zIGxpa2UgYWdlPTIwMjAtMTk5NgoKCiAgICAgICAgICAgICAgaWYgKGlzUHVyZUV2YWwoZWwudmFsdWUpKSB7CiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0cHVyZSA9IGV2YWwoZWwudmFsdWUpOwogICAgICAgICAgICAgICAgZWwudmFsdWUgPSBvdXRwdXRwdXJlOwogICAgICAgICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyBvdXRwdXRwdXJlICsgIlxuIjsKICAgICAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsKTsKICAgICAgICAgICAgICB9IC8vb3BlcmF0aW9ucyBsaWtlIG5hbWU9InN3YW5hbmQga2FkYW0iLCB2YXJpYWJsZSBhc3NpZ25tZW50cyBhcyBzdHJpbmdzCgoKICAgICAgICAgICAgICBpZiAoIWlzUHVyZUV2YWwoZWwudmFsdWUpICYmICFpc051bWJlcihlbC52YWx1ZSkpIHsKICAgICAgICAgICAgICAgIGlmICghKGVsLm5hbWUuaW5jbHVkZXMoJ10nKSAmJiBlbC5uYW1lLmluY2x1ZGVzKCdbJykpKSB7CiAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgZWwudmFsdWUgKyAiXG4iOwogICAgICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vIHdvcmsgdG8gYmUgY29udGludWVkCgogICAgICAgIH0pOyAvL0FOQ0hPUiAtIENPTkRJVElPTiAyCgogICAgICAgIGlmIChUb2tlbnNbaiArIDFdLnR5cGUgPT0gJ0FycmF5JykgewogICAgICAgICAgLy9UbyBydW4gb25seSBpZiBpdGVyYXRvciBpcyBwcmVzZW50CiAgICAgICAgICAvL1RoaXMgcnVucyBvbiBmb3IgbG9vcCAtIFByaW50KEFycmF5W2FdKSBldGMKICAgICAgICAgIC8vdGhpcyBydW5zIG9ubHkgaWYgZm9yKGkpIGFuZCBpbiB0aGUgbG9vcCwgYXJyYXlbaV0sIG5vdCBvbiBhcnJheVt4XS4gSXRlcmF0b3IgYW5kIGluZGV4IHNob3VsZCBiZSBzYW1lCiAgICAgICAgICBpZiAoaXRlcmF0b3IgIT0gdW5kZWZpbmVkICYmIFRva2Vuc1tqICsgMV0uSW5kZXhJbnB1dCA9PSBPcmlnaW5hbEl0ZXJhdG9yKSB7CiAgICAgICAgICAgIHZhciBWYWx1ZSA9IE5leHRUb2tlblZhbHVlOwoKICAgICAgICAgICAgdmFyIF9BcnJheUVsZW1lbnQgPSBDcmVhdGVBcnJheUVsZW1lbnQoVmFsdWUsIGl0ZXJhdG9yKTsKCiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChfQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2Vucyk7CiAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgb3V0cHV0ICsgIlxuIjsKICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goVG9rZW5zW2ogKyAxXSk7CiAgICAgICAgICB9IC8vVGhpcyBydW5zIHRvIFByaW50KEFycmF5WzJdKSBsaWtlIHNwZWNpZmljIGFycmF5IHZhbHVlcwoKCiAgICAgICAgICBpZiAoVG9rZW5zW2pdLkluZGV4SW5wdXQgIT0gT3JpZ2luYWxJdGVyYXRvcikgewogICAgICAgICAgICAvLwogICAgICAgICAgICB2YXIgX1ZhbHVlID0gTmV4dFRva2VuVmFsdWU7CiAgICAgICAgICAgIHZhciBJbmRleFRvQ2hhbmdlID0gVG9rZW5zW2ogKyAxXS5JbmRleElucHV0OwoKICAgICAgICAgICAgdmFyIF9BcnJheUVsZW1lbnQyID0gQ3JlYXRlQXJyYXlFbGVtZW50KF9WYWx1ZSwgSW5kZXhUb0NoYW5nZSk7CgogICAgICAgICAgICB2YXIgX291dHB1dCA9IFByaW50QXJyYXlFbGVtZW50KF9BcnJheUVsZW1lbnQyLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgICBpZiAoX291dHB1dCAhPSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArIF9vdXRwdXQgKyAiXG4iOwogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vVGhpcyBjb2xsZWN0cyBwcmludChBcnJheVthXSkgZnJvbSBmb3IgbG9vcCBhbmQgbm9ybWFsIFByaW50KEFycmF5WzJdKQoKICAgICAgICB9IC8vcHJpbnRpbmcgZGlyZWN0IG51bWJlcnMgYW5kIGRpcmVjdCBjYWxjdWx0aW9ucyBsaWtlIHByaW50KDEwKSwgcHJpbnQoMTAqMTApCgoKICAgICAgICBpZiAodG9rZW4gPT0gJ+CkquCljeCksOCkv+CkguCknycgJiYgKGlzUHVyZUV2YWwoTmV4dFRva2VuVmFsdWUpIHx8IGlzTnVtYmVyKFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkpKSB7CiAgICAgICAgICB2YXIgYSA9IGV2YWwoTmV4dFRva2VuVmFsdWUpOwogICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyAiXG4iICsgYSArICJcbiI7CiAgICAgICAgfSAvL2Zvcm9wZXJhdGlvbnMgbGlrZSBwcmludCgneW91IGxpdmUsIHlvdSBsZWFybicpCgoKICAgICAgICBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09ICJSZWFsVGltZVByaW50IiAmJiAhTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJysnKSAmJiAhTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJz0nKSkgewogICAgICAgICAgdmFyIF9vdXRwdXQyID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpOwoKICAgICAgICAgIF9vdXRwdXQyID0gX291dHB1dDIucmVwbGFjZSgvIi9nLCAnJyk7CiAgICAgICAgICBfb3V0cHV0MiA9IF9vdXRwdXQyLnJlcGxhY2UoLycvZywgJycpOwogICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyAiXG4iICsgX291dHB1dDIgKyAiXG4iOwogICAgICAgIH0gLy9vcGVyYXRpb25zIGxpa2UgcHJpbnQoQWdlICsgJ2lzIHlvdW5nIGFnZScpCgoKICAgICAgICBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09ICJSZWFsVGltZVByaW50IiAmJiBOZXh0VG9rZW5WYWx1ZS5pbmNsdWRlcygnKycpKSB7CiAgICAgICAgICB2YXIgeCA9IFNwbGl0RWxlbWVudHNBcnJheShOZXh0VG9rZW5WYWx1ZSk7CiAgICAgICAgICBTdHJpbmdWYXIgPSBTZXRWYWx1ZXMoeCwgdXBkYXRlZF90b2tlbnMpOwogICAgICAgICAgU3RyaW5nVmFyID0gU3RyaW5nVmFyLmpvaW4oJycpOwogICAgICAgICAgU3RyaW5nVmFyID0gU3RyaW5nVmFyLnNwbGl0KCIrIik7CgogICAgICAgICAgdmFyIF9vdXRwdXQzID0gU3RyaW5nVmFyLmpvaW4oJyAnKTsKCiAgICAgICAgICBfb3V0cHV0MyA9IFJlbW92ZUJyYWNrZXRzKF9vdXRwdXQzKTsKICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgIlxuIiArIF9vdXRwdXQzICsgIlxuIjsKICAgICAgICB9IC8vVEhJUyBDT0RFIGlzIHRvIHJ1biBwcmludCBpbmRleCB2YWx1ZSBpbiBsb29wLCBlLmcgcHJpbnQoaSkgaWYgaXRlcmF0b3IgaXMgaS4gCiAgICAgICAgLy9SdW5zIG9ubHkgaW4gZm9yIGxvb3AKCgogICAgICAgIGlmIChPcmlnaW5hbEl0ZXJhdG9yID09IFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkgewogICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyAiXG4iICsgaXRlcmF0b3IgKyAiXG4iOwogICAgICAgIH0KCiAgICAgICAgaWYgKGlzQ2FsY3VsYXRpb24oUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSAmJiBUb2tlbnNbaiArIDFdLm1vZGUgIT0gIlJlYWxUaW1lUHJpbnQiKSB7CiAgICAgICAgICB2YXIgX291dHB1dDQgPSBDYWxjdWxhdGVWYWx1ZXMoTmV4dFRva2VuVmFsdWUsIGosIHVwZGF0ZWRfdG9rZW5zKTsKCiAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArICJcbiIgKyBfb3V0cHV0NCArICJcbiI7CiAgICAgICAgfSAvLyAKCiAgICAgIH0gLy9FTkQgT0YgRnVuY3Rpb25zIGFuZCBJbXBvcnRlZCBGdW5jdGlvbnMKICAgICAgLy9TRUNUSU9OIC0gUGFyc2luZyBTVEFSVFMgaGVyZQogICAgICAvL1NFQ1RJT04gLSBDaGVja2luZyBlYWNoIHRva2VuIGFuZCBhZGRpbmcgdG8gdG9rZW5zIGFycmF5CgoKICAgICAgdmFyIHRlbXB0aGlzID0gdGhpczsKICAgICAgdmFyIHZhcmlhYmxlQXJyYXkgPSBbXTsgLy9UTyBSRU1PVkUgRFVQTElDQVRFIFZBUklBQkxFUywgU0VFIDQ4MgoKICAgICAgZnVuY3Rpb24gUGFyc2UoY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSB7CiAgICAgICAgdmFyIGVsZW1lbnQgPSBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CiAgICAgICAgdmFyIHN0cmluZyA9IFtdOwoKICAgICAgICBpZiAoaXNWYXJpYWJsZShlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICBpZiAoY2xlYW5lZF9zb3VyY2VkYXRhW2kgKyAxXSA9PSAnPScpIHsKICAgICAgICAgICAgUHVzaFZhcmlhYmxlKGVsZW1lbnQsIHRva2Vucyk7CgogICAgICAgICAgICBpZiAodmFyaWFibGVBcnJheS5pbmNsdWRlcyhlbGVtZW50KSkgewogICAgICAgICAgICAgIHZhciBVcGRhdGVFbGVtZW50VmFsdWUgPSBlbGVtZW50OwogICAgICAgICAgICAgIHZhciB4ID0gdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZWwudmFsdWUgPT0gZWxlbWVudDsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0b2tlbnMuaW5kZXhPZih4KTsgLy8KCiAgICAgICAgICAgICAgUmVJbnRpYWxpemVkVmFyaWFibGVzLnB1c2goewogICAgICAgICAgICAgICAgbmFtZTogZWxlbWVudAogICAgICAgICAgICAgIH0pOyAvLwogICAgICAgICAgICAgIC8vdG9rZW5zW2luZGV4KzJdLnZhbHVlPSBjbGVhbmVkX3NvdXJjZWRhdGFbaSsyXQogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXJpYWJsZUFycmF5LnB1c2goZWxlbWVudCk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoaXNOdW1iZXIoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgUHVzaE51bWJlcihlbGVtZW50LCB0b2tlbnMpOwogICAgICAgIH0KCiAgICAgICAgaWYgKGlzT3BlcmF0b3IoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgUHVzaE9wZXJhdG9yKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgfQoKICAgICAgICBpZiAoaXNLZXl3b3JkKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgfSAvL2NoZWNrIGlmIGl0IGFjY3BldHMgQXJyeVsyYV0gYXMgaW5kZXggOiAKCgogICAgICAgIGlmIChpc0FycmF5KGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgIGlmIChlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDEpID09ICddJykgewogICAgICAgICAgICBQdXNoQXJyYXkoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHZhciBCdWlsdEFycmF5ID0gQnVpbGRBcnJheShlbGVtZW50LCBpLCBjbGVhbmVkX3NvdXJjZWRhdGEpOwogICAgICAgICAgICBQdXNoQXJyYXkoQnVpbHRBcnJheSwgdG9rZW5zKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChpc1NldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpID09IHRydWUpIHsKICAgICAgICAgIFB1c2hTZXRBcnJheUluZGV4VmFsdWUoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgIH0KCiAgICAgICAgaWYgKGlzRW1wdHlBcnJheUluaXQoZWxlbWVudCwgY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSA9PSB0cnVlKSB7CiAgICAgICAgICBQdXNoRW1wdHlBcnJheUluaXQodG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICAgIH0KCiAgICAgICAgaWYgKGlzQ29uZGl0aW9uYWxLZXl3b3JkKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgIGlmIChpc1doaWxlTG9vcChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgIFB1c2hXaGlsZUxvb3AoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOyAvLyBQdXNoV2hpbGVMb29wQ29uZGl0aW9uKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgUHVzaENvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgfQoKICAgICAgICAgIHZhciBmb3VuZGNvbmRpdGlvbiA9IEJ1aWxkQ29uZGl0aW9uKGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSk7CiAgICAgICAgICBjb25zb2xlLmxvZygnZm91bmRjb25kaXRpb246ICcsIGZvdW5kY29uZGl0aW9uKTsKICAgICAgICAgIFB1c2hDb25kaXRpb24oZm91bmRjb25kaXRpb24sIHRva2Vucyk7CiAgICAgICAgfQoKICAgICAgICBpZiAoaXNGb3JMb29wKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgIFB1c2hGb3JMb29wKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICBQdXNoRm9yTG9vcEFydWd1bWVudHMoZWxlbWVudCwgY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCB0b2tlbnMpOwogICAgICAgIH0KCiAgICAgICAgaWYgKGlzQ2FsY3VsYXRpb24oZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgdmFyIF9lbGVtZW50ID0gJyc7CgogICAgICAgICAgaWYgKGNsZWFuZWRfc291cmNlZGF0YVtpICsgMV0gIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcGVyZm9ybSBsb25nIG9wZXJhdGlvbnMgbGlrZSBBdmVyYWdlQWdlPShhZ2VvbmUrYWdldHdvKS8yICsgKGFnZW9uZSthZ2V0d28pKjIKICAgICAgICAgICAgd2hpbGUgKGlzQ2FsY3VsYXRpb24oY2xlYW5lZF9zb3VyY2VkYXRhW2ldKSkgewogICAgICAgICAgICAgIF9lbGVtZW50ID0gX2VsZW1lbnQgKyBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CiAgICAgICAgICAgICAgaSsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9IC8vUHVzaENhbGN1bGF0aW9uKGVsZW1lbnQsdG9rZW5zKQogICAgICAgICAgLy8gIAoKCiAgICAgICAgICB0ZXJtcyA9IF9lbGVtZW50LnNwbGl0KCcnKTsgLy9yZW1vdmluZyB0aGUgIigiIiBhbmQgIikiCgogICAgICAgICAgdmFyIENsZWFuZWRFbGVtZW50ID0gUmVtb3ZlQnJhY2tldHMoX2VsZW1lbnQpOyAvLyB0byBzdG9wIHByZXZlbnRpb24gb2YgZXhwcmVzc2lvbnMgbGlrZSBpcyIrIGdldHRpbmcgYWRkZWQgYXMgYSBjYWxjdWxhdGlvbgoKICAgICAgICAgIGlmICghQ2xlYW5lZEVsZW1lbnQuaW5jbHVkZXMoJyInKSAmJiBfZWxlbWVudC5jaGFyQXQoMCkgIT0gJy8nICYmIF9lbGVtZW50LmNoYXJBdCgwKSAhPSAnKicpIHsKICAgICAgICAgICAgUHVzaENhbGN1bGF0aW9uKF9lbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgfSAvLyB0ZXJtczIgPSBDbGVhbmVkRWxlbWVudC5zcGxpdChvcGVyYXRpb24pCiAgICAgICAgICAvL2NoZWNrcG9pbnQ6IHRvIHBlcmZvcm0gY2FsY3VsYXRpb25zIAogICAgICAgICAgLy9JIGhhdmUgaWRlbnRpZmllZCB0aGUgb3BlcmF0aW9uKHNlcGVyYXRlZCkgYW5kIHRlcm1zIChzZXBlcmF0ZWQpCgogICAgICAgICAgLyogICAgICB0ZW1wdGhpcy5PcGVyYXRpb25PYmplY3RzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICB0ZXJtczogdGVybXMyLAogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgKi8KCiAgICAgICAgfSAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIHByaW50KCJzd2FuYW5kIikuIFRoZSByZWFsdGltZXByaW50IG9wZXJhdGlvbnMKCgogICAgICAgIGlmIChpc1JlYWxUaW1lUHJpbnRNdWx0aXBsZVN0cmluZyhlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAvLwogICAgICAgICAgdmFyIGZvdW5kU3RyaW5nID0gJyc7CiAgICAgICAgICB2YXIgayA9IGk7CiAgICAgICAgICB2YXIgY29uZGl0aW9uRW5kID0gZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGggLSAxKSArIGVsZW1lbnQuY2hhckF0KGVsZW1lbnQubGVuZ3RoIC0gMik7CiAgICAgICAgICB2YXIgZmxhZyA9IDA7CgogICAgICAgICAgZm9yIChrOyBrIDwgY2xlYW5lZF9zb3VyY2VkYXRhLmxlbmd0aDsgaysrKSB7CiAgICAgICAgICAgIHZhciBfZWxlbWVudDIgPSBjbGVhbmVkX3NvdXJjZWRhdGFba107CgogICAgICAgICAgICB2YXIgX2NvbmRpdGlvbkVuZCA9IF9lbGVtZW50Mi5jaGFyQXQoX2VsZW1lbnQyLmxlbmd0aCAtIDEpICsgX2VsZW1lbnQyLmNoYXJBdChfZWxlbWVudDIubGVuZ3RoIC0gMik7CgogICAgICAgICAgICBpZiAoY2xlYW5lZF9zb3VyY2VkYXRhW2tdLmluY2x1ZGVzKCfgpKrgpY3gpLDgpL/gpILgpJ8nKSB8fCBjbGVhbmVkX3NvdXJjZWRhdGFba10uaW5jbHVkZXMoJ+CkheCkl+CksCcpKSB7CiAgICAgICAgICAgICAgLy9mb3VuZFN0cmluZz1mb3VuZFN0cmluZysgICcgJysgY2xlYW5lZF9zb3VyY2VkYXRhW2tdCiAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKF9jb25kaXRpb25FbmQgPT0gJykiJykgewogICAgICAgICAgICAgIGZvdW5kU3RyaW5nID0gZm91bmRTdHJpbmcgKyAnICcgKyBjbGVhbmVkX3NvdXJjZWRhdGFba107CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChmbGFnID09IDEpIHsKICAgICAgICAgICAgICBmb3VuZFN0cmluZyA9IGZvdW5kU3RyaW5nICsgJyAnICsgY2xlYW5lZF9zb3VyY2VkYXRhW2tdOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoZmxhZyA9PSAwKSB7CiAgICAgICAgICAgICAgZm91bmRTdHJpbmcgPSBjbGVhbmVkX3NvdXJjZWRhdGFba107CiAgICAgICAgICAgICAgZmxhZyA9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBpZiAoIWZvdW5kU3RyaW5nLmluY2x1ZGVzKCI+IikgJiYgIWZvdW5kU3RyaW5nLmluY2x1ZGVzKCcvJykgJiYgIWZvdW5kU3RyaW5nLmluY2x1ZGVzKCcqJykgJiYgIWZvdW5kU3RyaW5nLmluY2x1ZGVzKCc8JykgJiYgIWZvdW5kU3RyaW5nLmluY2x1ZGVzKCc9PScpKSB7CiAgICAgICAgICAgIC8vIAogICAgICAgICAgICBQdXNoUmVhbFRpbWVQcmludE9wZXJhdGlvbihmb3VuZFN0cmluZywgdG9rZW5zKTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGlmIChpc1N0cmluZ2FuZFZhbHVlKGVsZW1lbnQpID09IHRydWUpIHt9IC8vCiAgICAgICAgLy9zdG9yaW5nIG9ubHkgdGhlIHN0cmluZyB2YWx1ZXMgdG8gdG9rZW5zICggbm90IHRoZSBzdHJpbmdzIGluIHByaW50IHN0YXRlbWVudHMpCgoKICAgICAgICBpZiAoaXNTdHJpbmcoZWxlbWVudCkpIHsKICAgICAgICAgIHZhciBjYWxjdWxhdGVkU3RyaW5nID0gQnVpbGRTdHJpbmcoZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKTsKICAgICAgICAgIGNhbGN1bGF0ZWRTdHJpbmcgPSBjYWxjdWxhdGVkU3RyaW5nLnJlcGxhY2UoL1snIl0rL2csICcnKTsKICAgICAgICAgIGlmICghY2FsY3VsYXRlZFN0cmluZy5pbmNsdWRlcygi4KSq4KWN4KSw4KS/4KSC4KSfIikpIFB1c2hTdHJpbmcoY2FsY3VsYXRlZFN0cmluZywgdG9rZW5zKTsgLy8KICAgICAgICB9IC8vRm91bmQgU29sdXRpb24gdXNpbmcgcmVnZXhwLSBwcmludChhKSB3aXRob3V0IHNwYWNlIGlzIGdldHRpbmcgYWNjZXB0ZWQgYXMgZXhwcmVzc2lvbgoKCiAgICAgICAgaWYgKC9eKD89Lio/4KSq4KWN4KSw4KS/4KSC4KSfKSg/PS4qW2Etel0pLy50ZXN0KGVsZW1lbnQpKSB7CiAgICAgICAgICBQdXNoS2V5d29yZChlbGVtZW50LnNsaWNlKDAsIDYpLCB0b2tlbnMpOyAvL1B1c2hpbmcgcHJpbnQga2V5d29yZCBvbmx5CgogICAgICAgICAgUHVzaEV4cHJlc3Npb24oZWxlbWVudC5zbGljZSg2KSwgdG9rZW5zKTsgLy9QdXNoaW5nIHJlbWFpbmluZyBleHByZXNzaW9uIGxpa2UgKGEpLCAoZ2FnYWtzKSBldGMKICAgICAgICB9IC8vZXJyb3IgcHJvbmUgY2hhbmdlIG1hZGUgaGVyZQoKCiAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihlbGVtZW50KSA9PSB0cnVlICYmICFpc0NhbGN1bGF0aW9uKGVsZW1lbnQpICYmICFlbGVtZW50LmluY2x1ZGVzKCdbJykgJiYgIWVsZW1lbnQuaW5jbHVkZXMoJ10nKSAmJiAhaXNDb25kaXRpb25hbEtleXdvcmQoY2xlYW5lZF9zb3VyY2VkYXRhW2kgLSAxXSkgJiYgY2xlYW5lZF9zb3VyY2VkYXRhW2kgLSAxXSAhPSAn4KSu4KWHJykgewogICAgICAgICAgUHVzaEV4cHJlc3Npb24oZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICB9CgogICAgICAgIGlmIChpc0V4cHJlc3Npb24oZWxlbWVudCkgPT0gdHJ1ZSAmJiBlbGVtZW50LmluY2x1ZGVzKCdbJykgJiYgZWxlbWVudC5pbmNsdWRlcygnXScpKSB7CiAgICAgICAgICBQdXNoQXJyYXkoZWxlbWVudCwgdG9rZW5zKTsKICAgICAgICB9CgogICAgICAgIGlmICghaXNLZXl3b3JkKGVsZW1lbnQpICYmICFpc051bWJlcihlbGVtZW50KSAmJiAhaXNWYXJpYWJsZShlbGVtZW50KSAmJiAhaXNFeHByZXNzaW9uKGVsZW1lbnQpICYmICFpc09wZXJhdG9yKGVsZW1lbnQpKSB7CiAgICAgICAgICAvL0FOQ0hPUiAKCiAgICAgICAgICAvKkhuYWRsaW5nIEltcHVyaXR5IGVycm9yLVRoZSBtYWluIHByb2JsZW0gaXMgZmlndXJpbmcgb3V0IGhvdyB0byBzb2x2ZSAiPTcwMDAiIGxpa2UgdGhpbmdzCiAgICAgICAgICBpbnN0ZWFkIGFza2luZyBkZXZlbG9wZXJzIHRvIGFkZCBzcGFjZSBtYW51YWxseQogICAgICAgICAgSGFuZGxpbmcgQWxwaGFudW1lcmljIHN0cmluZ3MgdG8gc29sdmUgaXNzdWVzIGxpa2UgJyBhbm5hPTIzNjI5MzQnKi8KICAgICAgICAgIHZhciBpbXB1cml0eSA9IGVsZW1lbnQuc3BsaXQoJz0nKTsKICAgICAgICAgIHZhciBmaW5kU3RyaW5nID0gaW1wdXJpdHlbMV07IC8vdG8gYWNjZXB0IGxvbmcgbnVtYmVycyBpLmUgYT03NDkzNzQ1OTM3NDU5MzcKCiAgICAgICAgICBpZiAoaXNWYXJpYWJsZShpbXB1cml0eVswXSkgJiYgaXNOdW1iZXIoaW1wdXJpdHlbMV0pKSB7CiAgICAgICAgICAgIGltcHVyaXR5WzJdID0gaW1wdXJpdHlbMV07CiAgICAgICAgICAgIGltcHVyaXR5WzFdID0gJz0nOwogICAgICAgICAgfSAvL3RvIGFjY2VwdCBhPVNUUklORwoKCiAgICAgICAgICBpZiAoaXNWYXJpYWJsZShpbXB1cml0eVswXSkgJiYgaXNWYXJpYWJsZShpbXB1cml0eVsxXSkpIHsKICAgICAgICAgICAgaW1wdXJpdHlbMl0gPSBpbXB1cml0eVsxXTsKICAgICAgICAgICAgaW1wdXJpdHlbMV0gPSAnPSc7CiAgICAgICAgICB9CgogICAgICAgICAgaW1wdXJpdHkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaSkgewogICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgUHVzaFZhcmlhYmxlKGVsZW1lbnQsIHRva2Vucyk7IC8vY29udGludWU7CiAgICAgICAgICAgIH0gLy8gQU5DSE9SIAogICAgICAgICAgICAvL0lzc3VlOiBSaWdodCBub3csIG9ubHkgaXNOdW1iZXIgaXMgcmVzb2x2ZWQsIGE9LCA9MjM4MjhxdyBhcmVuJ3QgcmVzb2x2ZWQuCiAgICAgICAgICAgIC8vU29sdXRpb246IFdvcmsgb24gYWxsIHRoZSBtb2R1bGVzCgoKICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICBQdXNoTnVtYmVyKGVsZW1lbnQsIHRva2Vucyk7CiAgICAgICAgICAgIH0gLy9BTkNIT1IgCiAgICAgICAgICAgIC8vWW91IG1pZ2h0IGhhdmUgdG8gcmVtb3ZlIHRoaXMgZXh0cmEgZmlsdGVycyBzaW5jZSB5b3UgYXJlIG9ubHkgd29ya2luZyBvbiBudW1iZXJzIChGdXR1cmUgSXNzdWUpCgoKICAgICAgICAgICAgaWYgKGlzT3BlcmF0b3IoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgIFB1c2hPcGVyYXRvcihlbGVtZW50LCB0b2tlbik7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChpc0tleXdvcmQoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAoaXNFeHByZXNzaW9uKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICBQdXNoRXhwcmVzc2lvbihlbGVtZW50LCB0b2tlbnMpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH0gLy9TRUNUSU9OIC0gQ2hlY2tpbmcgZWFjaCB0b2tlbiBhbmQgYWRkaW5nIHRvIHRva2VucyBhcnJheQogICAgICAvLyBQQVJTSU5HIElOSVRJQVRJT04KCgogICAgICBmb3IgKGk7IGkgPCBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOyBpKyspIHsKICAgICAgICBQYXJzZShjbGVhbmVkX3NvdXJjZWRhdGEsIGkpOwogICAgICB9IC8vQU5DSE9SIAogICAgICAvL0NMRUFOSU5HIFVQIFRIRSBUT0tFTlMgQVJSQVkKICAgICAgLy9SZW1vdmluZyB0b2tlbnMgd2l0aCB2YWx1ZSA9ICcnLCBJdCB3YXMgZ2VuZXJhdGVkIGR1ZSB0byAiIGNsZWFuZWRfc291cmNlZGF0YSA9IGNsZWFuZWRfc291cmNlZGF0YS5yZXBsYWNlKC8oO3xcbnxccikvZ20sICIgIikuc3BsaXQoJyAnKSIKCgogICAgICB0b2tlbnMgPSB0b2tlbnMuZmlsdGVyKGZ1bmN0aW9uIChlbCkgewogICAgICAgIHJldHVybiBlbC52YWx1ZSAhPSAnJzsKICAgICAgfSk7CiAgICAgIGNvbnNvbGUubG9nKCd0b2tlbnM6ICcsIHRva2Vucyk7IC8vVG8gZmluZCB1bmRlZmluZWQgdmFyaWFibGVzCgogICAgICB2YXIgZGlmZmVyZW5jZSA9IHZhcmlhYmxlc19hcnJheS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsKICAgICAgICByZXR1cm4gIWFzc2lnbmVkX3ZhcmlhYmxlcy5pbmNsdWRlcyh4KTsKICAgICAgfSk7IC8vCgogICAgICBpZiAoZGlmZmVyZW5jZS5sZW5ndGggPiAwKSB7CiAgICAgICAgdGhpcy5lcnJvci5wdXNoKCcgVmFyaWFibGUgJyArIGRpZmZlcmVuY2UudG9TdHJpbmcoKS5zcGxpdCgnLCcpICsgJyBpcyB1bmRlZmluZWQgJyk7CiAgICAgIH0gLy9TRUNUSU9OIC0gUHJpbnRpbmcgT3V0cHV0cywgY29uc2lkZXJpbmcgY29uZGl0aW9ucywgZmluZGluZyB2YWx1ZXMgaW4gdXBkYXRlZF90b2tlbnMKCgogICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykgewogICAgICAgIC8vIENoZWNraW5nIGZvciBhc3NpZ25tZW50IG9wZXJhdG9ycwogICAgICAgIHZhciBtdXRhYmxlX3Rva2VucyA9IHRva2VuczsKICAgICAgICB2YXIgdG9rZW4gPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZTsKICAgICAgICB2YXIgdG9rZW5UeXBlID0gbXV0YWJsZV90b2tlbnNbal0udHlwZTsKICAgICAgICB2YXIgU3RyaW5nVmFyID0gW107CiAgICAgICAgdmFyIFZhcldpdGhvdXRicmFja2V0cyA9IFJlbW92ZUJyYWNrZXRzKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlKTsKICAgICAgICBWYXJXaXRob3V0YnJhY2tldHMgPSBWYXJXaXRob3V0YnJhY2tldHMucmVwbGFjZSgvIC9nLCAnJyk7CgogICAgICAgIGlmIChtdXRhYmxlX3Rva2Vuc1tqXS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKSB7CiAgICAgICAgICB2YXIgVmFsdWVUb1NldCA9IG11dGFibGVfdG9rZW5zW2pdLlZhbHVlVG9TZXQ7CiAgICAgICAgICB2YXIgeCA9IEdldEFycmF5b3JTdHJpbmdFbGVtZW50KG11dGFibGVfdG9rZW5zW2pdLnZhbHVlLCB1cGRhdGVkX3Rva2VucywgVmFsdWVUb1NldCk7CiAgICAgICAgfQoKICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbal0udmFsdWUgPT0gJz0nKSB7CiAgICAgICAgICAoZnVuY3Rpb24gKCkgewogICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCiAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG11dGFibGVfdG9rZW5zW2ogLSAxXS52YWx1ZTsgLy8KCiAgICAgICAgICAgIHZhciB2YXJ2YWx1ZSA9IG11dGFibGVfdG9rZW5zW2ogKyAxXS52YWx1ZTsgLy8KICAgICAgICAgICAgLy9maW5kaW5nIGlmIGVsZW1lbnRzIGlzIGFscmVhZHkgYXNzZ2luZWQgaW4gdXBkYXRlZCB0b2tlbnMKICAgICAgICAgICAgLy90byBzb2x2ZSBuYW1lPSdzd2FuYW5kJyBhbmQgbmFtZT0gJ290aGVyIHN3YW5hbmQnCiAgICAgICAgICAgIC8vYm90aCBzaHB1bGQgYmUgcHJpbnRlZCBhY2NvcmRpbmdnbHkKCiAgICAgICAgICAgIHZhciBuID0gdXBkYXRlZF90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwsIGkpIHsKICAgICAgICAgICAgICByZXR1cm4gZWwubmFtZSA9PSB2YXJpYWJsZTsKICAgICAgICAgICAgfSk7IC8vIAoKICAgICAgICAgICAgaWYgKG4gPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgLy90byBjaGVjayBpZiB0aGUgYXNzaWduZWQgdmFsdWUgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC4gdGhpcyBpcyBmdXRoZXIgZGl2ZWRlZCBpbiB0d28gdHlwZXMKICAgICAgICAgICAgICBpZiAoaXNDYWxjdWxhdGlvbih2YXJ2YWx1ZSkpIHsKICAgICAgICAgICAgICAgIC8vdHlwZSAxLSBBZ2U9IDIwMjAtMjAwMCAKICAgICAgICAgICAgICAgIGlmIChpc1B1cmVFdmFsKHZhcnZhbHVlKSkgewogICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBldmFsKHZhcnZhbHVlKTsgLy93cml0ZSBmdW5jdGlvbiBmb3IgdGhpcywgc28gcmVwZWF0YWJsZQoKICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFyaWFibGUsCiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLAogICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGosCiAgICAgICAgICAgICAgICAgICAgdHlwZTogbXV0YWJsZV90b2tlbnNbaiArIDFdLnR5cGUKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9IC8vdHlwZSAyLSBYPSBhZ2VvbmUrYWdldHdvCiAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAvL3BlcmZvcm1pbmcgdGhlIGNhbGN1bGF0aW9uCiAgICAgICAgICAgICAgICAgICAgLy8gCiAgICAgICAgICAgICAgICAgICAgdmFyIF92YWx1ZSA9IENhbGN1bGF0ZVZhbHVlcyh2YXJ2YWx1ZSwgaiwgdXBkYXRlZF90b2tlbnMpOwoKICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhcmlhYmxlLAogICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92YWx1ZSwKICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGosCiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtdXRhYmxlX3Rva2Vuc1tqICsgMV0udHlwZQogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSAvL2lmIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlLCBwdXNoIHZhbHVlcyBhcyBpdCBpcwogICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YXJpYWJsZSwKICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFydmFsdWUsCiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiwKICAgICAgICAgICAgICAgICAgICB0eXBlOiBtdXRhYmxlX3Rva2Vuc1tqICsgMV0udHlwZQogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSAvL2lmIGl0J3MgYWxyZWFkeSBhc3NnaW5lZCwgcmVhc3NpZ24gaXQgd2l0aCB1cGRhdGVkIHZhbHVlCiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgaWYgKGlzQ2FsY3VsYXRpb24odmFydmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgIHZhciBOZXdWYWx1ZSA9IENhbGN1bGF0ZVZhbHVlcyh2YXJ2YWx1ZSwgaiwgdXBkYXRlZF90b2tlbnMpOwogICAgICAgICAgICAgICAgICBuLnZhbHVlID0gTmV3VmFsdWU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICBuLnZhbHVlID0gdmFydmFsdWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSAvLwogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyAKCiAgICAgICAgICB9KSgpOwogICAgICAgIH0KCiAgICAgICAgaWYgKHRva2VuVHlwZSA9PSAnY29uZGl0aW9uJykgewogICAgICAgICAgdmFyIGVsZW1lbnQgPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZTsgLy90aGlzIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBzdGVwIHRvIGhhbmRsbGUgb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCgogICAgICAgICAgdmFyIENvbmRpdGlvblZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoZWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGopOyAvL2NvbnNvbGUubG9nKCdDb25kaXRpb25WYWx1ZTogJywgQ29uZGl0aW9uVmFsdWUpOwogICAgICAgICAgLy9pZiB2YWx1ZSBpcyBmYWxzZSwganVzdCBza2lwIHRoZSBpZiBsb29wIGNvbnRleHQsIGlmIG5vdCBpdCB3aWxsIGJlIHJhbiBpbiBmaW5hbCBwcmludCBtb2R1bGUKCiAgICAgICAgICBpZiAoQ29uZGl0aW9uVmFsdWUgPT0gZmFsc2UpIHsKICAgICAgICAgICAgdmFyIEluaXRpYWxpemVMb29wID0gdG9rZW5zLmluZGV4T2YobXV0YWJsZV90b2tlbnNbal0pOwoKICAgICAgICAgICAgd2hpbGUgKG11dGFibGVfdG9rZW5zW2ogKyAxXS52YWx1ZSAhPSAnfScpIHsKICAgICAgICAgICAgICAvL3Rva2Vucy5zcGxpY2UoaisxLCAxKTsKICAgICAgICAgICAgICAvL05vIG5lZWQgdG8gZGVsZXRlIHRva2Vucywgd2UgYXJlIGp1c3Qgc2tpcHBpbmcgb3ZlciB0aGUgdmFsdWVzIHNvIHRoYXQgdGhleSB3b24ndCBiZSBwcmludGVkIG9yIHJ1bgogICAgICAgICAgICAgIGorKzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKSB7CiAgICAgICAgICBJZlRva2VuUHJpbnQobXV0YWJsZV90b2tlbnMsIGosIHRoaXMpOyAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCiAgICAgICAgfQoKICAgICAgICBpZiAodG9rZW5UeXBlID09ICdXaGlsZUxvb3BTdGFydCcpIHsKICAgICAgICAgIChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBoYW5kbGxlIG9wZXJhdGlvbnMgbGlrZSDgpIXgpJfgpLAgKGFnZW9uZT09MTAgJiYgQXZlcmFnZUFnZTwxMDAwICYmIGFnZXR3bz4xMDAgfHwgYWdlb25lPT0xMCkgT1IgKGFnZW9uZT09MTAgKQogICAgICAgICAgICB2YXIgZ2V0TG9vcEluZGV4U3RhcnQgPSBmdW5jdGlvbiBnZXRMb29wSW5kZXhTdGFydChtdXRhYmxlX3Rva2VucywgaiwgY2hlY2ssIHNldEluZGV4KSB7CiAgICAgICAgICAgICAgd2hpbGUgKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlICE9IGNoZWNrKSB7CiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlID09IGNoZWNrKSB7CiAgICAgICAgICAgICAgICAgIHNldEluZGV4ID0gaiArIDE7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaisrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIHNldEluZGV4OwogICAgICAgICAgICB9OwoKICAgICAgICAgICAgdmFyIGdldFdoaWxlTG9vcFNvdXJjZWRhdGEgPSBmdW5jdGlvbiBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICB2YXIgZmxhZyA9IHRydWU7CgogICAgICAgICAgICAgIHdoaWxlIChmbGFnKSB7CiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbc3RhcnRJbmRleF0udmFsdWUgPT0gJ3snKSB7CiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzdGFydEluZGV4OiAnLCBzdGFydEluZGV4KTsKCiAgICAgICAgICAgICAgICAgIHdoaWxlIChtdXRhYmxlX3Rva2Vuc1tzdGFydEluZGV4XS52YWx1ZSAhPSAnfScpIHsKICAgICAgICAgICAgICAgICAgICBTdG9yZVJlc3VsdC5wdXNoKG11dGFibGVfdG9rZW5zW3N0YXJ0SW5kZXggKyAxXSk7CiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCsrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKG11dGFibGVfdG9rZW5zW3N0YXJ0SW5kZXhdLnZhbHVlID09ICd9JykgewogICAgICAgICAgICAgICAgICAvLyAgCiAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgrKzsKICAgICAgICAgICAgICB9IC8vdGhpcyBsaW5lIGlzIGltcG9ydGFudC4gV2UgYXJlIHNraXBwaW5nIHRoZSBpbmRleCBvZiBtdXRhYmxlIHRva2VucyB1bnRpbCBmb3Jsb29wIGlzIGNvbXBsZXRlZC4gVGhpcyBpcyBkb25lIHRvIGhhdmUgc2VwcmF0ZSBmb3IgbG9vcCBjb250ZXh0IGFuZCBvdGhlCiAgICAgICAgICAgICAgLy9vdGhlciBmdWN0aW9ucyBzaG91bGQgbm90IGludGVydmVuZSBpbiBmb3IgbG9vcCBleGVjdXRpb24KCgogICAgICAgICAgICAgIGogPSBzdGFydEluZGV4ICsgMTsKICAgICAgICAgICAgICByZXR1cm4gU3RvcmVSZXN1bHQ7CiAgICAgICAgICAgIH07CgogICAgICAgICAgICB2YXIgVG9rZW5zQ3VycmVudEluZGV4ID0gaiArIDM7CiAgICAgICAgICAgIHZhciBDb25kaXRpb25WYWx1ZSA9IGZhbHNlOwogICAgICAgICAgICB2YXIgZWxlbWVudCA9IG11dGFibGVfdG9rZW5zW2ogKyAxXS52YWx1ZTsKICAgICAgICAgICAgdmFyIEV4dHJhdGNlZFZhcmlhYmxlID0gW107CiAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9ICcnOwogICAgICAgICAgICB2YXIgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSAwOwogICAgICAgICAgICB2YXIgV2hpbGVMb29wU291cmNlZGF0YVRva2VucyA9IFtdOwoKICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlbWVudC5sZW5ndGg7IF9pMisrKSB7CiAgICAgICAgICAgICAgdmFyIF94ID0gZWxlbWVudC5jaGFyQXQoX2kyKTsKCiAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoX3gpKSB7CiAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IHZhcmlhYmxlICsgX3g7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBpZiAoIWlzVmFyaWFibGUoZWxlbWVudC5jaGFyQXQoX2kyICsgMSkpICYmIGlzVmFyaWFibGUoX3gpKSB7CiAgICAgICAgICAgICAgICB2YXIgX3Rva2VuID0gdXBkYXRlZF90b2tlbnMuZmluZChmdW5jdGlvbiAoZWwpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT0gdmFyaWFibGU7CiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBFeHRyYXRjZWRWYXJpYWJsZS5wdXNoKHsKICAgICAgICAgICAgICAgICAgdmFyaWFibGU6IHZhcmlhYmxlLAogICAgICAgICAgICAgICAgICB2YWx1ZTogX3Rva2VuLnZhbHVlCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gJyc7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsgLy8KCiAgICAgICAgICAgIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBtdXRhYmxlX3Rva2VucywgJ30nLCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zKTsgLy9jb25zdGFudGx5IGFjY2Vzc2luZyB0aGUgY29uZGl0aW9udmFsdWUKCiAgICAgICAgICAgIHdoaWxlIChHZXRDb25kaXRpb25WYWx1ZShlbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaiArIDEpKSB7CiAgICAgICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgV2hpbGVMb29wU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pMysrKSB7CiAgICAgICAgICAgICAgICAvL1NFQ1RJT04gd2hpbGUgbG9vcCBjb250ZXh0CiAgICAgICAgICAgICAgICBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tfaTNdLnZhbHVlID09ICc9JykgewogICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBfaTMsIHVwZGF0ZWRfdG9rZW5zKTsgLy8KICAgICAgICAgICAgICAgICAgLy8gCiAgICAgICAgICAgICAgICB9IC8vIEhhbmRsaW5nIENPTkRJVElPTkFMIHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKCgogICAgICAgICAgICAgICAgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2kzXS50eXBlID09ICdjb25kaXRpb24nKSB7CiAgICAgICAgICAgICAgICAgIEhhbmRsZUNvbmRpdGlvbnMoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgX2kzLCB1cGRhdGVkX3Rva2Vucyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbX2kzXS52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykgewogICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQobXV0YWJsZV90b2tlbnMsIFRva2Vuc0N1cnJlbnRJbmRleCArIF9pMywgX3RoaXMpOyAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9KSgpOwogICAgICAgIH0KCiAgICAgICAgaWYgKHRva2VuVHlwZSA9PSAnRm9yTG9vcFN0YXJ0JykgewogICAgICAgICAgdmFyIEl0ZXJhdGlvblN0YXJ0OwogICAgICAgICAgdmFyIEl0ZXJhdGlvbkVuZDsKICAgICAgICAgIHZhciBlbGVtZW50VmFsdWU7CiAgICAgICAgICB2YXIgZWxlbWVudExlbmd0aDsKICAgICAgICAgIHZhciBGbGFnUHJpbWFsTG9vcDsKICAgICAgICAgIHZhciBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQ7CiAgICAgICAgICB2YXIgU291cmNlZGF0YVRva2VuczsKICAgICAgICAgIHZhciBPcmlnaW5hbEl0ZXJhdG9yOwogICAgICAgICAgdmFyIEFycmF5RWxlbWVudDsKCiAgICAgICAgICAoZnVuY3Rpb24gKCkgewogICAgICAgICAgICAvLwogICAgICAgICAgICB2YXIgZ2V0TG9vcEluZGV4U3RhcnQgPSBmdW5jdGlvbiBnZXRMb29wSW5kZXhTdGFydChtdXRhYmxlX3Rva2VucywgaiwgY2hlY2ssIHNldEluZGV4KSB7CiAgICAgICAgICAgICAgd2hpbGUgKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlICE9IGNoZWNrKSB7CiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlID09IGNoZWNrKSB7CiAgICAgICAgICAgICAgICAgIHNldEluZGV4ID0gaiArIDE7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaisrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIHNldEluZGV4OwogICAgICAgICAgICB9OwoKICAgICAgICAgICAgdmFyIGdldFNvdXJjZWRhdGEgPSBmdW5jdGlvbiBnZXRTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKICAgICAgICAgICAgICB2YXIgZmxhZyA9IHRydWU7CgogICAgICAgICAgICAgIHdoaWxlIChmbGFnKSB7CiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbc3RhcnRJbmRleF0udmFsdWUgPT0gJ3snKSB7CiAgICAgICAgICAgICAgICAgIHdoaWxlIChtdXRhYmxlX3Rva2Vuc1tzdGFydEluZGV4XS52YWx1ZSAhPSAnfScpIHsKICAgICAgICAgICAgICAgICAgICBTdG9yZVJlc3VsdC5wdXNoKG11dGFibGVfdG9rZW5zW3N0YXJ0SW5kZXggKyAxXSk7CiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCsrOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKG11dGFibGVfdG9rZW5zW3N0YXJ0SW5kZXggKyAxXS52YWx1ZSA9PSAnfScpIHsKICAgICAgICAgICAgICAgICAgLy8gIAogICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBzdGFydEluZGV4Kys7CiAgICAgICAgICAgICAgfSAvL3RoaXMgbGluZSBpcyBpbXBvcnRhbnQuIFdlIGFyZSBza2lwcGluZyB0aGUgaW5kZXggb2YgbXV0YWJsZSB0b2tlbnMgdW50aWwgZm9ybG9vcCBpcyBjb21wbGV0ZWQuIFRoaXMgaXMgZG9uZSB0byBoYXZlIHNlcHJhdGUgZm9yIGxvb3AgY29udGV4dCBhbmQgb3RoZQogICAgICAgICAgICAgIC8vb3RoZXIgZnVjdGlvbnMgc2hvdWxkIG5vdCBpbnRlcnZlbmUgaW4gZm9yIGxvb3AgZXhlY3V0aW9uCgoKICAgICAgICAgICAgICBqID0gc3RhcnRJbmRleCArIDE7CiAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0OwogICAgICAgICAgICB9OwoKICAgICAgICAgICAgLy9HZXR0aW5nIGV2cnkgaW5mb3JtYXRpb24gYWJvdXQgZm9yIGxvb3AgCiAgICAgICAgICAgIHZhciBGb3JMb29wTWV0YURhdGEgPSBtdXRhYmxlX3Rva2Vuc1tqICsgMV07IC8vU3BsaXR0aW5nIHRoZSBmb3Jsb29wbWV0YWRhdCB2YWx1ZXMgaW5kaXZpZHVhbGx5CgogICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBGb3JMb29wTWV0YURhdGEuaXRlcmF0b3I7CiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gRm9yTG9vcE1ldGFEYXRhLnZhbHVlOwogICAgICAgICAgICBJdGVyYXRpb25TdGFydCA9IHBhcnNlSW50KEZvckxvb3BNZXRhRGF0YS5pdGVyYXRpb25TdGFydCk7CiAgICAgICAgICAgIEl0ZXJhdGlvbkVuZCA9IHBhcnNlSW50KEZvckxvb3BNZXRhRGF0YS5pdGVyYXRpb25FbmQpOyAvLyBsZXQgRm9yTG9vcFNvdXJjZWRhdGEgPSBGb3JMb29wTWV0YURhdGEuRm9yTG9vcFNvdXJjZWRhdGEKICAgICAgICAgICAgLy8KCiAgICAgICAgICAgIGVsZW1lbnRWYWx1ZSA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZnVuY3Rpb24gKGVsKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGVsLm5hbWUgPT0gZWxlbWVudDsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGVsZW1lbnRMZW5ndGggPSAwOwogICAgICAgICAgICBGbGFnUHJpbWFsTG9vcCA9IDA7CiAgICAgICAgICAgIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IDA7CiAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnMgPSBbXTsKICAgICAgICAgICAgT3JpZ2luYWxJdGVyYXRvciA9IEZvckxvb3BNZXRhRGF0YS5pdGVyYXRvcjsKICAgICAgICAgICAgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQobXV0YWJsZV90b2tlbnMsIGosICd7JywgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KTsgLy8KCiAgICAgICAgICAgIFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRTb3VyY2VkYXRhKEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgbXV0YWJsZV90b2tlbnMsICd9JywgU291cmNlZGF0YVRva2Vucyk7CgogICAgICAgICAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygnKCcpICYmIGVsZW1lbnQuaW5jbHVkZXMoJywnKSkgewogICAgICAgICAgICAgIEZsYWdQcmltYWxMb29wID0gMTsgLy9zaGFsbCB3ZSBjZWVhdGUgYSBmb3Jsb29wIGNvbnRleHQgaGVyZT8KICAgICAgICAgICAgfSAvLyBSdW4gaWYgc3RhcnQgYW5kIGVuZCBwYXJhbWV0ZXJzIGFyZSBub3QgZ2l2ZW4gZS5nIOCkpuClgeCkueCksOCkvuCkkyBhIOCkleCliyAgTmFtZSDgpK7gpYcgCiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmFuIGp1c3QgdG8gZ2V0IFN0YXJ0IGFuZCBFbmQgcGFyYW1ldGVycyBhcyB0aGV5IGFyZSBub3QgcHJvdmlkZWQKCgogICAgICAgICAgICBpZiAoRm9yTG9vcE1ldGFEYXRhLml0ZXJhdGlvbkVuZCA9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAvL3J1biBpZiBlbGVtZW50IGlzIGFycmF5CiAgICAgICAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZS50eXBlID09ICdBcnJheScpIHsKICAgICAgICAgICAgICAgIGVsZW1lbnRMZW5ndGggPSBlbGVtZW50VmFsdWUudmFsdWUuc3BsaXQoJywnKS5sZW5ndGg7CiAgICAgICAgICAgICAgICBJdGVyYXRpb25TdGFydCA9IDA7CiAgICAgICAgICAgICAgICBJdGVyYXRpb25FbmQgPSBlbGVtZW50TGVuZ3RoOwogICAgICAgICAgICAgIH0gLy9ydW4gaWYgZWxlbWVudCBpcyBTdHJpbmcKICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgZWxlbWVudExlbmd0aCA9IGVsZW1lbnRWYWx1ZS52YWx1ZS5sZW5ndGg7CiAgICAgICAgICAgICAgICAgIEl0ZXJhdGlvblN0YXJ0ID0gMDsKICAgICAgICAgICAgICAgICAgSXRlcmF0aW9uRW5kID0gZWxlbWVudExlbmd0aDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIEN5Y2xlID0gSXRlcmF0aW9uRW5kOyAvL0l0ZXJhdGluZyBvdmVyIGZvcmxvb3Agc291cmNlZGF0YQoKICAgICAgICAgICAgZm9yIChpdGVyYXRvciA9IEl0ZXJhdGlvblN0YXJ0OyBpdGVyYXRvciA8IEN5Y2xlOyBpdGVyYXRvcisrKSB7CiAgICAgICAgICAgICAgLy9mbGFnIHRvIGF2b2lkIHJ1bm5pbmcgdGhpcyBjb2RlIGlmIGxvb3AgaXMgcHJpbWFsIGJlY2F1c2UgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgY29tcGVsdGVseSBkaWZmZXJlbnQKICAgICAgICAgICAgICBpZiAoRmxhZ1ByaW1hbExvb3AgPSAwKSB7CiAgICAgICAgICAgICAgICBGb3JMb29wQXJyYXlvclN0cmluZ091dHB1dChlbGVtZW50VmFsdWUsIGl0ZXJhdG9yLCB1cGRhdGVkX3Rva2VucywgX3RoaXMpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IF9pNCsrKSB7CiAgICAgICAgICAgICAgICBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTRdLnZhbHVlID09ICc9JykgewogICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCiAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKFNvdXJjZWRhdGFUb2tlbnMsIF9pNCwgdXBkYXRlZF90b2tlbnMpOwogICAgICAgICAgICAgICAgfSAvL0hhbmRsaW5nIHByaW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKCgogICAgICAgICAgICAgICAgaWYgKFNvdXJjZWRhdGFUb2tlbnNbX2k0XS52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykgewogICAgICAgICAgICAgICAgICAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCiAgICAgICAgICAgICAgICAgIElmVG9rZW5QcmludChTb3VyY2VkYXRhVG9rZW5zLCBfaTQsIF90aGlzLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcik7IC8vCiAgICAgICAgICAgICAgICB9IC8vSGFuZGxpbmcgc2V0IGFycmF5IGVsZW1lbnQgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAoKCiAgICAgICAgICAgICAgICBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTRdLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIpIHsKICAgICAgICAgICAgICAgICAgdmFyIFZhbHVlID0gU291cmNlZGF0YVRva2Vuc1tfaTRdLnZhbHVlOwogICAgICAgICAgICAgICAgICB2YXIgX1ZhbHVlVG9TZXQgPSBTb3VyY2VkYXRhVG9rZW5zW19pNF0uVmFsdWVUb1NldDsKCiAgICAgICAgICAgICAgICAgIHZhciBfZWxlbWVudDMgPSBSZW1vdmVCcmFja2V0cyhWYWx1ZSk7CgogICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSAnJzsgLy9TZXByYXRpbmcgb3V0IGluZGV4IGlkZW50aWZpZXIuIHh5eiBmcm9tIEFycmF5W3h5el0KCiAgICAgICAgICAgICAgICAgIF9lbGVtZW50MyA9IF9lbGVtZW50My5yZXBsYWNlKCddJywgJycpOwoKICAgICAgICAgICAgICAgICAgdmFyIFNwbGl0ID0gX2VsZW1lbnQzLnNwbGl0KCdbJyk7IC8vIHJ1biBpZiB3ZSBuZWVkIHRvIHNldCBkaXJlY3QgQXJyYXkgZWxlbWVudCB2YWx1ZS4gbGlrZSBBcnJheVsyXT0geHl4ICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoU3BsaXRbMV0pKSB7CiAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJyk7IC8vCgogICAgICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQgKyAnXSc7CiAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gU3BsaXQ7CiAgICAgICAgICAgICAgICAgIH0gLy8gcnVuIGlmIHdlIG5lZWQgdG8gZHluYW1pY2FsbHkgc2V0IEFycmF5IGVsZW1lbnQgdmFsdWUuIGxpa2UgQXJyYXlbaV09IHh5eAogICAgICAgICAgICAgICAgICAvL0NyZWF0ZUFycmF5RWxlbWVudCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBkeW5hbWljIEFycmF5IHZhbHVlcy4gbGlrZSBBcnJheVswXSwgQXJyYXlbMV0gZXRjLiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KFZhbHVlLCBpdGVyYXRvcik7CiAgICAgICAgICAgICAgICAgICAgfSAvLyB0aGlzIGNvZGUgaXMgd3JpdHRlbiB0byBmaW5kIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT0gYSoxMDArYWdlKmEuIG5vdGljZSBhCiAgICAgICAgICAgICAgICAgIC8vZmluZCBhIHdheSB0byBzaW1wbGlmeSB0aGlzIGluIGxvbmcgdGVybQoKCiAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gX1ZhbHVlVG9TZXQ7CiAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcqJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJysnKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLScpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcvJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJywnKTsgLy9idWlsZGluZyBhIG5ldyB2YWx1ZSB0byBjb252ZXJ0IGEqMTAwK2FnZSphIGludG8gNSoxMDArYWdlKmEgYW5kIHRoZW4gc2VuZGluZyBpdCB0byBDYWxjdWxhdGVWYWx1ZXMoKQoKICAgICAgICAgICAgICAgICAgdmFyIE5ld1ZhbHVlVG9TZXQgPSAnJzsgLy8gCgogICAgICAgICAgICAgICAgICBpZiAoZGF0YS5pbmNsdWRlcyhTcGxpdFsxXSkgJiYgZGF0YS5sZW5ndGggPiAxKSB7CiAgICAgICAgICAgICAgICAgICAgLy93ZSBoYXZlIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT0gYSoxMDArYWdlKmEuIG5vdGljZSBhCiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBfVmFsdWVUb1NldC5sZW5ndGg7IG0rKykgewogICAgICAgICAgICAgICAgICAgICAgaWYgKF9WYWx1ZVRvU2V0W21dID09IFNwbGl0WzFdICYmICEvXlthLXpdKyQvaS50ZXN0KF9WYWx1ZVRvU2V0W20gKyAxXSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgaXMgYmVlbiBzZXQgLiByZXBsYWNpbmcgaW5kZXggdmFsdWUgYSB3aXRoIGl0ZWFydG9yIHZhbHVlIDAsMSwyLCBldGMuICAgCiAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBOZXdWYWx1ZVRvU2V0ICsgaXRlcmF0b3I7CiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gTmV3VmFsdWVUb1NldCArIF9WYWx1ZVRvU2V0W21dOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZXJhdCA9IGZhbHNlOyAvL2dhdmUgaXQgYSBkaWZmZXJlbnQgbmFtZSBzbyBpdCB3b3VsZCBub3QgZnVjayB1cCB3aXRoIGZvciBsb29wIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoTmV3VmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMpOyAvLyAKCiAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0LCBOZXdWYWx1ZVRvU2V0LCB0b2tlbnMpOwogICAgICAgICAgICAgICAgICB9IC8vIHRoaXMgY29uZGl0aW9uIGVuYWJsZXMgcHJvZ3JhbSB0byBvbmx5IHJ1biAgQXJyYXlbYV09IHh5eiB3aGVuIGl0ZXJhdG9yIGlzIGEuIEl0IGRpc2FsbG93cyBydW5uaW5nIEFycmF5W2JsYWJsYWJsYV09eHl6CgoKICAgICAgICAgICAgICAgICAgaWYgKE9yaWdpbmFsSXRlcmF0b3IgPT0gU3BsaXRbMV0pIHsKICAgICAgICAgICAgICAgICAgICBpZiAoU3BsaXRbMV0gPT0gX1ZhbHVlVG9TZXQpIHsKICAgICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgX2l0ZXJhdG9yLCBfVmFsdWVUb1NldCwgdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgICB9IC8vIGZvciBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09YWdlb25lKjEwMAoKCiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmluY2x1ZGVzKFNwbGl0WzFdKSAmJiBPcmlnaW5hbEl0ZXJhdG9yID09IFNwbGl0WzFdKSB7CiAgICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgX1ZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoX1ZhbHVlVG9TZXQsIGosIHVwZGF0ZWRfdG9rZW5zKTsgLy8gCgogICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgX2l0ZXJhdG9yMiwgX1ZhbHVlVG9TZXQsIHRva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgfSAvL1NldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCx1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gLy8gSGFuZGxpbmcgQ09ORElUSU9OQUwgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAoKCiAgICAgICAgICAgICAgICBpZiAoU291cmNlZGF0YVRva2Vuc1tfaTRdLnR5cGUgPT0gJ2NvbmRpdGlvbicpIHsKICAgICAgICAgICAgICAgICAgSGFuZGxlQ29uZGl0aW9ucyhTb3VyY2VkYXRhVG9rZW5zLCBfaTQsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pKCk7CiAgICAgICAgfSAvL0VORCBGT1IgTE9PUCBFWEVDVVRJT04KCiAgICAgIH0KCiAgICAgIHZhciB0MSA9IHBlcmZvcm1hbmNlLm5vdygpOwoKICAgICAgaWYgKHRoaXMub3V0cHV0ICE9ICcnKSB7CiAgICAgICAgdGhpcy5UaW1lVGFrZW4gPSAiQ29tcGlsZWQgU3VjY2VzZnVsbHkgaW4gIiArICh0MSAtIHQwKS50b1ByZWNpc2lvbig0KSArICIgbXMuIjsKICAgICAgfQoKICAgICAgdGhpcy5saW5lYnlsaW5lT3V0cHV0ID0gdGhpcy5vdXRwdXQuc3BsaXQoJ1xuJyk7CiAgICAgIHRoaXMubGluZWJ5bGluZU91dHB1dCA9IHRoaXMubGluZWJ5bGluZU91dHB1dC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICByZXR1cm4gaXRlbSAhPT0gIiI7CiAgICAgIH0pOyAvL1NFQ1RJT04gLSBDYWxjdWxhdGluZyByZW1haW5pbmcgdmFsdWVzCiAgICAgIC8vc28gdGhhdCByZXBsYWNlIHggd2l0aCB2YWx1ZXMKCiAgICAgIC8qCiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLmZvckVhY2goKGVsLCBpKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZWwudmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmluZyB0aGUgIigiIiBhbmQgIikiCiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBDbGVhbmVkRWxlbWVudCA9IFJlbW92ZUJyYWNrZXRzKGVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gJycKICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2h5IHB1cmVldmFsPwogICAgICAgICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9ucyBsaWtlIDUwKzYwIHdlcmUgc2V0IGFzIFs1LDAsKyw2LDBdIGluc3RlYWQgb2YgWzUwLCssNjBdLiBiYXNpY2FsbHkgZGlyZWN0IGNhbGN1bGF0aW9uIHdhcyBub3Qgd29ya2luZwogICAgICAgICAgICAgICAgICAgICAgLy9wdXJlZXZhbCBmaW5kcyBzdWNoIHB1cmUgb3BlcmF0aW9ucyBhbmQgdGhlbiBjYWxjdWxhdGUgdGhlbSB0byBkaXJlY3RseSBzZXQgdGhlaXIgdmFsdWUKICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBzaGl0IGlzIG9ubHkgZm9yIHB1cmVvcGVyYXRpb25zCiAgICAgICAgICAgICAgICAgICAgICBsZXQgcHVyZXZhbCA9IC9eKFstK10/WzAtOV0qXC4/WzAtOV0rW1wvXCtcLVwqXSkrKFstK10/WzAtOV0qXC4/WzAtOV0rKSokL2dtLnRlc3QoQ2xlYW5lZEVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB1cmV2YWwgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zW2ldLnZhbHVlID0gZXZhbCh1cGRhdGVkX3Rva2Vuc1tpXS52YWx1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGN1bGF0aW9uKENsZWFuZWRFbGVtZW50KSA9PSB0cnVlICYmICFwdXJldmFsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1zID0gQ2xlYW5lZEVsZW1lbnQuc3BsaXQoJycpCiAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zCiAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewogICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleHRvQ2hhbmdlID0gJycgLy90byBrbm93IHdoaWNoIHZhbHVlIHRvIHJlcGxhY2UgbGlrZSAiYW5uYStkYWRhLWJhZCIgd2l0aCAiNSs2LTciCiAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsLnZhbHVlIC8vIHJlYWRpbmcgdGhlIGN1cnJlbnQgdmFsdWUsIGZvciBsb24gc3RyaW5nIHZhcmlhYmxlIG5hbWVzIGl0J3Mgc3RpbGwgbGlrZSAiYW5uYStkYWRhLWJhZCIKICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnRvU3RyaW5nKCkKICAgICAgICAgICAgICAgICAgICAgIHZhciBTdHJpbmdWYXIgPSBbXQogICAgICAgICAgICAgICAgICAgICAgLy8gCiAgICAgICAgICAgICAgICAgICAgICAgbGV0IHB1cmV2YWwgPSAvXihbLStdP1thLXpdKlwuP1thLXpdK1tcL1wrXC1cKl0pKyhbLStdP1thLXpdKlwuP1thLXpdKykqJC9nbS50ZXN0KGVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygnPicpIHx8IGVsZW1lbnQuaW5jbHVkZXMoJzwnKSB8fCBlbGVtZW50LmluY2x1ZGVzKCc9PScpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3BsaXRFbGVtZW50c0FycmF5KGVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU2V0VmFsdWVzKFN0cmluZ1ZhciwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVcGRhdGVVcGRhdGVkX3Rva2Vuc3dpdGhWYWx1ZXMoU3RyaW5nVmFyLCBpLCB1cGRhdGVkX3Rva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmluZGluZyBvcGVyYXRpb25zIGxpa2UgYStiLWMKICAgICAgICAgICAgICAgICAgICAgIGlmIChwdXJldmFsID09IHRydWUgfHwgZWxlbWVudC5jaGFyQXQoMCkgPT0gIigiKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3BsaXRFbGVtZW50c0FycmF5KGVsZW1lbnQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU2V0VmFsdWVzKFN0cmluZ1ZhciwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRlVXBkYXRlZF90b2tlbnN3aXRoVmFsdWVzKFN0cmluZ1ZhciwgaSwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgICAgICAgICAvKgogICAgICAgICAgICAgICAgICAgUmVJbnRpYWxpemVkVmFyaWFibGVzLmZvckVhY2goZWw9PnsKICAgICAgICAgICAgICAgICAgIGxldCBmbGFnPTAKICAgICAgICAgICAgICAgICAgbGV0IFNraXBJbmRleD0wCiAgICAgICAgICAgICAgICAgICBmb3IobGV0IG09MDttPHVwZGF0ZWRfdG9rZW5zLmxlbmd0aDttKyspCiAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICBpZihlbC5uYW1lPT11cGRhdGVkX3Rva2Vuc1ttXS5uYW1lICYmIGZsYWc9PTApCiAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBpZihlbC52YWx1ZS5jaGFyQXQoMCk9PSciJykKICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBsZXQgQnVpbHRTdHJpbmc9IEJ1aWxkU3RyaW5nKGVsLnZhbHVlLCApCiAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZmxhZz0xOwogICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vuc1ttXS52YWx1ZT1lbC52YWx1ZTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgIFNraXBJbmRleD1tCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgIGlmKCBtIT1Ta2lwSW5kZXggJiYgZmxhZz09MSAmJiBlbC5uYW1lPT11cGRhdGVkX3Rva2Vuc1ttXS5uYW1lKQogICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMuc3BsaWNlKG0sMSkKICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICAqLwogICAgICAvL1NFQ1RJT04gLSBJdGVyYXRpbmcgb3ZlciB0b2tlbnMgYW5kIHRoZW4gUFJJTlRJTkcgRklOQUwgdXNpbmcgdmFsdWVzIHN0b3JlZCBpbiB1cGRhdGVkIHRva2VucwoKICAgICAgLyogICAgICAgIAogICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHsKICAgICAgICAgICAgdmFyIG11dGFibGVfdG9rZW5zID0gdG9rZW5zCiAgICAgICAgICB2YXIgdG9rZW4gPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZQogICAgICAgCiAgICAgICAgICAgaWYgKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICkKICAgICAgICAgICB7CiAgICAgICAgICAgICAgIHZhciBiID0gUmVtb3ZlQnJhY2tldHMobXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZSkKICAgICAgICAgICAgICAgICAgdmFyaWFibGVzX2FycmF5LnB1c2goYikKICAgICAgICAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICAgIC8vU0VDVElPTiAtIE91dHB1dHRpbmcgdGhlIGNvZGUKICAgICAgICAgICAgICAvLyBmaW5kaW5nIHRoZSByZWx2YW50IHZhbHVlIGFuZCB0aGVuIG91dHB1dCBpdCBhcyBIVE1MCiAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMuZm9yRWFjaCgoZWwsIGkpID0+IHsKICAgICAgICAgICAgICAgICAgIGlmIChlbC5uYW1lID09IGIgKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0ICsgZWwudmFsdWUgKyAiXG4iOwogICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsLm5hbWUpOwogICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAvLyB3b3JrIHRvIGJlIGNvbnRpbnVlZAogICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgCiAgICAgICAgICAgfQogICAgICAgICAgICAvL0hhbmRsaW5nIENvbmRpdGlvbnMKICAgICAgICAgICBpZihtdXRhYmxlX3Rva2Vuc1tqXS50eXBlPT0iY29uZGl0aW9uIikKICAgICAgICAgIHsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICBsZXQgdG9rZW49IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZWw9PiBlbC5vcmlnaW5hbHZhbHVlPT1tdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSkKICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uVmFsdWU9dG9rZW4udmFsdWUKICAgICAgICAgICAgIAogICAgICAgICAgICAgIGlmKENvbmRpdGlvblZhbHVlPT1mYWxzZSkKICAgICAgICAgICAgIHsKICAgICAgbGV0IEluaXRpYWxpemVMb29wPSB0b2tlbnMuaW5kZXhPZihtdXRhYmxlX3Rva2Vuc1tqXSkKICAgICAgd2hpbGUobXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZSE9J30nICkKICAgICAgewogICAgICBsZXQgeD0gbXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZS5sZW5ndGgKICAgICAgdG9rZW5zLnNwbGljZShqKzEsIDEpOwogICAgICBqKys7CiAgICAgIH0KICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYodG9rZW4gPT0gJ+CkquCljeCksOCkv+CkguCknycgJiYgL14oWy0rXT9bMC05XSpcLj9bMC05XStbXC9cK1wtXCpdKSsoWy0rXT9bMC05XSpcLj9bMC05XSspKiQvZ20udGVzdChtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlKSApCiAgICAgICAgICB7CiAgICAgICAgICAgIGxldCBhPSBldmFsKG11dGFibGVfdG9rZW5zW2orMV0udmFsdWUpCiAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dCArICJcbiIgKyBhICsgIlxuIgogICAgICAgICAgIH0KICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgCiAgICAgIC8vIHRoaXMgaXMgdG8gaGFuZGxlIOCkquCljeCksOCkv+CkguCknyAoIkFnZSBpcyIrIEFnZSkgZXRjLgogICAgICAgICAgIGlmKGlzU3RyaW5nYW5kVmFsdWUobXV0YWJsZV90b2tlbnNbal0udmFsdWUpKQogICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHg9bXV0YWJsZV90b2tlbnNbal0udmFsdWUKICAgICAgICAgICAgICBsZXQgc3RyaW5nPScnCiAgICAgICAgICAgICAgbGV0IG5ld2VsPScnCiAgICAgICAgICAgICAgIHg9UmVtb3ZlQnJhY2tldHMoeCkKICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgLy94ID0geC5yZXBsYWNlKC8gL2csJycpCiAgICAgICAgICAgICAgIHg9eC5zcGxpdCgiKyIpCiAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICB4LmZvckVhY2goZWxlbWVudCA9PiB7CiAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgIGlmKGVsZW1lbnQuY2hhckF0KDApPT0gIiAiIHx8IGVsZW1lbnQuY2hhckF0KGVsZW1lbnQubGVuZ3RoLTEpPT0iICIgJiYgIShlbGVtZW50LmluY2x1ZGVzKCciJykpKXsKICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgbmV3ZWw9IGVsZW1lbnQucmVwbGFjZSgvXHMvZywgJycpOwogICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgICAgICAgICAgIG5ld2VsPWVsZW1lbnQKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBsZXQgeT0gdXBkYXRlZF90b2tlbnMuZmluZChlbD0+IGVsLm5hbWU9PSBuZXdlbCkKICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAKICAgICAgLy8KICAgICAgICAgICAgICAgICBpZih5IT11bmRlZmluZWQpCiAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHN0cmluZz1zdHJpbmcgKyAnICcgKyB5LnZhbHVlCiAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ9IGVsZW1lbnQucmVwbGFjZSgvIi9nLCAnJyk7CiAgICAgICAgICAgICAgICAgICAgIHN0cmluZz1zdHJpbmcrICcgJyArIGVsZW1lbnQKICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dCArICJcbiIgKyBzdHJpbmcgKyAiXG4iCiAgICAgIH0KICAgICAgLy9USElTIElTIHRvIGhhbmRsZSBvcGVyYXRpb25zIGxpa2Ug4KSq4KWN4KSw4KS/4KSC4KSfICgiTmFtZSBpcyBHT0FUIiksIOCkquCljeCksOCkv+CkguCknyAoIkdvb2RieWUiKQogICAgICBlbHNlewogICAgICAgICAgICAgICBsZXQgdmFsdWU9IFJlbW92ZUJyYWNrZXRzKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlKQogICAgICAgICAgIC8vIAogICAgICAgICAgICAgCiAgICAgICAgICAgICAgbGV0IENsZWFuZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyAvZywnJykKICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgIGlmKC9eKFstK10/WzAtOV0qXC4/WzAtOV0rW1wvXCtcLVwqXSkrKFstK10/WzAtOV0qXC4/WzAtOV0rKSokL2dtLnRlc3QoQ2xlYW5lZFZhbHVlKSE9dHJ1ZSkKICAgICAgICAgICAgICB7CiAgICAgICAgICAgIC8vIAogICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyIvZywgIiIpOwogICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvJy9nLCAiIik7CiAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQgKyAiXG4iICsgdmFsdWUgKyAiXG4iIAogICAgICB9CiAgICAgICAgICAgICAgICAgIAogICAgICB9CiAgICAgICAgfQogICAgICAgCiAgICAgIH0pCiAgICAgIH0KICAgICAgKi8KICAgIH0KICB9Cn07"},{"version":3,"sources":["HelloWorld.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div class=\"hello\">\n   \n   <div id=\"compiler\">\n   <div id=\"textarea\">\n    <textarea v-model=\"code\" type=\"text\" name=\"code\" id=\"codearea\"></textarea>\n\n    <button id=\"subm\" @click=\"RUN()\">RUN</button>\n   \n   </div>\n\n    <div id=\"output\">\n\n<div id=\"bharatDIV\">\n        <p style=\"color:orange\" id=\"bharatP\">BH</p> <p id=\"bharatP\" style=\"color:white\">AR</p> <p id=\"bharatP\" style=\"color:green\">AT</p>  <p id=\"versionNumber\" >  v1.0</p>\n\n<p style=\"    text-align: left;\n    color: #2fff2f;\n    font-family: monospace;\n\">{{TimeTaken}}</p>\n        \n\n<p id=\"linebylineOutput\" v-for=\"(output,index) in this.linebylineOutput\" :key=\"index\">\n\n{{output}}\n</p>\n\n\n</div>\n\n\n    </div>\n</div>\n    <div id=\"errorstack\">\n\n<div v-for=\"(error,index) in this.error\" :key=\"index\">\n\n{{error}}\n</div>\n\n\n    </div>\n\n    \n      \n  </div>\n</template>\n\n<script>\nimport {\n    SourceDataReplaceforEasyParsing\n} from '../FunctionScripts/functions'\nimport * as TypeCheck from '../FunctionScripts/TypeChecking'\nimport * as AdvancedTypeCheck from '../FunctionScripts/AdvancedTypeChecking'\nimport * as BuildOperation from '../FunctionScripts/BuildOperations'\nimport {\n    PushArray,\n    PushCalculation,\n    PushConditionalKeyword,\n    PushCondition,\n    PushForLoop,\n    PushWhileLoop,\n    PushWhileLoopCondition,\n    PushForLoopAruguments,\n    PushExpression,\n    PushKeyword,\n    PushNumber,\n    PushOperator,\n    PushRealTimePrintOperation,\n    PushString,\n    PushStringandValueOperation,\n    PushVariable,\n    PushEmptyArrayInit\n} from '../FunctionScripts/PushFunctions'\nimport {\n    RemoveBrackets,\n    isArrayOperation,\n    CreateArrayElement,\n    CalculateValues,\n    GetArrayorStringElement,\n    SetArrayorStringElement,\n    PrintArrayElement,\n    handlemultConditions,\n    SplitElementsArray,\n    SetValues,\n    PushSetArrayIndexValue,\n    UpdateUpdated_tokenswithValues,\n    GetConditionValue,\n    ForLoopArrayorStringOutput,\n    AssignorUpdateValues,\n    HandleConditions\n} from '../FunctionScripts/MiscImportantFunctions'\n\n\nexport default {\n    name: \"HelloWorld\",\n    props: {\n        msg: String\n    },\n\n    data() {\n        return {\n            code: 'Name=\"Swanand Kadam\" Name=\"Swanand Kadam is goat\" Array=[ 20,30,\"swanand\"] Age=2020-1996 ageone=20 agetwo=30 x=ageone+agetwo City=\"Pune\" प्रिंट (x)  प्रिंट (Name)  प्रिंट (\"You live, you learn\")  प्रिंट (Age)  अगर (ageone>agetwo) {प्रिंट (\"condition worked\")} प्रिंट (Array[2] + Age + \"is young age\" + Age) अगर (ageone==20) {प्रिंट (\"condition 2 worked\") y=x+ageone प्रिंट (y) }',\n            output: '',\n            error: [],\n            OperationObjects: [],\n            linebylineOutput: '',\n            TimeTaken:''\n\n        };\n    },\n\n    methods: {\n        RUN: function() {\n\n            var t0 = performance.now()\n\n            //to stop accumulating output on succesive RUN\n            this.output = ''\n            this.linebylineOutput = this.output.split(\"\\n\")\n            this.error = []\n            this.OperationObjects = []\n            var sourcedata = this.code;\n            var cleaned_sourcedata = []\n            var i = 0;\n            var tokens = [];\n            var mixedimpurity = []\n            var updated_tokens = []\n            var variables_array = []\n            var assigned_variables = []\n            var terms = []\n            var terms2 = []\n            var operation = ''\n            var CalculationStack = []\n            var foundToken = ''\n            var ReIntializedVariables = []\n\n\n\n\n            //preparing sourcedata for easy parsing by handling new lines, enters etc.\n            //cleaning up the data to get my version of sourcedata. it's better to get version suitable for me because users can type what they wish but I need to maintain \n            //integrity of program in every possible conditio. So. I created my own condition below\n\n            function GetCleanSourcedata(sourcedata, cleaned_sourcedata, impurities) {\n\n                sourcedata = SourceDataReplaceforEasyParsing(sourcedata)\n\n                sourcedata.forEach((element, i) => {\n\n\n                    //finding the elements which has =\" in it so that to seprate them e.g. anna=\"swanand\" also finding the elements which starts with =. e.g \"=78787890\"\n\n\n                    if ((element.indexOf('=\"') > -1 || element.indexOf('=') > 0 || element.charAt(0) == \"=\") && element != '==')\n\n\n                    {\n\n\n\n                        impurities.push(element) //push such element as impurity in impurities\n\n\n\n                        let elements = element.split(\"=\")\n                        let index = cleaned_sourcedata.length\n\n\n                        cleaned_sourcedata[index] = (elements[0])\n                        cleaned_sourcedata[index + 1] = (\"=\")\n                        cleaned_sourcedata[index + 2] = (elements[1])\n\n\n                    }\n\n\n                    //as long as element is pure, push it to new and clean version of sourcedata\n                    if (!impurities.includes(element)) {\n\n\n                        cleaned_sourcedata.push(element)\n\n                    }\n\n                    //\n\n                })\n\n\n                //removing empty \"\" values for final version of sourcedata\n                //SECTION FInal sourcedata cleaning\n                cleaned_sourcedata = cleaned_sourcedata.filter(function(item) {\n                    return item !== \"\"\n                })\n\n\n\n                return cleaned_sourcedata;\n\n            }\n\n\n            let Result = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity)\n\n            cleaned_sourcedata = Result\n            console.log('cleaned_sourcedata: ', cleaned_sourcedata);\n            \n\n\n\n            //SECTION - Start of Bharat Parser\n\n\n            //Checking for type of characters\n\n            const isVariable = TypeCheck.isVariable()\n            const isNumber = TypeCheck.isNumber()\n\n            const isOperator = TypeCheck.isOperator()\n\n            const isKeyword = TypeCheck.isKeyword()\n            const isConditionalKeyword = TypeCheck.isConditionalKeyword()\n            const isForLoop = TypeCheck.isForLoop()\n            const isWhileLoop = TypeCheck.isWhileLoop()\n\n            //needs work\n            const isExpression = TypeCheck.isExpression()\n\n            const isArray = TypeCheck.isArray()\n\n\n            const isSetArrayIndexValue = TypeCheck.isSetArrayIndexValue()\n\n            const isEmptyArrayInit = TypeCheck.isEmptyArrayInit()\n\n            const isString = TypeCheck.isString()\n\n            const isPureEval = AdvancedTypeCheck.isPureEval()\n\n            //if parser encounters anything like (\" or (, then that's a realtime print. \n            //buildstring will be applied now to create a string and push it into tokens\n\n            const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString()\n\n\n\n            const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n            const isCalculation = AdvancedTypeCheck.isCalculation()\n\n            const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n\n\n\n            // to solve [a,n,n,a] into [anna]\n\n            //SECTION Build Operations \n\n            const BuildString = BuildOperation.BuildString()\n\n            const BuildArray = BuildOperation.BuildArray()\n\n            const BuildCondition = BuildOperation.BuildCondition()\n\n\n             //counting how many times do we have &&, || condition present\n            function Count(item, element) {\n\n                            let count = 0\n\n\n                            for (let i = 0; i < element.length; i++) {\n\n                                if (element.charAt(i) == item && element.charAt(i + 1) == item) {\n\n                                    count += 1\n\n\n\n                                }\n\n\n\n                            }\n\n                            return count;\n\n\n            }\n\n\n           \n           //This will run for every print statement encountered in the program, not just for loops\n\n            function IfTokenPrint(Tokens, j, global, iterator, OriginalIterator)\n\n\n            {\n\n\n\n\n                var token = Tokens[j].value\n                \n\n                var NextTokenValue = Tokens[j + 1].value\n\n\n                var StringVar = []\n\n                var b = RemoveBrackets(NextTokenValue)\n\n\n                if (isVariable(b)) {\n\n                    variables_array.push(b)\n                        // \n\n                }\n\n                //SECTION - Outputting the code\n                // finding the relvant value and then output it as HTML\n\n                //This loop is only for printing direct values like print(name), print(array)\n\n                updated_tokens.forEach((el, i) => {\n\n\n\n\n\n\n                    //THIS IS THE REAL GAME\n\n\n\n                    if (el.name == b) {\n\n                        //for calculations like x=ageone+agetwo\n\n                        //If we have already caluculated value, use that or else move forward\n\n\n\n\n\n\n                        if (assigned_variables.includes(el)) {\n\n\n                            global.output = global.output + el.value + \"\\n\";\n\n\n                        } else {\n\n\n                            if (isNumber(el.value)) {\n\n\n\n                                global.output = global.output + el.value + \"\\n\";\n\n                                assigned_variables.push(el);\n\n\n                            }\n\n                            //operations like age=2020-1996\n\n                            if (isPureEval(el.value)) {\n\n\n\n\n\n                                let outputpure = eval(el.value)\n\n\n\n                                el.value = outputpure\n\n\n                                global.output = global.output + outputpure + \"\\n\";\n\n                                assigned_variables.push(el);\n\n                            }\n\n\n\n                            //operations like name=\"swanand kadam\", variable assignments as strings\n\n                            if (!isPureEval(el.value) && !isNumber(el.value))\n\n\n                            {\n\n\n\n\n                                if (!(el.name.includes(']') && el.name.includes('['))) {\n                                    global.output = global.output + el.value + \"\\n\";\n\n                                    assigned_variables.push(el);\n                                }\n\n\n\n\n                            }\n\n\n\n\n                        }\n\n                    }\n\n\n\n\n\n                    // work to be continued\n                })\n\n\n                //ANCHOR - CONDITION 2\n                if (Tokens[j + 1].type == 'Array')\n\n\n\n\n                {\n\n                    //To run only if iterator is present\n\n                    //This runs on for loop - Print(Array[a]) etc\n\n                    //this runs only if for(i) and in the loop, array[i], not on array[x]. Iterator and index should be same\n\n                    if (iterator != undefined && Tokens[j + 1].IndexInput == OriginalIterator)\n\n                    {\n\n\n\n                        let Value = NextTokenValue\n\n                        let ArrayElement = CreateArrayElement(Value, iterator)\n\n\n                        let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                        global.output = global.output + output + \"\\n\";\n\n\n                        assigned_variables.push(Tokens[j + 1]);\n\n\n                    }\n\n\n                    //This runs to Print(Array[2]) like specific array values\n                    if (Tokens[j].IndexInput != OriginalIterator)\n\n                    {\n\n\n                        //\n\n                        let Value = NextTokenValue\n                        let IndexToChange = Tokens[j + 1].IndexInput\n\n\n                        let ArrayElement = CreateArrayElement(Value, IndexToChange)\n                        let output = PrintArrayElement(ArrayElement, updated_tokens)\n\n\n\n                        if (output != undefined) {\n                            global.output = global.output + output + \"\\n\";\n\n\n                        }\n\n\n\n\n\n                    }\n\n                    //This collects print(Array[a]) from for loop and normal Print(Array[2])\n\n                }\n\n\n\n\n                //printing direct numbers and direct calcultions like print(10), print(10*10)\n\n                if (token == 'प्रिंट' && (isPureEval(NextTokenValue) || isNumber(RemoveBrackets(NextTokenValue)))) {\n\n\n                    let a = eval(NextTokenValue)\n\n                    global.output = global.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n\n\n\n                //foroperations like print('you live, you learn')\n                if (Tokens[j + 1].mode == \"RealTimePrint\" && !NextTokenValue.includes('+') && !NextTokenValue.includes('='))\n\n                {\n\n                    let output = RemoveBrackets(NextTokenValue)\n\n                    output = output.replace(/\"/g, '');\n                    output = output.replace(/'/g, '');\n\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n\n\n\n                }\n\n                //operations like print(Age + 'is young age')\n\n                if (Tokens[j + 1].mode == \"RealTimePrint\" && NextTokenValue.includes('+')) {\n\n\n\n                    let x = SplitElementsArray(NextTokenValue)\n\n\n                    StringVar = SetValues(x, updated_tokens)\n\n\n\n                    StringVar = StringVar.join('')\n                    StringVar = StringVar.split(\"+\")\n\n                    let output = StringVar.join(' ')\n                    output = RemoveBrackets(output)\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n\n\n\n\n                }\n\n\n                //THIS CODE is to run print index value in loop, e.g print(i) if iterator is i. \n                //Runs only in for loop\n\n                if (OriginalIterator == RemoveBrackets(NextTokenValue)) {\n\n                    global.output = global.output + \"\\n\" + iterator + \"\\n\"\n\n\n                }\n\n\n                if (isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != \"RealTimePrint\")\n\n                {\n\n\n                    let output = CalculateValues(NextTokenValue, j, updated_tokens)\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n\n\n\n                }\n                // \n\n\n\n\n\n            }\n\n\n            //END OF Functions and Imported Functions\n\n\n\n            //SECTION - Parsing STARTS here\n\n            //SECTION - Checking each token and adding to tokens array\n\n\n\n            let tempthis = this;\n            let variableArray = [] //TO REMOVE DUPLICATE VARIABLES, SEE 482\n\n            function Parse(cleaned_sourcedata, i) {\n\n                var element = cleaned_sourcedata[i];\n\n                var string = []\n\n\n\n\n                if (isVariable(element) == true) {\n\n                    if (cleaned_sourcedata[i + 1] == '=') {\n\n\n                        PushVariable(element, tokens)\n\n                        if (variableArray.includes(element)) {\n\n                            let UpdateElementValue = element\n\n                            let x = tokens.find(el => el.value == element)\n\n                            let index = tokens.indexOf(x)\n\n\n\n                            //\n\n\n                            ReIntializedVariables.push({\n                                name: element\n                            })\n\n                            //\n\n                            //tokens[index+2].value= cleaned_sourcedata[i+2]\n\n\n\n                        }\n\n                        variableArray.push(element)\n\n\n\n\n\n                    }\n\n                }\n\n                if (isNumber(element) == true) {\n\n                    PushNumber(element, tokens)\n\n                }\n\n                if (isOperator(element) == true) {\n                    PushOperator(element, tokens)\n\n                }\n\n                if (isKeyword(element) == true) {\n\n                    PushKeyword(element, tokens)\n\n                }\n\n                //check if it accpets Arry[2a] as index : \n                if (isArray(element) == true) {\n\n                    if (element.charAt(element.length - 1) == ']') {\n\n\n                        PushArray(element, tokens)\n\n                    } else {\n\n\n                        let BuiltArray = BuildArray(element, i, cleaned_sourcedata)\n\n                        PushArray(BuiltArray, tokens)\n\n\n\n                    }\n                }\n\n                if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == true) {\n\n\n\n\n                    PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i)\n\n\n                }\n\n                if (isEmptyArrayInit(element, cleaned_sourcedata, i) == true) {\n\n\n\n                    PushEmptyArrayInit(tokens, cleaned_sourcedata, i)\n\n\n                }\n\n\n\n\n                if (isConditionalKeyword(element) == true) {\n                    \n\n\nif (isWhileLoop(element) == true) {\n\n                    PushWhileLoop(element, tokens,cleaned_sourcedata,i)\n                   // PushWhileLoopCondition(element, cleaned_sourcedata, i, tokens)\n\n\n                }\n\n                else{\n\n                    PushConditionalKeyword(element, tokens)\n                }\n                   \n                   \n                   let foundcondition = BuildCondition(element, i, cleaned_sourcedata)\n                    console.log('foundcondition: ', foundcondition);\n\n\n\n                    PushCondition(foundcondition, tokens)\n\n                \n\n\n                }\n\n\n                if (isForLoop(element) == true) {\n\n                    PushForLoop(element, tokens)\n                    PushForLoopAruguments(element, cleaned_sourcedata, i, tokens)\n\n\n                }\n\n                \n\n\n                if (isCalculation(element) == true) {\n\n\n                    let element = ''\n\n                    if (cleaned_sourcedata[i + 1] != undefined) {\n\n\n\n                        // this is to perform long operations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n\n                        while (isCalculation(cleaned_sourcedata[i]))\n\n\n\n                        {\n\n\n                            element = element + cleaned_sourcedata[i];\n\n\n                            i++;\n\n                        }\n\n\n\n\n\n                    }\n\n\n                    //PushCalculation(element,tokens)\n\n\n\n\n                    //  \n                    terms = element.split('')\n\n                    //removing the \"(\"\" and \")\"\n\n                    var CleanedElement = RemoveBrackets(element)\n\n\n                    // to stop prevention of expressions like is\"+ getting added as a calculation\n                    if (!(CleanedElement.includes('\"')) && element.charAt(0) != '/' && element.charAt(0) != '*') {\n\n\n                        PushCalculation(element, tokens)\n\n\n                    }\n\n\n                    // terms2 = CleanedElement.split(operation)\n\n                    //checkpoint: to perform calculations \n                    //I have identified the operation(seperated) and terms (seperated)\n\n\n\n                    /*      tempthis.OperationObjects.push({\n                                  terms: terms2,\n\n\n                              }\n\n\n\n                          )\n                          */\n\n\n\n\n\n                }\n\n                //finding operations like print(\"swanand\"). The realtimeprint operations\n\n\n\n                if (isRealTimePrintMultipleString(element) == true) {\n\n\n\n                    //\n                    let foundString = ''\n\n                    let k = i\n                    let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n\n                    var flag = 0;\n\n\n\n\n                    for (k; k < cleaned_sourcedata.length; k++) {\n\n                        let element = cleaned_sourcedata[k]\n                        let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n\n\n                        if (cleaned_sourcedata[k].includes('प्रिंट') || cleaned_sourcedata[k].includes('अगर')) {\n\n\n                            //foundString=foundString+  ' '+ cleaned_sourcedata[k]\n\n                            //\n                            break;\n\n\n                        }\n\n                        if (conditionEnd == ')\"')\n\n                        {\n\n                            foundString = foundString + ' ' + cleaned_sourcedata[k];\n                            break;\n\n                        }\n\n                        if (flag == 1) {\n\n                            foundString = foundString + ' ' + cleaned_sourcedata[k]\n\n                        }\n\n                        if (flag == 0) {\n\n                            foundString = cleaned_sourcedata[k];\n\n                            flag = 1;\n\n                        }\n\n\n\n\n                    }\n\n\n\n                    if ((!foundString.includes(\">\")) && (!foundString.includes('/')) && (!foundString.includes('*')) && (!foundString.includes('<')) && (!foundString.includes('==')))\n\n\n                    {\n\n                        // \n                        PushRealTimePrintOperation(foundString, tokens)\n                    }\n\n\n\n\n                }\n\n\n                if (isStringandValue(element) == true) {\n\n\n                    //\n\n                }\n\n\n\n\n                //storing only the string values to tokens ( not the strings in print statements)\n\n                if (isString(element))\n                \n\n                {\n\n\n\n                    let calculatedString = BuildString(element, i, cleaned_sourcedata)\n\n\n\n                    calculatedString = calculatedString.replace(/['\"]+/g, '')\n\n                    if (!(calculatedString.includes(\"प्रिंट\")))\n\n                        PushString(calculatedString, tokens)\n\n                    //\n\n\n\n                }\n\n\n\n\n                //Found Solution using regexp- print(a) without space is getting accepted as expression\n\n\n                if (/^(?=.*?प्रिंट)(?=.*[a-z])/.test(element)) {\n\n                    PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n                    \n                    \n                    PushExpression(element.slice(6), tokens) //Pushing remaining expression like (a), (gagaks) etc\n                }\n\n\n                //error prone change made here\n\n                if (isExpression(element) == true && !isCalculation(element) && !element.includes('[') && !element.includes(']') && (!isConditionalKeyword(cleaned_sourcedata[i - 1]))&& (cleaned_sourcedata[i - 1] != 'मे' ))  {\n\n                                      \n\n                   PushExpression(element, tokens)\n\n\n\n                }\n                if (isExpression(element) == true && element.includes('[') && element.includes(']')) {\n\n                    PushArray(element, tokens)\n\n                }\n\n\n                if (!isKeyword(element) && !isNumber(element) && !isVariable(element) && !isExpression(element) && !isOperator(element)) {\n\n\n                    //ANCHOR \n                    /*Hnadling Impurity error-The main problem is figuring out how to solve \"=7000\" like things\n                    instead asking developers to add space manually\n                    Handling Alphanumeric strings to solve issues like ' anna=2362934'*/\n\n                    let impurity = element.split('=')\n\n                    let findString = impurity[1]\n\n\n                    //to accept long numbers i.e a=749374593745937\n\n                    if (isVariable(impurity[0]) && isNumber(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n                    //to accept a=STRING\n                    if (isVariable(impurity[0]) && isVariable(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n\n\n                    impurity.forEach((element, i) => {\n\n                        if (isVariable(element) == true) {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            //continue;\n                        }\n\n                        // ANCHOR \n\n                        //Issue: Right now, only isNumber is resolved, a=, =23828qw aren't resolved.\n                        //Solution: Work on all the modules\n\n\n                        if (isNumber(element) == true) {\n\n\n                            PushNumber(element, tokens)\n\n                        }\n\n                        //ANCHOR \n                        //You might have to remove this extra filters since you are only working on numbers (Future Issue)\n                        if (isOperator(element) == true) {\n                            PushOperator(element, token)\n\n                        }\n\n\n\n                        if (isKeyword(element) == true) {\n\n                            PushKeyword(element)\n\n                        }\n\n                        if (isExpression(element) == true ) {\n                            \n\n                            PushExpression(element, tokens)\n\n                        }\n\n\n\n\n                    })\n\n\n                }\n\n\n\n            }\n\n            //SECTION - Checking each token and adding to tokens array\n            // PARSING INITIATION\n\n\n            for (i; i < cleaned_sourcedata.length; i++) {\n\n\n                Parse(cleaned_sourcedata, i)\n            }\n\n            //ANCHOR \n            //CLEANING UP THE TOKENS ARRAY\n            //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n            tokens = tokens.filter(el => el.value != '')\n            console.log('tokens: ', tokens);\n            \n\n\n\n\n            //To find undefined variables\n            let difference = variables_array.filter(x => !assigned_variables.includes(x))\n\n            //\n\n            if (difference.length > 0)\n\n            {\n                this.error.push(' Variable ' + difference.toString().split(',') + ' is undefined ')\n\n            }\n\n\n\n\n            //SECTION - Printing Outputs, considering conditions, finding values in updated_tokens\n\n\n\n\n            for (var j = 0; j < tokens.length; j++) {\n\n                // Checking for assignment operators\n\n\n                let mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n                let tokenType = mutable_tokens[j].type\n\n\n\n                var StringVar = []\n\n                let VarWithoutbrackets = RemoveBrackets(mutable_tokens[j].value)\n\n                VarWithoutbrackets = VarWithoutbrackets.replace(/ /g, '')\n\n\n                if (mutable_tokens[j].type == \"SetArrayIndexValue\")\n\n\n\n                {\n\n                    let ValueToSet = mutable_tokens[j].ValueToSet\n\n\n\n\n\n\n                    let x = GetArrayorStringElement(mutable_tokens[j].value, updated_tokens, ValueToSet)\n\n\n\n                }\n\n                if (mutable_tokens[j].value == '=') {\n\n                    //assigning values to variables\n\n                    let variable = mutable_tokens[j - 1].value\n\n\n\n\n\n                    //\n                    let varvalue = mutable_tokens[j + 1].value\n\n\n\n                    //\n\n                    //finding if elements is already assgined in updated tokens\n                    //to solve name='swanand' and name= 'other swanand'\n                    //both shpuld be printed accordinggly\n\n\n                    let n = updated_tokens.find((el, i) => el.name == variable)\n\n\n\n                    // \n\n\n\n                    if (n == undefined) {\n\n\n\n                        //to check if the assigned value needs to be calculated. this is futher diveded in two types\n                        if (isCalculation(varvalue))\n\n\n                        {\n\n\n                            //type 1- Age= 2020-2000 \n                            if (isPureEval(varvalue))\n\n\n\n                            {\n\n\n                                let value = eval(varvalue)\n\n                                //write function for this, so repeatable\n                                updated_tokens.push({\n                                    name: variable,\n\n                                    value: value,\n\n                                    identifier: j,\n                                    type: mutable_tokens[j + 1].type\n                                })\n\n\n                            }\n\n                            //type 2- X= ageone+agetwo\n                            else {\n\n\n                                //performing the calculation\n                                // \n                                let value = CalculateValues(varvalue, j, updated_tokens)\n\n\n\n\n\n                                updated_tokens.push({\n                                    name: variable,\n\n                                    value: value,\n\n                                    identifier: j,\n                                    type: mutable_tokens[j + 1].type\n                                })\n\n\n\n                            }\n\n\n\n                        }\n\n\n                        //if there is no need to calculate, push values as it is\n                        else {\n\n                            updated_tokens.push({\n                                name: variable,\n\n                                value: varvalue,\n\n                                identifier: j,\n                                type: mutable_tokens[j + 1].type\n                            })\n\n\n                        }\n\n\n                    }\n\n\n\n\n                    //if it's already assgined, reassign it with updated value\n                    else {\n\n\n                        if (isCalculation(varvalue)) {\n\n                            let NewValue = CalculateValues(varvalue, j, updated_tokens)\n                            n.value = NewValue\n\n\n                        } else {\n\n                            n.value = varvalue\n                        }\n\n\n\n\n\n                    }\n                    //\n                    //\n\n                    // \n\n\n                }\n\n\n\n                if (tokenType == 'condition')\n\n                {\n\n\n                   \n\n                    let element = mutable_tokens[j].value\n\n //this function is the first step to handlle operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n                \n                let ConditionValue= GetConditionValue(element,updated_tokens,j )\n                \n                \n//console.log('ConditionValue: ', ConditionValue);\n\n                   \n\n\n                    //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                    if (ConditionValue == false) {\n\n                        let InitializeLoop = tokens.indexOf(mutable_tokens[j])\n\n\n\n\n                        while (mutable_tokens[j + 1].value != '}')\n\n\n\n                        {\n\n\n\n\n                            //tokens.splice(j+1, 1);\n\n                            //No need to delete tokens, we are just skipping over the values so that they won't be printed or run\n\n                            j++;\n\n\n                        }\n\n\n\n\n                    }\n\n\n\n\n                }\n\n                if (token == 'प्रिंट')\n\n\n                {\n\n\n\n                    IfTokenPrint(mutable_tokens, j, this) //for operations like print(array[3])\n\n\n                }\n\n                if (tokenType == 'WhileLoopStart')\n                {\n\n                 \n                let TokensCurrentIndex=j+3\n\n                   let ConditionValue = false\n\n                    let element = mutable_tokens[j+1].value\n\n                    let ExtratcedVariable=[]\n                    \n                    let variable=''\n                   let WhileLoopSourcedataIndexStart =0\n                   let WhileLoopSourcedataTokens=[]\n\n                   \n\n                    for(let i=0;i<element.length;i++)\n  {\n                        let x= element.charAt(i)\n                        \n\n                        if(isVariable(x))\n                        \n                        {\n\n                            variable=variable+x\n                            \n                            \n\n                        }\n                        if(!isVariable(element.charAt(i+1)) && isVariable(x))\n                        {\n\n           let token=updated_tokens.find(el=> el.name==variable)\n            \n            ExtratcedVariable.push(\n                {\n                    variable:variable,\n                    value:token.value\n\n                }\n            )\n\n\n            variable=''\n\n\n                        }\n                        \n  }\n\n\n                    //this function is the first step to handlle operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n                   \n    function getLoopIndexStart(mutable_tokens, j, check, setIndex)\n\n                    {\n\n\n                        while (mutable_tokens[j].value != check)\n\n\n\n                        {\n\n\n                            if (mutable_tokens[j + 1].value == check) {\n\n\n\n                                setIndex = j + 1\n\n\n                            }\n\n\n\n                            j++;\n\n                        }\n                        return setIndex\n  }\n\n                    function getWhileLoopSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n\n\n                        let flag = true\n\n                        while (flag) {\n\n\n\n                            if (mutable_tokens[startIndex].value == '{') {\n                                console.log('startIndex: ', startIndex);\n\n\n                                while (mutable_tokens[startIndex].value != '}' ) {\n\n\n                                  StoreResult.push(mutable_tokens[startIndex+1])\n\n\n                                    startIndex++;\n\n\n\n                                    \n\n\n                                }\n\n\n\n                            }\n\n\n\n\n                            if (mutable_tokens[startIndex].value == '}') {\n\n\n\n                                //  \n\n\n                                break;\n\n\n                            }\n\n                            startIndex++;\n\n                        }\n\n                        //this line is important. We are skipping the index of mutable tokens until forloop is completed. This is done to have seprate for loop context and othe\n                        //other fuctions should not intervene in for loop execution\n\n                        j = startIndex + 1\n\n                        return StoreResult\n                        \n\n\n\n\n                    }\n\n\n\n\n\n                    WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart)\n                        //\n                    WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, '}', WhileLoopSourcedataTokens)\n                    \n                    \n                    \n                    \n\n//constantly accessing the conditionvalue\n                \n                while(GetConditionValue(element,updated_tokens,j+1 ))\n                {\n\n                            for(let i=0;i<WhileLoopSourcedataTokens.length;i++){\n\n\n                            //SECTION while loop context\n\n                                    if(WhileLoopSourcedataTokens[i].value=='=') {\n      \n      \n      \n\n                                AssignorUpdateValues(WhileLoopSourcedataTokens,i,updated_tokens)\n\n                                //\n\n                                // \n\n\n                            }\n\n                           \n\n                            // Handling CONDITIONAL statements in for loop\n\n                            if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                            {\n\n\n\n\nHandleConditions(WhileLoopSourcedataTokens,i,updated_tokens)\n\n\n                            }\n\n\n \n \n                                if (WhileLoopSourcedataTokens[i].value == 'प्रिंट')\n\n\n\n                                      {\n  \n\n                                           IfTokenPrint(mutable_tokens, TokensCurrentIndex+i, this) //for operations like print(array[3])\n                    \n                    \n                    \n\n\n                                             }\n            \n                            }\n\n                            \n                }\n                }\n              \n\n        \n\n                \n\n\n\n\n                if (tokenType == 'ForLoopStart')\n\n\n\n                {\n\n\n\n\n                    //Getting evry information about for loop \n\n\n                    let ForLoopMetaData = mutable_tokens[j + 1]\n\n\n                    //Splitting the forloopmetadat values individually\n                    let iterator = ForLoopMetaData.iterator\n\n                    let element = ForLoopMetaData.value\n                    var IterationStart = parseInt(ForLoopMetaData.iterationStart)\n                    var IterationEnd = parseInt(ForLoopMetaData.iterationEnd)\n                   // let ForLoopSourcedata = ForLoopMetaData.ForLoopSourcedata\n                        //\n\n\n                    var elementValue = updated_tokens.find(el => el.name == element)\n                    var elementLength = 0\n                    var FlagPrimalLoop = 0\n                    var ForLoopSourcedataIndexStart = 0\n                    var SourcedataTokens = []\n                    var OriginalIterator = ForLoopMetaData.iterator\n\n                    //\n                    function getLoopIndexStart(mutable_tokens, j, check, setIndex)\n\n                    {\n\n\n                        while (mutable_tokens[j].value != check)\n\n\n\n                        {\n\n\n                            if (mutable_tokens[j + 1].value == check) {\n\n\n\n                                setIndex = j + 1\n\n\n                            }\n\n\n\n                            j++;\n\n                        }\n                        return setIndex\n\n\n                    }\n\n                    function getSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n\n\n                        let flag = true\n\n                        while (flag) {\n\n\n\n                            if (mutable_tokens[startIndex].value == '{') {\n\n\n                                while (mutable_tokens[startIndex].value != '}') {\n\n                                    StoreResult.push(mutable_tokens[startIndex + 1])\n                                    startIndex++;\n\n\n                                }\n\n\n\n                            }\n\n\n\n\n                            if (mutable_tokens[startIndex + 1].value == '}') {\n\n\n\n                                //  \n\n\n                                break;\n\n\n                            }\n\n                            startIndex++;\n\n                        }\n\n                        //this line is important. We are skipping the index of mutable tokens until forloop is completed. This is done to have seprate for loop context and othe\n                        //other fuctions should not intervene in for loop execution\n\n                        j = startIndex + 1\n\n\n                        return StoreResult\n                        \n\n\n\n\n                    }\n\n\n\n\n\n                    ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart)\n                        //\n\n                    SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, '}', SourcedataTokens)\n                    \n\n\n\n\n\n                    if (element.includes('(') && element.includes(','))\n\n                    {\n\n                        FlagPrimalLoop = 1\n\n\n\n                        //shall we ceeate a forloop context here?\n\n\n\n\n                    }\n\n\n\n                    // Run if start and end parameters are not given e.g दुहराओ a को  Name मे \n                    // This is ran just to get Start and End parameters as they are not provided\n                    if (ForLoopMetaData.iterationEnd == undefined) {\n\n\n                        //run if element is array\n                        if (elementValue.type == 'Array')\n\n\n                        {\n                            elementLength = elementValue.value.split(',').length\n\n                            IterationStart = 0\n                            IterationEnd = elementLength\n\n\n                        }\n\n                        //run if element is String\n                        else {\n                            elementLength = elementValue.value.length\n                            IterationStart = 0\n                            IterationEnd = elementLength\n\n\n                        }\n\n\n                    }\n\n\n\n\n                    let Cycle = IterationEnd\n\n\n                    //Iterating over forloop sourcedata\n\n\n                    for (iterator = IterationStart; iterator < Cycle; iterator++) {\n\n\n                        //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                        if (FlagPrimalLoop = 0) {\n                            ForLoopArrayorStringOutput(elementValue, iterator, updated_tokens, this)\n\n                        }\n\n\n                        for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                        {\n\n\n\n\n\n\n                            if (SourcedataTokens[i].value == '=') {\n\n                                //assigning values to variables\n\n                            AssignorUpdateValues(SourcedataTokens,i,updated_tokens)\n\n                            }\n\n\n\n\n                            //Handling print statements in for loop\n\n                            if (SourcedataTokens[i].value == 'प्रिंट')\n\n\n\n\n\n                            {\n\n                                //for operations like print(array[3])\n                                IfTokenPrint(SourcedataTokens, i, this, iterator, OriginalIterator)\n\n                                //\n\n\n                            }\n\n\n\n                            //Handling set array element statements in for loop\n                            if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                            {\n\n                                let Value = SourcedataTokens[i].value\n\n                                let ValueToSet = SourcedataTokens[i].ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                        //\n\n                                    Split = Split + ']'\n\n                                    ArrayElement = Split\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n                                    ArrayElement = CreateArrayElement(Value, iterator)\n\n\n                                }\n\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                        //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, j, updated_tokens, )\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                            // \n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    //SetArrayorStringElement(ArrayElement,updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n\n\n\n                            }\n\n\n\n                            // Handling CONDITIONAL statements in for loop\n\n                            if (SourcedataTokens[i].type == 'condition')\n\n                            {\n\n\nHandleConditions(SourcedataTokens,i,updated_tokens)\n\n\n\n                            }\n\n\n                        }\n\n\n\n                    }\n\n\n\n\n                }\n\n                //END FOR LOOP EXECUTION\n\n\n\n\n\n\n\n            }\n\n\n\n\n\n            \n\n\n\n\nvar t1 = performance.now()\nif(this.output!='')\n{\nthis.TimeTaken= \"Compiled Succesfully in \" + (t1 - t0).toPrecision(4) + \" ms.\"\n\n}\n\n            this.linebylineOutput = this.output.split('\\n')\n\n\n            this.linebylineOutput = this.linebylineOutput.filter(function(item) {\n                return item !== \"\"\n            })\n\n\n\n\n\n            //SECTION - Calculating remaining values\n\n\n            //so that replace x with values\n\n            /*\n                        updated_tokens.forEach((el, i) => {\n\n\n                            let element = el.value\n\n\n                            //removing the \"(\"\" and \")\"\n\n\n                            var CleanedElement = RemoveBrackets(element)\n\n                            operation = ''\n\n\n\n                            //why pureeval?\n                            // operations like 50+60 were set as [5,0,+,6,0] instead of [50,+,60]. basically direct calculation was not working\n                            //pureeval finds such pure operations and then calculate them to directly set their value\n                            //this shit is only for pureoperations\n                            let pureval = /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedElement)\n\n                            if (pureval == true) {\n\n\n\n                                updated_tokens[i].value = eval(updated_tokens[i].value)\n\n\n                            }\n\n\n\n\n                            if (isCalculation(CleanedElement) == true && !pureval) {\n\n                                terms = CleanedElement.split('')\n\n\n\n                            }\n\n\n\n\n                        })\n\n\n\n\n                        //\n\n                        // performing calculations\n\n\n\n\n                        updated_tokens.forEach((el, i) => {\n\n                            var indextoChange = '' //to know which value to replace like \"anna+dada-bad\" with \"5+6-7\"\n\n\n\n                            let element = el.value // reading the current value, for lon string variable names it's still like \"anna+dada-bad\"\n                            element = element.toString()\n                            var StringVar = []\n                            // \n\n                            let pureval = /^([-+]?[a-z]*\\.?[a-z]+[\\/\\+\\-\\*])+([-+]?[a-z]*\\.?[a-z]+)*$/gm.test(element)\n\n\n\n                            if (element.includes('>') || element.includes('<') || element.includes('==')) {\n\n\n\n                                StringVar = SplitElementsArray(element)\n\n\n\n                                StringVar = SetValues(StringVar, updated_tokens)\n\n\n                                UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n\n\n                            }\n\n\n                            //finding operations like a+b-c\n                            if (pureval == true || element.charAt(0) == \"(\") {\n\n                                // \n\n\n                                StringVar = SplitElementsArray(element)\n                                StringVar = SetValues(StringVar, updated_tokens)\n                                UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n                            }\n\n\n\n\n                        })\n\n\n\n\n                        /*\n                         ReIntializedVariables.forEach(el=>{\n\n                        let flag=0\n                        let SkipIndex=0\n\n                        for(let m=0;m<updated_tokens.length;m++)\n                        {\n                            \n                        if(el.name==updated_tokens[m].name && flag==0)\n                        {\n\n\n                        if(el.value.charAt(0)=='\"')\n                        {\n\n\n                            let BuiltString= BuildString(el.value, )\n\n                            \n                        }\n                        flag=1;\n                        updated_tokens[m].value=el.value;\n\n\n                        \n\n                        SkipIndex=m\n\n\n                        }\n\n                        //\n\n                        if( m!=SkipIndex && flag==1 && el.name==updated_tokens[m].name)\n\n                        {\n\n                        updated_tokens.splice(m,1)\n\n                        }\n\n\n                        }\n\n\n\n\n                        })\n                        */\n\n\n\n\n            //SECTION - Iterating over tokens and then PRINTING FINAL using values stored in updated tokens\n\n            /*        \n\n            for (var j = 0; j < tokens.length; j++) {\n\n\n                var mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n             \n\n                if (token == 'प्रिंट' )\n\n                {\n\n                    var b = RemoveBrackets(mutable_tokens[j+1].value)\n\n\n\n\n                    variables_array.push(b)\n\n                    \n\n                 \n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n                    updated_tokens.forEach((el, i) => {\n\n                        if (el.name == b ) {\n\n\n\n                            this.output = this.output + el.value + \"\\n\";\n\n                            assigned_variables.push(el.name);\n\n                           \n\n\n                        }\n\n\n\n                        // work to be continued\n\n                    })\n\n                    \n\n                    \n\n                }\n\n\n                //Handling Conditions\n\n                if(mutable_tokens[j].type==\"condition\")\n                {\n\n\n\n                   \n\n                    let token= updated_tokens.find(el=> el.originalvalue==mutable_tokens[j].value)\n\n\n\n                    let ConditionValue=token.value\n\n                  \n\n                   if(ConditionValue==false)\n                   {\n\nlet InitializeLoop= tokens.indexOf(mutable_tokens[j])\n\n\n\n\n\nwhile(mutable_tokens[j+1].value!='}' )\n{\n\n\n\n    let x= mutable_tokens[j+1].value.length\n    \n    \ntokens.splice(j+1, 1);\n \n\n    j++;\n\n\n}\n\n\n\n\n                   }\n\n\n                }\n\n\n                if(token == 'प्रिंट' && /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(mutable_tokens[j+1].value) )\n                {\n \n                let a= eval(mutable_tokens[j+1].value)\n\n                this.output = this.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n                \n\n        \n              \n\n\n\n\n      // this is to handle प्रिंट (\"Age is\"+ Age) etc.\n\n                if(isStringandValue(mutable_tokens[j].value))\n{\n\n\n        \n\n                    let x=mutable_tokens[j].value\n                    let string=''\n                    let newel=''\n\n                    x=RemoveBrackets(x)\n\n                    \n                    //x = x.replace(/ /g,'')\n\n                    x=x.split(\"+\")\n\n                    \n\n                    x.forEach(element => {\n                        \n\n                        \n                        if(element.charAt(0)== \" \" || element.charAt(element.length-1)==\" \" && !(element.includes('\"'))){\n\n                          \n                       newel= element.replace(/\\s/g, '');\n\n                        \n\n\n                        }\n                        else{\n\n                            newel=element\n                        }\n\n                       let y= updated_tokens.find(el=> el.name== newel)\n\n                      \n                       \n//\n                       if(y!=undefined)\n                       {\n\n\n\n                       string=string + ' ' + y.value\n                       //\n\n\n                       }\n                       else{\n\n                           \n                           element= element.replace(/\"/g, '');\n                           string=string+ ' ' + element\n                       }\n                       \n\n                       \n\n                    });\n\n\n\n                        this.output = this.output + \"\\n\" + string + \"\\n\"\n}\n\n\n//THIS IS to handle operations like प्रिंट (\"Name is GOAT\"), प्रिंट (\"Goodbye\")\n\nelse{\n\n\n\n                  let value= RemoveBrackets(mutable_tokens[j].value)\n                 // \n\n                  \n\n                   let CleanedValue = value.replace(/ /g,'')\n\n                    \n\n\n                   if(/^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedValue)!=true)\n\n                   {\n\n                 // \n\n                    value = value.replace(/\"/g, \"\");\n                    value = value.replace(/'/g, \"\");\n\n\n\n                        this.output = this.output + \"\\n\" + value + \"\\n\" \n }\n                        \n\n}\n\n\n            }\n\n\n           \n            })\n\n        }\n        */\n\n\n        }\n\n    }\n\n};\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n#bharatP{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace\n}\n#versionNumber{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace;\n    padding-left: 6%\n}\n\n#bharatDIV{\n\n    padding-top: 2%;\n    padding-left: 2%\n\n}\n\n#linebylineOutput\n{\n\n\n\nheight: 10px;\n    text-align: left;\n    \n\n\n}\n#errorstack{\n\ntext-align: left;\npadding-left: 2.5%;\npadding-top: 6%;\nfont-weight: bold;\ncolor:rgb(231, 83, 83);\n\n}\n\n#compiler{\n\n  display: flex;\n}\n\n#textarea{\n\n  width: 50%\n}\n#output{\n\n  height: 400px;\n  width: 50%;\n  background-color: black;\n    color: white;\n    overflow: auto\n  \n}\nh3 {\n  margin: 40px 0 0;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n\n.hello {\n  display: grid;\n}\n\n#codearea {\n  width: 90%;\n  height: 400px;\n  background-color: whitesmoke;\n    font-family: monospace;\n    font-size: medium;\n    border: none\n}\n\n#subm {\n  width: 10%;\n  height: 50px;\n}\n</style>"],"sourceRoot":"src/components"}]}