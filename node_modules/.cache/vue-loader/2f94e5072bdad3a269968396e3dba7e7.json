{"remainingRequest":"/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/jonny/Documents/Work/test/src/components/HelloWorld.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/jonny/Documents/Work/test/src/components/HelloWorld.vue","mtime":1590465979863},{"path":"/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCgppbXBvcnQgcHJvbXB0cyBmcm9tICdwcm9tcHRzJwoKICAgIGltcG9ydCB7CiAgICAgICAgU291cmNlRGF0YVJlcGxhY2Vmb3JFYXN5UGFyc2luZwogICAgfSBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvZnVuY3Rpb25zJwppbXBvcnQgKiBhcyBUeXBlQ2hlY2sgZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL1R5cGVDaGVja2luZycKaW1wb3J0ICogYXMgQWR2YW5jZWRUeXBlQ2hlY2sgZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL0FkdmFuY2VkVHlwZUNoZWNraW5nJwppbXBvcnQgKiBhcyBCdWlsZE9wZXJhdGlvbiBmcm9tICcuLi9GdW5jdGlvblNjcmlwdHMvQnVpbGRPcGVyYXRpb25zJwppbXBvcnQgewogICAgUHVzaEFycmF5LAogICAgUHVzaENhbGN1bGF0aW9uLAogICAgUHVzaENvbmRpdGlvbmFsS2V5d29yZCwKICAgIFB1c2hDb25kaXRpb24sCiAgICBQdXNoRm9yTG9vcCwKICAgIFB1c2hXaGlsZUxvb3AsCiAgICBQdXNoV2hpbGVMb29wQ29uZGl0aW9uLAogICAgUHVzaEZvckxvb3BBcnVndW1lbnRzLAogICAgUHVzaEV4cHJlc3Npb24sCiAgICBQdXNoS2V5d29yZCwKICAgIFB1c2hOdW1iZXIsCiAgICBQdXNoT3BlcmF0b3IsCiAgICBQdXNoUmVhbFRpbWVQcmludE9wZXJhdGlvbiwKICAgIFB1c2hTdHJpbmcsCiAgICBQdXNoU3RyaW5nYW5kVmFsdWVPcGVyYXRpb24sCiAgICBQdXNoVmFyaWFibGUsCiAgICBQdXNoVmFyaWFibGVWYWx1ZSwKICAgIFB1c2hGdW5jdGlvbkRhdGEsCiAgICBQdXNoSW5wdXQKCn0gZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL1B1c2hGdW5jdGlvbnMnCmltcG9ydCB7CiAgICBSZW1vdmVCcmFja2V0cywKICAgIFJlc2V0VmFsdWUsCiAgICBpc0FycmF5T3BlcmF0aW9uLAogICAgQ3JlYXRlQXJyYXlFbGVtZW50LAogICAgQ2FsY3VsYXRlVmFsdWVzLAogICAgR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQsCiAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudCwKICAgIFByaW50QXJyYXlFbGVtZW50LAogICAgaGFuZGxlbXVsdENvbmRpdGlvbnMsCiAgICBIYW5kbGVCbG9ja3MsCiAgICBTcGxpdEVsZW1lbnRzQXJyYXksCiAgICBTZXRWYWx1ZXMsCiAgICBQdXNoU2V0QXJyYXlJbmRleFZhbHVlLAogICAgUHVzaEdldEFycmF5SW5kZXhWYWx1ZSwKICAgIFVwZGF0ZVVwZGF0ZWRfdG9rZW5zd2l0aFZhbHVlcywKICAgIEdldENvbmRpdGlvblZhbHVlLAogICAgRm9yTG9vcEFycmF5b3JTdHJpbmdPdXRwdXQsCiAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcywKICAgIEhhbmRsZUNvbmRpdGlvbnMsCiAgICBnZXRMb29wSW5kZXhTdGFydCwKICAgIEZvckxvb3BTZXRNZXRhZGF0YQp9IGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9NaXNjSW1wb3J0YW50RnVuY3Rpb25zJwoKCgpleHBvcnQgZGVmYXVsdCB7CiAgICBuYW1lOiAiSGVsbG9Xb3JsZCIsCiAgICBwcm9wczogewogICAgICAgIG1zZzogU3RyaW5nCiAgICB9LAoKICAgIGRhdGEoKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgY29kZTogJ05hbWU9IlN3YW5hbmQgS2FkYW0iIE5hbWU9IlN3YW5hbmQgS2FkYW0gaXMgZ29hdCIgQXJyYXk9WyAyMCwzMCwic3dhbmFuZCJdIEFnZT0yMDIwLTE5OTYgYWdlb25lPTIwIGFnZXR3bz0zMCB4PWFnZW9uZSthZ2V0d28gQ2l0eT0iUHVuZSIg4KSq4KWN4KSw4KS/4KSC4KSfICh4KSAg4KSq4KWN4KSw4KS/4KSC4KSfIChOYW1lKSAg4KSq4KWN4KSw4KS/4KSC4KSfICgiWW91IGxpdmUsIHlvdSBsZWFybiIpICDgpKrgpY3gpLDgpL/gpILgpJ8gKEFnZSkgIOCkheCkl+CksCAoYWdlb25lPmFnZXR3bykge+CkquCljeCksOCkv+CkguCknyAoImNvbmRpdGlvbiB3b3JrZWQiKX0g4KSq4KWN4KSw4KS/4KSC4KSfIChBcnJheVsyXSArIEFnZSArICJpcyB5b3VuZyBhZ2UiICsgQWdlKSDgpIXgpJfgpLAgKGFnZW9uZT09MjApIHvgpKrgpY3gpLDgpL/gpILgpJ8gKCJjb25kaXRpb24gMiB3b3JrZWQiKSB5PXgrYWdlb25lIOCkquCljeCksOCkv+CkguCknyAoeSkgfScsCiAgICAgICAgICAgIG91dHB1dDogJycsCiAgICAgICAgICAgIGVycm9yOiBbXSwKICAgICAgICAgICAgT3BlcmF0aW9uT2JqZWN0czogW10sCiAgICAgICAgICAgIGxpbmVieWxpbmVPdXRwdXQ6ICcnLAogICAgICAgICAgICBUaW1lVGFrZW46ICcnLAogICAgICAgICAgICBpbnB1dEluZGV4ZXM6W10sCiAgICAgICAgICAgIGlucHV0OicnCgogICAgICAgIH07CiAgICB9LAoKICAgIG1ldGhvZHM6IHsKICAgICAgICBSVU46IGZ1bmN0aW9uKCkgewoKCmNvbnNvbGUubG9nKHByb21wdHMpOwoKCnZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpCgogICAgICAgICAgICAvL3RvIHN0b3AgYWNjdW11bGF0aW5nIG91dHB1dCBvbiBzdWNjZXNpdmUgUlVOCiAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gJycKICAgICAgICAgICAgdGhpcy5pbnB1dD0nJywKICAgICAgICAgICAgdGhpcy5saW5lYnlsaW5lT3V0cHV0ID0gdGhpcy5vdXRwdXQuc3BsaXQoIlxuIikKICAgICAgICAgICAgdGhpcy5pbnB1dEluZGV4ZXM9W10KICAgICAgICAgICAgdGhpcy5lcnJvciA9IFtdCiAgICAgICAgICAgIHRoaXMuT3BlcmF0aW9uT2JqZWN0cyA9IFtdCiAgICAgICAgICAgIHZhciBzb3VyY2VkYXRhID0gdGhpcy5jb2RlOwogICAgICAgICAgICB2YXIgY2xlYW5lZF9zb3VyY2VkYXRhID0gW10KICAgICAgICAgICAgdmFyIGkgPSAwOwogICAgICAgICAgICB2YXIgdG9rZW5zID0gW107CiAgICAgICAgICAgIHZhciBtaXhlZGltcHVyaXR5ID0gW10KICAgICAgICAgICAgdmFyIHVwZGF0ZWRfdG9rZW5zID0gW10KICAgICAgICAgICAgdmFyIGZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zPVtdCiAgICAgICAgICAgIHZhciB2YXJpYWJsZXNfYXJyYXkgPSBbXQogICAgICAgICAgICB2YXIgYXNzaWduZWRfdmFyaWFibGVzID0gW10KICAgICAgICAgICAgdmFyIHRlcm1zID0gW10KICAgICAgICAgICAgdmFyIHRlcm1zMiA9IFtdCiAgICAgICAgICAgIHZhciBvcGVyYXRpb24gPSAnJwogICAgICAgICAgICB2YXIgQ2FsY3VsYXRpb25TdGFjayA9IFtdCiAgICAgICAgICAgIHZhciBmb3VuZFRva2VuID0gJycKICAgICAgICAgICAgdmFyIFJlSW50aWFsaXplZFZhcmlhYmxlcyA9IFtdCgogICAgICAgICAgICAvL2VtcHR5aW5nIGFjY3VtdWxhdGVkdmFsdWUgc3RvcmVkIGZvciBvcGVyYXRpb25zIGxpa2UgTmFtZT0gTmFtZStBcnJheVtpXQogICAgICAgICAgICAvL1NlZSBBc3NpZ25vclVwZGF0ZVZhbHVlcyBmdWN0aW9uIGZvciBtb3JlCiAgICAgICAgICAgIFJlc2V0VmFsdWUoKQoKCmZ1bmN0aW9uIHNsZWVwKG1pbGxpc2Vjb25kcykgewogIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpOwogIGxldCBjdXJyZW50RGF0ZSA9IG51bGw7CiAgZG8gewogICAgY3VycmVudERhdGUgPSBEYXRlLm5vdygpOwogIH0gd2hpbGUgKGN1cnJlbnREYXRlIC0gZGF0ZSA8IG1pbGxpc2Vjb25kcyk7Cn0KCgogICAgICAgICAgICAvL3ByZXBhcmluZyBzb3VyY2VkYXRhIGZvciBlYXN5IHBhcnNpbmcgYnkgaGFuZGxpbmcgbmV3IGxpbmVzLCBlbnRlcnMgZXRjLgogICAgICAgICAgICAvL2NsZWFuaW5nIHVwIHRoZSBkYXRhIHRvIGdldCBteSB2ZXJzaW9uIG9mIHNvdXJjZWRhdGEuIGl0J3MgYmV0dGVyIHRvIGdldCB2ZXJzaW9uIHN1aXRhYmxlIGZvciBtZSBiZWNhdXNlIHVzZXJzIGNhbiB0eXBlIHdoYXQgdGhleSB3aXNoIGJ1dCBJIG5lZWQgdG8gbWFpbnRhaW4gCiAgICAgICAgICAgIC8vaW50ZWdyaXR5IG9mIHByb2dyYW0gaW4gZXZlcnkgcG9zc2libGUgY29uZGl0aW8uIFNvLiBJIGNyZWF0ZWQgbXkgb3duIGNvbmRpdGlvbiBiZWxvdwoKICAgICAgICAgICAgZnVuY3Rpb24gR2V0Q2xlYW5Tb3VyY2VkYXRhKHNvdXJjZWRhdGEsIGNsZWFuZWRfc291cmNlZGF0YSwgaW1wdXJpdGllcykgewoKICAgICAgICAgICAgICAgIHNvdXJjZWRhdGEgPSBTb3VyY2VEYXRhUmVwbGFjZWZvckVhc3lQYXJzaW5nKHNvdXJjZWRhdGEpCgogICAgICAgICAgICAgICAgc291cmNlZGF0YS5mb3JFYWNoKChlbGVtZW50LCBpKSA9PiB7CgoKICAgICAgICAgICAgICAgICAgICAvL2ZpbmRpbmcgdGhlIGVsZW1lbnRzIHdoaWNoIGhhcyA9IiBpbiBpdCBzbyB0aGF0IHRvIHNlcHJhdGUgdGhlbSBlLmcuIGFubmE9InN3YW5hbmQiIGFsc28gZmluZGluZyB0aGUgZWxlbWVudHMgd2hpY2ggc3RhcnRzIHdpdGggPS4gZS5nICI9Nzg3ODc4OTAiCgoKCiAgICAgICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50LmluY2x1ZGVzKCc9PScpJiYoZWxlbWVudC5pbmRleE9mKCc9IicpID4gLTEgfHwgZWxlbWVudC5pbmRleE9mKCc9JykgPiAwIHx8IGVsZW1lbnQuY2hhckF0KDApID09ICI9IikgJiYgZWxlbWVudCAhPSAnPT0nKQoKCiAgICAgICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgICAgICBpbXB1cml0aWVzLnB1c2goZWxlbWVudCkgLy9wdXNoIHN1Y2ggZWxlbWVudCBhcyBpbXB1cml0eSBpbiBpbXB1cml0aWVzCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IGVsZW1lbnQuc3BsaXQoIj0iKQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoCgoKICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5lZF9zb3VyY2VkYXRhW2luZGV4XSA9IChlbGVtZW50c1swXSkKICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5lZF9zb3VyY2VkYXRhW2luZGV4ICsgMV0gPSAoIj0iKQogICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGFbaW5kZXggKyAyXSA9IChlbGVtZW50c1sxXSkKCgoKICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAvL2FzIGxvbmcgYXMgZWxlbWVudCBpcyBwdXJlLCBwdXNoIGl0IHRvIG5ldyBhbmQgY2xlYW4gdmVyc2lvbiBvZiBzb3VyY2VkYXRhCiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXB1cml0aWVzLmluY2x1ZGVzKGVsZW1lbnQpKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YS5wdXNoKGVsZW1lbnQpCgogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAvL3JlbW92aW5nIGVtcHR5ICIiIHZhbHVlcyBmb3IgZmluYWwgdmVyc2lvbiBvZiBzb3VyY2VkYXRhCiAgICAgICAgICAgICAgICAvL1NFQ1RJT04gRkluYWwgc291cmNlZGF0YSBjbGVhbmluZwoKICAgICAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YSA9IGNsZWFuZWRfc291cmNlZGF0YS5maWx0ZXIoZnVuY3Rpb24oaXRlbSkgewogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtICE9PSAiIgogICAgICAgICAgICAgICAgfSkKCgoKICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbmVkX3NvdXJjZWRhdGE7CgogICAgICAgICAgICB9CgoKICAgICAgICAgICAgbGV0IFJlc3VsdCA9IEdldENsZWFuU291cmNlZGF0YShzb3VyY2VkYXRhLCBjbGVhbmVkX3NvdXJjZWRhdGEsIG1peGVkaW1wdXJpdHkpCgogICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGEgPSBSZXN1bHQKICAgICAgICAgICAgY29uc29sZS5sb2coJ2NsZWFuZWRfc291cmNlZGF0YTogJywgY2xlYW5lZF9zb3VyY2VkYXRhKTsKCgoKCiAgICAgICAgICAgIC8vU0VDVElPTiAtIFN0YXJ0IG9mIEJoYXJhdCBQYXJzZXIKCgogICAgICAgICAgICAvL0NoZWNraW5nIGZvciB0eXBlIG9mIGNoYXJhY3RlcnMKCiAgICAgICAgICAgIGNvbnN0IGlzVmFyaWFibGUgPSBUeXBlQ2hlY2suaXNWYXJpYWJsZSgpCiAgICAgICAgICAgIGNvbnN0IGlzTnVtYmVyID0gVHlwZUNoZWNrLmlzTnVtYmVyKCkKCiAgICAgICAgICAgIGNvbnN0IGlzT3BlcmF0b3IgPSBUeXBlQ2hlY2suaXNPcGVyYXRvcigpCgogICAgICAgICAgICBjb25zdCBpc0tleXdvcmQgPSBUeXBlQ2hlY2suaXNLZXl3b3JkKCkKICAgICAgICAgICAgY29uc3QgaXNDb25kaXRpb25hbEtleXdvcmQgPSBUeXBlQ2hlY2suaXNDb25kaXRpb25hbEtleXdvcmQoKQogICAgICAgICAgICBjb25zdCBpc0Zvckxvb3AgPSBUeXBlQ2hlY2suaXNGb3JMb29wKCkKICAgICAgICAgICAgY29uc3QgaXNXaGlsZUxvb3AgPSBUeXBlQ2hlY2suaXNXaGlsZUxvb3AoKQogICAgICAgICAgICBjb25zdCBpc0Z1bmN0aW9uID0gVHlwZUNoZWNrLmlzRnVuY3Rpb24oKQogICAgICAgICAgICAvL25lZWRzIHdvcmsKICAgICAgICAgICAgY29uc3QgaXNFeHByZXNzaW9uID0gVHlwZUNoZWNrLmlzRXhwcmVzc2lvbigpCgogICAgICAgICAgICBjb25zdCBpc0FycmF5ID0gVHlwZUNoZWNrLmlzQXJyYXkoKQogICAgICAgICAgICBjb25zdCBpc0lucHV0ID0gVHlwZUNoZWNrLmlzSW5wdXQoKSAKCiAgICAgICAgICAgIGNvbnN0IGlzU2V0QXJyYXlJbmRleFZhbHVlID0gVHlwZUNoZWNrLmlzU2V0QXJyYXlJbmRleFZhbHVlKCkKCiAgICAgICAgICAgIC8vIGNvbnN0IGlzRW1wdHlBcnJheUluaXQgPSBUeXBlQ2hlY2suaXNFbXB0eUFycmF5SW5pdCgpCgogICAgICAgICAgICBjb25zdCBpc1N0cmluZyA9IFR5cGVDaGVjay5pc1N0cmluZygpCgogICAgICAgICAgICBjb25zdCBpc1B1cmVFdmFsID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNQdXJlRXZhbCgpCgogICAgICAgICAgICAvL2lmIHBhcnNlciBlbmNvdW50ZXJzIGFueXRoaW5nIGxpa2UgKCIgb3IgKCwgdGhlbiB0aGF0J3MgYSByZWFsdGltZSBwcmludC4gCiAgICAgICAgICAgIC8vYnVpbGRzdHJpbmcgd2lsbCBiZSBhcHBsaWVkIG5vdyB0byBjcmVhdGUgYSBzdHJpbmcgYW5kIHB1c2ggaXQgaW50byB0b2tlbnMKCiAgICAgICAgICAgIGNvbnN0IGlzUmVhbFRpbWVQcmludE11bHRpcGxlU3RyaW5nID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoKQoKCgogICAgICAgICAgICBjb25zdCBpc1N0cmluZ2FuZFZhbHVlID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNTdHJpbmdhbmRWYWx1ZSgpCgogICAgICAgICAgICBjb25zdCBpc0NhbGN1bGF0aW9uID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNDYWxjdWxhdGlvbigpCgogICAgICAgICAgICBjb25zdCBpc0RpcmVjdFByaW50QXJpdGhtZXRpYyA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzRGlyZWN0UHJpbnRBcml0aG1ldGljKCkKCgoKCiAgICAgICAgICAgIC8vIHRvIHNvbHZlIFthLG4sbixhXSBpbnRvIFthbm5hXQoKICAgICAgICAgICAgLy9TRUNUSU9OIEJ1aWxkIE9wZXJhdGlvbnMgCgogICAgICAgICAgICBjb25zdCBCdWlsZFN0cmluZyA9IEJ1aWxkT3BlcmF0aW9uLkJ1aWxkU3RyaW5nKCkKCiAgICAgICAgICAgIGNvbnN0IEJ1aWxkQXJyYXkgPSBCdWlsZE9wZXJhdGlvbi5CdWlsZEFycmF5KCkKCiAgICAgICAgICAgIGNvbnN0IEJ1aWxkQ29uZGl0aW9uID0gQnVpbGRPcGVyYXRpb24uQnVpbGRDb25kaXRpb24oKQoKCiAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBoYW5kbGxlIG9wZXJhdGlvbnMgbGlrZSDgpIXgpJfgpLAgKGFnZW9uZT09MTAgJiYgQXZlcmFnZUFnZTwxMDAwICYmIGFnZXR3bz4xMDAgfHwgYWdlb25lPT0xMCkgT1IgKGFnZW9uZT09MTAgKQoKICAgICAgICAgICAgCgoKICAgICAgICAgICAgLy9jb3VudGluZyBob3cgbWFueSB0aW1lcyBkbyB3ZSBoYXZlICYmLCB8fCBjb25kaXRpb24gcHJlc2VudAogICAgICAgICAgICBmdW5jdGlvbiBDb3VudChpdGVtLCBlbGVtZW50KSB7CgogICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMAoKCiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyBpKyspIHsKCiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hhckF0KGkpID09IGl0ZW0gJiYgZWxlbWVudC5jaGFyQXQoaSArIDEpID09IGl0ZW0pIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDEKCgoKICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50OwoKCiAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgLy9UaGlzIHdpbGwgcnVuIGZvciBldmVyeSBwcmludCBzdGF0ZW1lbnQgZW5jb3VudGVyZWQgaW4gdGhlIHByb2dyYW0sIG5vdCBqdXN0IGZvciBsb29wcwoKICAgICAgICAgICAgZnVuY3Rpb24gSWZUb2tlblByaW50KFRva2Vucyx1cGRhdGVkX3Rva2VucywgaiwgZ2xvYmFsLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcikKICAgICAgICAgICAgCiAgICAgICAgICAgIAogICAgICAgICAgICAKCgogICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IFRva2Vuc1tqXS52YWx1ZQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICB2YXIgTmV4dFRva2VuVmFsdWUgPSBUb2tlbnNbaiArIDFdLnZhbHVlCiAgICAgICAgICAgICAgICBOZXh0VG9rZW5WYWx1ZT1OZXh0VG9rZW5WYWx1ZS5yZXBsYWNlKCIrIiwgJyArICcpCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICB2YXIgU3RyaW5nVmFyID0gW10KCiAgICAgICAgICAgICAgICB2YXIgYiA9IFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAKCgoKICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGIpKSB7CgogICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc19hcnJheS5wdXNoKGIpCiAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAvL1NFQ1RJT04gLSBPdXRwdXR0aW5nIHRoZSBjb2RlCiAgICAgICAgICAgICAgICAvLyBmaW5kaW5nIHRoZSByZWx2YW50IHZhbHVlIGFuZCB0aGVuIG91dHB1dCBpdCBhcyBIVE1MCgogICAgICAgICAgICAgICAgLy9UaGlzIGxvb3AgaXMgb25seSBmb3IgcHJpbnRpbmcgZGlyZWN0IHZhbHVlcyBsaWtlIHByaW50KG5hbWUpLCBwcmludChhcnJheSkKCiAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewogICAgICAgICAgICAgICAgICAgIAoKCgoKICAgICAgICAgICAgICAgICAgICAvL1RISVMgSVMgVEhFIFJFQUwgR0FNRQoKCgogICAgICAgICAgICAgICAgICAgIGlmIChlbC5uYW1lID09IGIpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIGNhbGN1bGF0aW9ucyBsaWtlIHg9YWdlb25lK2FnZXR3bwoKICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB3ZSBoYXZlIGFscmVhZHkgY2FsdWN1bGF0ZWQgdmFsdWUsIHVzZSB0aGF0IG9yIGVsc2UgbW92ZSBmb3J3YXJkCgoKCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzaWduZWRfdmFyaWFibGVzLmluY2x1ZGVzKGVsKSkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArIGVsLnZhbHVlICsgIlxuIjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihlbC52YWx1ZSkpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArIGVsLnZhbHVlICsgIlxuIjsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vcGVyYXRpb25zIGxpa2UgYWdlPTIwMjAtMTk5NgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUHVyZUV2YWwoZWwudmFsdWUpKSB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXRwdXJlID0gZXZhbChlbC52YWx1ZSkKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC52YWx1ZSA9IG91dHB1dHB1cmUKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgb3V0cHV0cHVyZSArICJcbiI7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29wZXJhdGlvbnMgbGlrZSBuYW1lPSJzd2FuYW5kIGthZGFtIiwgdmFyaWFibGUgYXNzaWdubWVudHMgYXMgc3RyaW5ncwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzUHVyZUV2YWwoZWwudmFsdWUpICYmICFpc051bWJlcihlbC52YWx1ZSkpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZWwubmFtZS5pbmNsdWRlcygnXScpICYmIGVsLm5hbWUuaW5jbHVkZXMoJ1snKSkpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgZWwudmFsdWUgKyAiXG4iOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKGVsKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgdG8gYmUgY29udGludWVkCiAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAvL0FOQ0hPUiAtIENPTkRJVElPTiAyCiAgICAgICAgICAgICAgICBpZiAoVG9rZW5zW2ogKyAxXS50eXBlID09ICdBcnJheScpCgoKCgogICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdUb2tlbnNbaiArIDFdOiAnLCBUb2tlbnNbaiArIDFdKTsKICAgICAgICAgICAgICAgICAgICAvL1RvIHJ1biBvbmx5IGlmIGl0ZXJhdG9yIGlzIHByZXNlbnQKCiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIHJ1bnMgb24gZm9yIGxvb3AgLSBQcmludChBcnJheVthXSkgZXRjCgogICAgICAgICAgICAgICAgICAgIC8vdGhpcyBydW5zIG9ubHkgaWYgZm9yKGkpIGFuZCBpbiB0aGUgbG9vcCwgYXJyYXlbaV0sIG5vdCBvbiBhcnJheVt4XS4gSXRlcmF0b3IgYW5kIGluZGV4IHNob3VsZCBiZSBzYW1lCgogICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvciAhPSB1bmRlZmluZWQgJiYgVG9rZW5zW2ogKyAxXS5JbmRleElucHV0ID09IE9yaWdpbmFsSXRlcmF0b3IpCgogICAgICAgICAgICAgICAgICAgIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlID0gTmV4dFRva2VuVmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZhbHVlOiAnLCBWYWx1ZSk7CgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KFZhbHVlLCBpdGVyYXRvcikKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgb3V0cHV0ICsgIlxuIjsKICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnb3V0cHV0OiAnLCBvdXRwdXQpOwoKCiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lnbmVkX3ZhcmlhYmxlcy5wdXNoKFRva2Vuc1tqICsgMV0pOwoKCiAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIHJ1bnMgdG8gUHJpbnQoQXJyYXlbMl0pIGxpa2Ugc3BlY2lmaWMgYXJyYXkgdmFsdWVzCiAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFRva2Vuc1tqXS5JbmRleElucHV0ICE9IE9yaWdpbmFsSXRlcmF0b3IpCgoKICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdUb2tlbnNbal06ICcsIFRva2Vuc1tqICsgMV0pOwogICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlID0gTmV4dFRva2VuVmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbmRleFRvQ2hhbmdlID0gVG9rZW5zW2ogKyAxXS5JbmRleElucHV0CgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEFycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChWYWx1ZSwgSW5kZXhUb0NoYW5nZSkKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IEFycmF5RWxlbWVudC5yZXBsYWNlKCddJywgJycpCgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFNwbGl0ID0gZWxlbWVudC5zcGxpdCgnWycpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoU3BsaXRbMV0uaW5jbHVkZXMoJy0nKSB8fCBTcGxpdFsxXS5pbmNsdWRlcygnKycpKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBDYWxjdWxhdGVWYWx1ZXMoU3BsaXRbMV0sIGosIHVwZGF0ZWRfdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0WzFdID0gb3V0cHV0CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykgKyAnXScKICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5RWxlbWVudCA9IFNwbGl0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdBcnJheUVsZW1lbnQ6ICcsIEFycmF5RWxlbWVudCk7CgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZWwgPT4gZWwubmFtZSA9PSBTcGxpdFsxXSkKCiAgICAgICAgICAgICAgICAgICAgICBpZih0b2tlbiAhPSB1bmRlZmluZWQgJiYgT3JpZ2luYWxJdGVyYXRvciAhPSBTcGxpdFsxXSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0WzFdID0gdG9rZW4udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTcGxpdCA9IFNwbGl0LmpvaW4oJ1snKSArICddJwogICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gU3BsaXQKCgogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5RWxlbWVudCA9IEFycmF5RWxlbWVudAogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnQXJyYXlFbGVtZW50OiAnLCBBcnJheUVsZW1lbnQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyBvdXRwdXQgKyAiXG4iOwogICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdvdXRwdXQ6ICcsIG91dHB1dCk7CgoKCgogICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgIC8vcHJpbnRpbmcgZGlyZWN0IG51bWJlcnMgYW5kIGRpcmVjdCBjYWxjdWx0aW9ucyBsaWtlIHByaW50KDEwKSwgcHJpbnQoMTAqMTApCgogICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJyAmJiAoaXNQdXJlRXZhbChOZXh0VG9rZW5WYWx1ZSkgfHwgaXNOdW1iZXIoUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpKSkpIHsKCgogICAgICAgICAgICAgICAgICAgIGxldCBhID0gZXZhbChOZXh0VG9rZW5WYWx1ZSkKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTmV4dFRva2VuVmFsdWU6ICcsIE5leHRUb2tlblZhbHVlKTsKCiAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyAiXG4iICsgYSArICJcbiIKCiAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgLy9mb3JvcGVyYXRpb25zIGxpa2UgcHJpbnQoJ3lvdSBsaXZlLCB5b3UgbGVhcm4nKQogICAgICAgICAgICAgICBlbHNlIGlmIChUb2tlbnNbaiArIDFdLm1vZGUgPT0gIlJlYWxUaW1lUHJpbnQiICYmICFOZXh0VG9rZW5WYWx1ZS5pbmNsdWRlcygnKycpICYmICFOZXh0VG9rZW5WYWx1ZS5pbmNsdWRlcygnPScpKQoKICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSkKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTmV4dFRva2VuVmFsdWU6ICcsIE5leHRUb2tlblZhbHVlKTsKCiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoLyIvZywgJycpOwogICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8nL2csICcnKTsKCgogICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgIlxuIiArIG91dHB1dCArICJcbiIKICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdnbG9iYWwub3V0cHV0OiAnLCBnbG9iYWwub3V0cHV0KTsKCgoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL29wZXJhdGlvbnMgbGlrZSBwcmludChBZ2UgKyAnaXMgeW91bmcgYWdlJykKCiAgICAgICAgICAgICAgIGVsc2UgaWYgKFRva2Vuc1tqICsgMV0ubW9kZSA9PSAiUmVhbFRpbWVQcmludCIgJiYgTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJysnKSkgewoKCgogICAgICAgICAgICAgICAgICAgIGxldCB4ID0gU3BsaXRFbGVtZW50c0FycmF5KE5leHRUb2tlblZhbHVlKQogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd4OiAnLCB4KTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyh4LCB1cGRhdGVkX3Rva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3RyaW5nVmFyLmpvaW4oJycpCiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3RyaW5nVmFyLnNwbGl0KCIrIikKCiAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IFN0cmluZ1Zhci5qb2luKCcgJykKICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBSZW1vdmVCcmFja2V0cyhvdXRwdXQpCgogICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgIlxuIiArIG91dHB1dCArICJcbiIKCgoKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNDYWxjdWxhdGlvbihSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSkpICYmIFRva2Vuc1tqICsgMV0ubW9kZSAhPSAiUmVhbFRpbWVQcmludCIpCiAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBDYWxjdWxhdGVWYWx1ZXMoTmV4dFRva2VuVmFsdWUsIGosIHVwZGF0ZWRfdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArICJcbiIgKyBvdXRwdXQgKyAiXG4iCgoKCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLyAKCgoKCiAgICAgICAgICAgIH0KCgogICAgICAgICAgICAvL0VORCBPRiBGdW5jdGlvbnMgYW5kIEltcG9ydGVkIEZ1bmN0aW9ucwoKCgogICAgICAgICAgICAvL1NFQ1RJT04gLSBQYXJzaW5nIFNUQVJUUyBoZXJlCgogICAgICAgICAgICAvL1NFQ1RJT04gLSBDaGVja2luZyBlYWNoIHRva2VuIGFuZCBhZGRpbmcgdG8gdG9rZW5zIGFycmF5CgoKCiAgICAgICAgICAgIGxldCB0ZW1wdGhpcyA9IHRoaXM7CiAgICAgICAgICAgIGxldCB2YXJpYWJsZUFycmF5ID0gW10gLy9UTyBSRU1PVkUgRFVQTElDQVRFIFZBUklBQkxFUywgU0VFIDQ4MgoKICAgICAgICAgICAgZnVuY3Rpb24gUGFyc2UoY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSB7CgogICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CgoKICAgICAgICAgICAgICAgIHZhciBzdHJpbmcgPSBbXQoKCgoKICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGVsZW1lbnQpID09IHRydWUpIHsKCgogICAgICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkX3NvdXJjZWRhdGFbaSArIDFdID09ICc9JykgewoKCgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoVmFyaWFibGUoZWxlbWVudCwgdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZUFycmF5LmluY2x1ZGVzKGVsZW1lbnQpKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgVXBkYXRlRWxlbWVudFZhbHVlID0gZWxlbWVudAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4ID0gdG9rZW5zLmZpbmQoZWwgPT4gZWwudmFsdWUgPT0gZWxlbWVudCkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSB0b2tlbnMuaW5kZXhPZih4KQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVJbnRpYWxpemVkVmFyaWFibGVzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rva2Vuc1tpbmRleCsyXS52YWx1ZT0gY2xlYW5lZF9zb3VyY2VkYXRhW2krMl0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVBcnJheS5wdXNoKGVsZW1lbnQpCgoKCgogICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xlYW5lZF9zb3VyY2VkYXRhW2kgLSAxXSA9PSAnPScpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoVmFyaWFibGVWYWx1ZShlbGVtZW50LCB0b2tlbnMpCgogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIoZWxlbWVudCkgPT0gdHJ1ZSkgewoKICAgICAgICAgICAgICAgICAgICBQdXNoTnVtYmVyKGVsZW1lbnQsIHRva2VucykKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgZWxzZSBpZihpc0lucHV0KGVsZW1lbnQpPT10cnVlKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICBQdXNoSW5wdXQoZWxlbWVudCx0b2tlbnMsY2xlYW5lZF9zb3VyY2VkYXRhLGkpCiAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09wZXJhdG9yKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICBQdXNoT3BlcmF0b3IoZWxlbWVudCwgdG9rZW5zKQoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CgogICAgICAgICAgICAgICAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQsIHRva2VucykKCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVsZW1lbnQpID09IHRydWUpIHsKClB1c2hGdW5jdGlvbkRhdGEoZWxlbWVudCx0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSxpKQoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL2NoZWNrIGlmIGl0IGFjY3BldHMgQXJyeVsyYV0gYXMgaW5kZXggOiAKICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoZWxlbWVudCkgPT0gdHJ1ZSkgewoKCgoKICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGggLSAxKSA9PSAnXScpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEFycmF5KGVsZW1lbnQsIHRva2VucykKCiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgQnVpbHRBcnJheSA9IEJ1aWxkQXJyYXkoZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKQoKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEFycmF5KEJ1aWx0QXJyYXksIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgLy9mb3IgTnVtYmVyc1thXT14CiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1NldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpID09IHRydWUpIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgUHVzaFNldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSk7CgoKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgLy9mb3IgeD1OdW1iZXJzW2FdCgogICAgICAgICAgICAgICBlbHNlIGlmIChpc1NldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpID09IGZhbHNlKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgUHVzaEdldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkKCgoKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgLyogIGlmIChpc0VtcHR5QXJyYXlJbml0KGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkgPT0gdHJ1ZSkgewoKCgogICAgICAgICAgICAgICAgICAgIFB1c2hFbXB0eUFycmF5SW5pdCh0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkKCgogICAgICAgICAgICAgICAgfQoqLwoKCgogICAgICAgICAgICAgICBlbHNlIGlmIChpc0NvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2hpbGVMb29wKGVsZW1lbnQpID09IHRydWUpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hXaGlsZUxvb3AoZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2hXaGlsZUxvb3BDb25kaXRpb24oZWxlbWVudCwgY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCB0b2tlbnMpCgoKICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaENvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50LCB0b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kY29uZGl0aW9uID0gQnVpbGRDb25kaXRpb24oZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKQogICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmb3VuZGNvbmRpdGlvbjogJywgZm91bmRjb25kaXRpb24pOwoKCgogICAgICAgICAgICAgICAgICAgIFB1c2hDb25kaXRpb24oZm91bmRjb25kaXRpb24sIHRva2VucykKCgoKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRm9yTG9vcChlbGVtZW50KSA9PSB0cnVlKSB7CgogICAgICAgICAgICAgICAgICAgIFB1c2hGb3JMb29wKGVsZW1lbnQsIHRva2VucykKICAgICAgICAgICAgICAgICAgICBQdXNoRm9yTG9vcEFydWd1bWVudHMoZWxlbWVudCwgY2xlYW5lZF9zb3VyY2VkYXRhLCBpLCB0b2tlbnMpCgogICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewoKbmFtZTpjbGVhbmVkX3NvdXJjZWRhdGFbaSsxXSwKdmFsdWU6MCwKdHlwZTogJ0Zvckxvb3BJdGVyYXRvcicKCiAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICBlbHNlIGlmIChpc0NhbGN1bGF0aW9uKGVsZW1lbnQpID09IHRydWUpIHsKCgogICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gJycKCiAgICAgICAgICAgICAgICAgICAgaWYgKGNsZWFuZWRfc291cmNlZGF0YVtpICsgMV0gIT0gdW5kZWZpbmVkKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdG8gcGVyZm9ybSBsb25nIG9wZXJhdGlvbnMgbGlrZSBBdmVyYWdlQWdlPShhZ2VvbmUrYWdldHdvKS8yICsgKGFnZW9uZSthZ2V0d28pKjIKCiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpc0NhbGN1bGF0aW9uKGNsZWFuZWRfc291cmNlZGF0YVtpXSkpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQgKyBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkrKzsKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgLy9QdXNoQ2FsY3VsYXRpb24oZWxlbWVudCx0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgIC8vICAKICAgICAgICAgICAgICAgICAgICB0ZXJtcyA9IGVsZW1lbnQuc3BsaXQoJycpCgogICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZpbmcgdGhlICIoIiIgYW5kICIpIgoKICAgICAgICAgICAgICAgICAgICB2YXIgQ2xlYW5lZEVsZW1lbnQgPSBSZW1vdmVCcmFja2V0cyhlbGVtZW50KQoKCiAgICAgICAgICAgICAgICAgICAgLy8gdG8gc3RvcCBwcmV2ZW50aW9uIG9mIGV4cHJlc3Npb25zIGxpa2UgaXMiKyBnZXR0aW5nIGFkZGVkIGFzIGEgY2FsY3VsYXRpb24KICAgICAgICAgICAgICAgICAgICBpZiAoIShDbGVhbmVkRWxlbWVudC5pbmNsdWRlcygnIicpKSAmJiBlbGVtZW50LmNoYXJBdCgwKSAhPSAnLycgJiYgZWxlbWVudC5jaGFyQXQoMCkgIT0gJyonKSB7CgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoQ2FsY3VsYXRpb24oZWxlbWVudCwgdG9rZW5zLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpCgoKCiAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgLy8gdGVybXMyID0gQ2xlYW5lZEVsZW1lbnQuc3BsaXQob3BlcmF0aW9uKQoKICAgICAgICAgICAgICAgICAgICAvL2NoZWNrcG9pbnQ6IHRvIHBlcmZvcm0gY2FsY3VsYXRpb25zIAogICAgICAgICAgICAgICAgICAgIC8vSSBoYXZlIGlkZW50aWZpZWQgdGhlIG9wZXJhdGlvbihzZXBlcmF0ZWQpIGFuZCB0ZXJtcyAoc2VwZXJhdGVkKQoKCgogICAgICAgICAgICAgICAgICAgIC8qICAgICAgdGVtcHRoaXMuT3BlcmF0aW9uT2JqZWN0cy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1zOiB0ZXJtczIsCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgICAqLwoKCgoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIHByaW50KCJzd2FuYW5kIikuIFRoZSByZWFsdGltZXByaW50IG9wZXJhdGlvbnMKCgoKICAgICAgICAgICAgICBlbHNlICBpZiAoaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoZWxlbWVudCkgPT0gdHJ1ZSkgewoKCgogICAgICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kU3RyaW5nID0gJycKCiAgICAgICAgICAgICAgICAgICAgbGV0IGsgPSBpCiAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdlbGVtZW50OiAnLCBlbGVtZW50KTsKICAgICAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uRW5kID0gZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGggLSAxKSArIGVsZW1lbnQuY2hhckF0KGVsZW1lbnQubGVuZ3RoIC0gMikKCiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnY29uZGl0aW9uRW5kOiAnLCBjb25kaXRpb25FbmQpOwoKCiAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWcgPSAwOwoKCgoKICAgICAgICAgICAgICAgICAgICBmb3IgKGs7IGsgPCBjbGVhbmVkX3NvdXJjZWRhdGEubGVuZ3RoOyBrKyspIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gY2xlYW5lZF9zb3VyY2VkYXRhW2tdCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdlbGVtZW50OiAnLCBlbGVtZW50KTsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbkVuZCA9IGVsZW1lbnQuY2hhckF0KGVsZW1lbnQubGVuZ3RoIC0gMSkgKyBlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDIpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkX3NvdXJjZWRhdGFba10uaW5jbHVkZXMoJ+CkpuClgeCkueCksOCkvuCkkycpIHx8IGNsZWFuZWRfc291cmNlZGF0YVtrXS5pbmNsdWRlcygn4KSq4KWN4KSw4KS/4KSC4KSfJykgfHwgY2xlYW5lZF9zb3VyY2VkYXRhW2tdLmluY2x1ZGVzKCfgpIXgpJfgpLAnKSB8fCBjbGVhbmVkX3NvdXJjZWRhdGFbayArIDFdID09ICc9J3x8IGNsZWFuZWRfc291cmNlZGF0YVtrXSA9PSAnfScpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3VuZFN0cmluZz1mb3VuZFN0cmluZysgICcgJysgY2xlYW5lZF9zb3VyY2VkYXRhW2tdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25FbmQgPT0gJykiJykKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFN0cmluZyA9IGZvdW5kU3RyaW5nICsgJyAnICsgY2xlYW5lZF9zb3VyY2VkYXRhW2tdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZsYWcgPT0gMSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RyaW5nID0gZm91bmRTdHJpbmcgKyAnICcgKyBjbGVhbmVkX3NvdXJjZWRhdGFba10KCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZsYWcgPT0gMCkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RyaW5nID0gY2xlYW5lZF9zb3VyY2VkYXRhW2tdOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSAxOwoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgaWYgKCghZm91bmRTdHJpbmcuaW5jbHVkZXMoIj4iKSkgJiYgKCFmb3VuZFN0cmluZy5pbmNsdWRlcygnLycpKSAmJiAoIWZvdW5kU3RyaW5nLmluY2x1ZGVzKCcqJykpICYmICghZm91bmRTdHJpbmcuaW5jbHVkZXMoJzwnKSkgJiYgKCFmb3VuZFN0cmluZy5pbmNsdWRlcygnPT0nKSkpCgoKICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmb3VuZFN0cmluZzogJywgZm91bmRTdHJpbmcpOwogICAgICAgICAgICAgICAgICAgICAgICBQdXNoUmVhbFRpbWVQcmludE9wZXJhdGlvbihmb3VuZFN0cmluZywgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAKCgoKCiAgICAgICAgICAgICAgICAvL3N0b3Jpbmcgb25seSB0aGUgc3RyaW5nIHZhbHVlcyB0byB0b2tlbnMgKCBub3QgdGhlIHN0cmluZ3MgaW4gcHJpbnQgc3RhdGVtZW50cykKCiAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKQoKCiAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGN1bGF0ZWRTdHJpbmcgPSBCdWlsZFN0cmluZyhlbGVtZW50LCBpLCBjbGVhbmVkX3NvdXJjZWRhdGEpCgoKCiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZFN0cmluZyA9IGNhbGN1bGF0ZWRTdHJpbmcucmVwbGFjZSgvWyciXSsvZywgJycpCgogICAgICAgICAgICAgICAgICAgIGlmICghKGNhbGN1bGF0ZWRTdHJpbmcuaW5jbHVkZXMoIuCkquCljeCksOCkv+CkguCknyIpKSkKCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hTdHJpbmcoY2FsY3VsYXRlZFN0cmluZywgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAvLwoKCgogICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgIC8vRm91bmQgU29sdXRpb24gdXNpbmcgcmVnZXhwLSBwcmludChhKSB3aXRob3V0IHNwYWNlIGlzIGdldHRpbmcgYWNjZXB0ZWQgYXMgZXhwcmVzc2lvbgoKCiAgICAgICAgICAgICAgIGVsc2UgaWYgKC9eKD89Lio/4KSq4KWN4KSw4KS/4KSC4KSfKSg/PS4qW2Etel0pLy50ZXN0KGVsZW1lbnQpKSB7CgogICAgICAgICAgICAgICAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQuc2xpY2UoMCwgNiksIHRva2Vucyk7IC8vUHVzaGluZyBwcmludCBrZXl3b3JkIG9ubHkKCgogICAgICAgICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKGVsZW1lbnQuc2xpY2UoNiksIHRva2VucykgLy9QdXNoaW5nIHJlbWFpbmluZyBleHByZXNzaW9uIGxpa2UgKGEpLCAoZ2FnYWtzKSBldGMKICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgLy9lcnJvciBwcm9uZSBjaGFuZ2UgbWFkZSBoZXJlCgogICAgICAgICAgICAgZWxzZSAgIGlmIChpc0V4cHJlc3Npb24oZWxlbWVudCkgPT0gdHJ1ZSAmJiAhaXNDYWxjdWxhdGlvbihlbGVtZW50KSAmJiAhZWxlbWVudC5pbmNsdWRlcygnWycpICYmICFlbGVtZW50LmluY2x1ZGVzKCddJykgJiYgKCFpc0NvbmRpdGlvbmFsS2V5d29yZChjbGVhbmVkX3NvdXJjZWRhdGFbaSAtIDFdKSkgJiYgKGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0gIT0gJ+CkruClhycgJiYgY2xlYW5lZF9zb3VyY2VkYXRhW2kgLSAxXSAhPSAn4KSV4KS+4KSw4KWN4KSvJyAgKSkgewoKCgppZihlbGVtZW50LmNoYXJBdCgwKSE9JygnKQp7CgpsZXQgQ2hlY2tGdW5jdGlvbkV4cHJlc3Npb249IGVsZW1lbnQuc3BsaXQoJygnKQoKCmxldCBwYXNzZWRWYWx1ZXM9UmVtb3ZlQnJhY2tldHMoQ2hlY2tGdW5jdGlvbkV4cHJlc3Npb25bMV0pCnBhc3NlZFZhbHVlcz1wYXNzZWRWYWx1ZXMuc3BsaXQoJywnKQpsZXQgdG9rZW49IHRva2Vucy5maW5kKGVsPT4gZWwudmFsdWU9PUNoZWNrRnVuY3Rpb25FeHByZXNzaW9uWzBdKQoKCmlmKHRva2VuIT11bmRlZmluZWQpCnsKCgoKdG9rZW4uRnVuY3Rpb25JbnZvY2F0aW9uRXhpc3RzPXRydWUKdG9rZW4uRXhlY3V0aW9uSW5kZXg9aS0xCnRva2VuLnBhc3NlZFZhbHVlcz1wYXNzZWRWYWx1ZXMKCgoKfQoKfQoKICAgICAgICAgICAgICAgICAgICBQdXNoRXhwcmVzc2lvbihlbGVtZW50LCB0b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICBlbHNlICAgaWYgKGlzRXhwcmVzc2lvbihlbGVtZW50KSA9PSB0cnVlICYmIGVsZW1lbnQuaW5jbHVkZXMoJ1snKSAmJiBlbGVtZW50LmluY2x1ZGVzKCddJykpIHsKCiAgICAgICAgICAgICAgICAgICAgUHVzaEFycmF5KGVsZW1lbnQsIHRva2VucykKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgIGVsc2UgICBpZiAoIWlzS2V5d29yZChlbGVtZW50KSAmJiAhaXNOdW1iZXIoZWxlbWVudCkgJiYgIWlzVmFyaWFibGUoZWxlbWVudCkgJiYgIWlzRXhwcmVzc2lvbihlbGVtZW50KSAmJiAhaXNPcGVyYXRvcihlbGVtZW50KSkgewoKCiAgICAgICAgICAgICAgICAgICAgLy9BTkNIT1IgCiAgICAgICAgICAgICAgICAgICAgLypIbmFkbGluZyBJbXB1cml0eSBlcnJvci1UaGUgbWFpbiBwcm9ibGVtIGlzIGZpZ3VyaW5nIG91dCBob3cgdG8gc29sdmUgIj03MDAwIiBsaWtlIHRoaW5ncwogICAgICAgICAgICAgICAgICAgIGluc3RlYWQgYXNraW5nIGRldmVsb3BlcnMgdG8gYWRkIHNwYWNlIG1hbnVhbGx5CiAgICAgICAgICAgICAgICAgICAgSGFuZGxpbmcgQWxwaGFudW1lcmljIHN0cmluZ3MgdG8gc29sdmUgaXNzdWVzIGxpa2UgJyBhbm5hPTIzNjI5MzQnCgogICAgICAgICAgICAgICAgICAgIGxldCBpbXB1cml0eSA9IGVsZW1lbnQuc3BsaXQoJz0nKQoKICAgICAgICAgICAgICAgICAgICBsZXQgZmluZFN0cmluZyA9IGltcHVyaXR5WzFdCgoKICAgICAgICAgICAgICAgICAgICAvL3RvIGFjY2VwdCBsb25nIG51bWJlcnMgaS5lIGE9NzQ5Mzc0NTkzNzQ1OTM3CgogICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGltcHVyaXR5WzBdKSAmJiBpc051bWJlcihpbXB1cml0eVsxXSkpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBpbXB1cml0eVsyXSA9IGltcHVyaXR5WzFdOwogICAgICAgICAgICAgICAgICAgICAgICBpbXB1cml0eVsxXSA9ICc9JzsKCiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAvL3RvIGFjY2VwdCBhPVNUUklORwogICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGltcHVyaXR5WzBdKSAmJiBpc1ZhcmlhYmxlKGltcHVyaXR5WzFdKSkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXR5WzJdID0gaW1wdXJpdHlbMV07CiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXR5WzFdID0gJz0nOwoKICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHkuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4gewoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoZWxlbWVudCkgPT0gdHJ1ZSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaFZhcmlhYmxlKGVsZW1lbnQsIHRva2VucykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb250aW51ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy8gQU5DSE9SIAoKICAgICAgICAgICAgICAgICAgICAgICAgLy9Jc3N1ZTogUmlnaHQgbm93LCBvbmx5IGlzTnVtYmVyIGlzIHJlc29sdmVkLCBhPSwgPTIzODI4cXcgYXJlbid0IHJlc29sdmVkLgogICAgICAgICAgICAgICAgICAgICAgICAvL1NvbHV0aW9uOiBXb3JrIG9uIGFsbCB0aGUgbW9kdWxlcwoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihlbGVtZW50KSA9PSB0cnVlKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hOdW1iZXIoZWxlbWVudCwgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy9BTkNIT1IgCiAgICAgICAgICAgICAgICAgICAgICAgIC8vWW91IG1pZ2h0IGhhdmUgdG8gcmVtb3ZlIHRoaXMgZXh0cmEgZmlsdGVycyBzaW5jZSB5b3UgYXJlIG9ubHkgd29ya2luZyBvbiBudW1iZXJzIChGdXR1cmUgSXNzdWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09wZXJhdG9yKGVsZW1lbnQpID09IHRydWUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hPcGVyYXRvcihlbGVtZW50LCB0b2tlbikKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEtleXdvcmQoZWxlbWVudCkKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0V4cHJlc3Npb24oZWxlbWVudCkgPT0gdHJ1ZSkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoRXhwcmVzc2lvbihlbGVtZW50LCB0b2tlbnMpCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgIH0pCiAqLwoKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vU0VDVElPTiAtIENoZWNraW5nIGVhY2ggdG9rZW4gYW5kIGFkZGluZyB0byB0b2tlbnMgYXJyYXkKICAgICAgICAgICAgLy8gUEFSU0lORyBJTklUSUFUSU9OCgoKICAgICAgICAgICAgZm9yIChpOyBpIDwgY2xlYW5lZF9zb3VyY2VkYXRhLmxlbmd0aDsgaSsrKSB7CgoKICAgICAgICAgICAgICAgIFBhcnNlKGNsZWFuZWRfc291cmNlZGF0YSwgaSkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy9BTkNIT1IgCiAgICAgICAgICAgIC8vQ0xFQU5JTkcgVVAgVEhFIFRPS0VOUyBBUlJBWQogICAgICAgICAgICAvL1JlbW92aW5nIHRva2VucyB3aXRoIHZhbHVlID0gJycsIEl0IHdhcyBnZW5lcmF0ZWQgZHVlIHRvICIgY2xlYW5lZF9zb3VyY2VkYXRhID0gY2xlYW5lZF9zb3VyY2VkYXRhLnJlcGxhY2UoLyg7fFxufFxyKS9nbSwgIiAiKS5zcGxpdCgnICcpIgogICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuZmlsdGVyKGVsID0+IGVsLnZhbHVlICE9ICcnKQogICAgICAgICAgICBjb25zb2xlLmxvZygndG9rZW5zOiAnLCB0b2tlbnMpOwoKCgoKICAgICAgICAgICAgLy9UbyBmaW5kIHVuZGVmaW5lZCB2YXJpYWJsZXMKICAgICAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSB2YXJpYWJsZXNfYXJyYXkuZmlsdGVyKHggPT4gIWFzc2lnbmVkX3ZhcmlhYmxlcy5pbmNsdWRlcyh4KSkKCiAgICAgICAgICAgIC8vCgogICAgICAgICAgICBpZiAoZGlmZmVyZW5jZS5sZW5ndGggPiAwKQoKICAgICAgICAgICAgewogICAgICAgICAgICAgICAgdGhpcy5lcnJvci5wdXNoKCcgVmFyaWFibGUgJyArIGRpZmZlcmVuY2UudG9TdHJpbmcoKS5zcGxpdCgnLCcpICsgJyBpcyB1bmRlZmluZWQgJykKCiAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgIC8vU0VDVElPTiAtIFByaW50aW5nIE91dHB1dHMsIGNvbnNpZGVyaW5nIGNvbmRpdGlvbnMsIGZpbmRpbmcgdmFsdWVzIGluIHVwZGF0ZWRfdG9rZW5zCgoKCgogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykgewoKICAgICAgICAgICAgICAgIC8vIENoZWNraW5nIGZvciBhc3NpZ25tZW50IG9wZXJhdG9ycwoKICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBsZXQgbXV0YWJsZV90b2tlbnMgPSB0b2tlbnMKICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlCiAgICAgICAgICAgICAgICBsZXQgdG9rZW5UeXBlID0gbXV0YWJsZV90b2tlbnNbal0udHlwZQoKCgogICAgICAgICAgICAgICAgdmFyIFN0cmluZ1ZhciA9IFtdCgogICAgICAgICAgICAgICAgbGV0IFZhcldpdGhvdXRicmFja2V0cyA9IFJlbW92ZUJyYWNrZXRzKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlKQoKICAgICAgICAgICAgICAgIFZhcldpdGhvdXRicmFja2V0cyA9IFZhcldpdGhvdXRicmFja2V0cy5yZXBsYWNlKC8gL2csICcnKQoKCiAgICAgICAgICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbal0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikKCgoKICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlVG9TZXQgPSBtdXRhYmxlX3Rva2Vuc1tqXS5WYWx1ZVRvU2V0CgoKICAgICAgICAgICAgICAgICAgICAvL0ZvciBOdW1iZXJzW2FdPWFnZW9uZSsxMDAgbGlrZSBjYWxjdWxhdGlvbnMKCiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsY3VsYXRpb24oVmFsdWVUb1NldCkpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMpCgoKICAgICAgICAgICAgICAgICAgICAgICAgR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQobXV0YWJsZV90b2tlbnNbal0udmFsdWUsIHVwZGF0ZWRfdG9rZW5zLCBWYWx1ZVRvU2V0KQoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIC8vRm9yIE51bWJlcnNbYV09YWdlb25lICwgZGlyZWN0IHNldHRpbmcKICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBHZXRBcnJheW9yU3RyaW5nRWxlbWVudChtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSwgdXBkYXRlZF90b2tlbnMsIFZhbHVlVG9TZXQpCgogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGVsc2UgaWYgKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlID09ICc9JykgewoKICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCgogICAgICAgICAgICAgICAgICAgIGxldCB2YXJpYWJsZSA9IG11dGFibGVfdG9rZW5zW2ogLSAxXS52YWx1ZQoKCgoKICAgICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICAgIGxldCB2YXJ2YWx1ZSA9IG11dGFibGVfdG9rZW5zW2ogKyAxXS52YWx1ZQoKCiAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgLy9maW5kaW5nIGlmIGVsZW1lbnRzIGlzIGFscmVhZHkgYXNzZ2luZWQgaW4gdXBkYXRlZCB0b2tlbnMKICAgICAgICAgICAgICAgICAgICAvL3RvIHNvbHZlIG5hbWU9J3N3YW5hbmQnIGFuZCBuYW1lPSAnb3RoZXIgc3dhbmFuZCcKICAgICAgICAgICAgICAgICAgICAvL2JvdGggc2hwdWxkIGJlIHByaW50ZWQgYWNjb3JkaW5nZ2x5CgoKCiAgICAgICAgICAgICAgICAgICAgbGV0IG0gPSB1cGRhdGVkX3Rva2Vucy5maW5kKChlbCwgaSkgPT4gZWwubmFtZSA9PSB2YXJ2YWx1ZSkKCiAgICAgICAgICAgICAgICAgICAgdmFydmFsdWUgPSBtICE9IHVuZGVmaW5lZCA/IG0udmFsdWUgOiB2YXJ2YWx1ZQoKCgoKICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoKGVsLCBpKSA9PiBlbC5uYW1lID09IHZhcmlhYmxlKQoKCgoKICAgICAgICAgICAgICAgICAgICAvLyAKCgoKICAgICAgICAgICAgICAgICAgICBpZiAobiA9PSB1bmRlZmluZWQpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgLy90byBjaGVjayBpZiB0aGUgYXNzaWduZWQgdmFsdWUgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC4gdGhpcyBpcyBmdXRoZXIgZGl2ZWRlZCBpbiB0d28gdHlwZXMKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsY3VsYXRpb24odmFydmFsdWUpKQoKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90eXBlIDEtIEFnZT0gMjAyMC0yMDAwIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHVyZUV2YWwodmFydmFsdWUpKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZXZhbCh2YXJ2YWx1ZSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93cml0ZSBmdW5jdGlvbiBmb3IgdGhpcywgc28gcmVwZWF0YWJsZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YXJpYWJsZSwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGosCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG11dGFibGVfdG9rZW5zW2ogKyAxXS50eXBlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHlwZSAyLSBYPSBhZ2VvbmUrYWdldHdvCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcGVyZm9ybWluZyB0aGUgY2FsY3VsYXRpb24KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBDYWxjdWxhdGVWYWx1ZXModmFydmFsdWUsIGosIHVwZGF0ZWRfdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFyaWFibGUsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtdXRhYmxlX3Rva2Vuc1tqICsgMV0udHlwZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlLCBwdXNoIHZhbHVlcyBhcyBpdCBpcwogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YXJpYWJsZSwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhcnZhbHVlLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG11dGFibGVfdG9rZW5zW2ogKyAxXS50eXBlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGFscmVhZHkgYXNzZ2luZWQsIHJlYXNzaWduIGl0IHdpdGggdXBkYXRlZCB2YWx1ZQogICAgICAgICAgICAgICAgICAgIGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsY3VsYXRpb24odmFydmFsdWUpKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IE5ld1ZhbHVlID0gQ2FsY3VsYXRlVmFsdWVzKHZhcnZhbHVlLCBqLCB1cGRhdGVkX3Rva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4udmFsdWUgPSBOZXdWYWx1ZQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbi52YWx1ZSA9IHZhcnZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgLy8gCgoKICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgIGVsc2UgaWYodG9rZW5UeXBlPT0nQWNjZXB0SW5wdXQnKQogICAgICAgICAgICAgICAgewoKbGV0IFNldElucHV0VmFsdWVBcz0gbXV0YWJsZV90b2tlbnNbal0uQWNjZXB0QXMKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZT1wcm9tcHQoJ0VudGVyIFZhbHVlIGZvcicgKyBTZXRJbnB1dFZhbHVlQXMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd2YWx1ZTogJywgdmFsdWUpOwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBTZXRJbnB1dFZhbHVlQXMsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KQoKCiAKKGFzeW5jICgpID0+IHsKICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHByb21wdHMoewogICAgdHlwZTogJ251bWJlcicsCiAgICBuYW1lOiAndmFsdWUnLAogICAgbWVzc2FnZTogJ0hvdyBvbGQgYXJlIHlvdT8nLAogICAgdmFsaWRhdGU6IHZhbHVlID0+IHZhbHVlIDwgMTggPyBgTmlnaHRjbHViIGlzIDE4KyBvbmx5YCA6IHRydWUKICB9KTsKIAogIGNvbnNvbGUubG9nKHJlc3BvbnNlKTsgLy8gPT4geyB2YWx1ZTogMjQgfQp9KSgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgIH0KCgoKCgoKICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlblR5cGU9PSdmdW5jdGlvbicpCnsKCi8vY2hlY2tpbmcgaWYgZnVuY3Rpb24gaXMgaW52b2tlZCBzb21ld2hlcmUgbGF0ZXIgaW4gdGhlIHByb2dyYW0KbGV0IGZ1bmN0aW9uSW52b2NhdGlvbj1tdXRhYmxlX3Rva2Vuc1tqXS5GdW5jdGlvbkludm9jYXRpb25FeGlzdHMKCgoKICBpZihmdW5jdGlvbkludm9jYXRpb24pCiAgewpsZXQgZnVuY3Rpb25Tb3VyY2VEYXRhPVtdCgogbGV0IHJlc3VsdCA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2VucywgaiwgZnVuY3Rpb25Tb3VyY2VEYXRhICkKCiBmdW5jdGlvblNvdXJjZURhdGE9cmVzdWx0LlN0b3JlUmVzdWx0CgpsZXQgZnVuY3Rpb25Bcmd1bWVudHM9bXV0YWJsZV90b2tlbnNbal0uYXJndW1lbnRzCmxldCBmdW5jdGlvbk5hbWU9bXV0YWJsZV90b2tlbnNbal0udmFsdWUKCmxldCBwYXNzZWRWYWx1ZXM9bXV0YWJsZV90b2tlbnNbal0ucGFzc2VkVmFsdWVzCgoKCi8vQ3JlYXRpbmcgYSBzZXBlcmF0ZSBleGVjdXRpb24gY29udGV4dCBhbmQgc2V0dGluZyBmdWNudGlvbiBjb250ZXh0IG5hbWU6dmFsdWUgcGFpciBpbiAnZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMnCmZ1bmN0aW9uQXJndW1lbnRzLmZvckVhY2goKGVsLGluZGV4KSA9PiB7CgoKICAgbGV0IHZhbD0gcGFzc2VkVmFsdWVzW2luZGV4XQogICB2YWwgPSB2YWwucmVwbGFjZSgvIi9nLCAiIik7CiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoLycvZywgIiIpOwoKICAgICAgICAgICAgICAgICAgICBwYXNzZWRWYWx1ZXNbaW5kZXhdPXZhbAogICAgCmZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zLnB1c2goewogICAgCiAgICAKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWwsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFzc2VkVmFsdWVzW2luZGV4XSwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGoraW5kZXgsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd2YWx1ZScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6J0Z1bmN0aW9uRXhlY3V0aW9uQ29udGV4dCcKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCgp9KQoKCgoKfSk7CgoKdmFyIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3Q9Wy4uLnVwZGF0ZWRfdG9rZW5zLC4uLmZ1bmN0aW9uQ29udGV4dHVwZGF0ZWRfdG9rZW5zXQpjb25zb2xlLmxvZygnQ29tcGxldGVUb2tlblZhbHVlTGlzdDogJywgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7CgoKZm9yKGxldCBpPTE7aTxmdW5jdGlvblNvdXJjZURhdGEubGVuZ3RoO2krKykKCnsKCgpsZXQgZWw9ZnVuY3Rpb25Tb3VyY2VEYXRhW2ldCgoKCgoKaWYoZWwudmFsdWU9PSfgpKrgpY3gpLDgpL/gpILgpJ8nKQoKewoKCiBJZlRva2VuUHJpbnQobXV0YWJsZV90b2tlbnMsZnVuY3Rpb25Db250ZXh0dXBkYXRlZF90b2tlbnMsIGoraSwgdGhpcykgCgoKfQoKZWxzZSAgaWYgKGVsLnR5cGU9PSAnY29uZGl0aW9uJykKCiAgICAgICAgICAgICAgICB7CgoKCgogICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZnVuY3Rpb25Tb3VyY2VEYXRhW2ldLnZhbHVlCgogICAgICAgICAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBjYWxjdWxhdGUgdmFsdWUgb2Ygb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCgogICAgICAgICAgICAgICAgICAgIGxldCBDb25kaXRpb25WYWx1ZSA9IEdldENvbmRpdGlvblZhbHVlKGVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGkpCiAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdqOiAnLGopOwoKCgoKICAgICAgICAgICAgICAgICAgICAvL2lmIHZhbHVlIGlzIGZhbHNlLCBqdXN0IHNraXAgdGhlIGlmIGxvb3AgY29udGV4dCwgaWYgbm90IGl0IHdpbGwgYmUgcmFuIGluIGZpbmFsIHByaW50IG1vZHVsZQoKICAgICAgICAgICAgICAgICAgICBpZiAoQ29uZGl0aW9uVmFsdWUgPT0gZmFsc2UpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbml0aWFsaXplTG9vcCA9IHRva2Vucy5pbmRleE9mKGZ1bmN0aW9uU291cmNlRGF0YVtpXSkKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlIEJsb2NrcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGNhcmUgb2YgbmVzdGVkIGJsb2NrIGJ5IHRha2luZyBjYXJlIG9mIG5lc3RlZCB7IGFuZCB9IGJyYWNrZXRzCiAgICAgICAgICAgICAgICAgICAgICAgIC8vaXQgdXNlcyB0aGUgc3RhY2sgdG8gcHVzaCBhbmQgcG9wIGJyYWNrZXRzIHRvIGFjY3VyYXRlbHkgaWRlbnRpZnkgc3RhcnQgYW5kIHRoZSBlbmQgb2YgdGhlIGJsb2NrCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhmdW5jdGlvblNvdXJjZURhdGEsIGkpCgogICAgICAgICAgICAgICAgICAgICAgICBpID0gUmV0dXJudmFsdWUuaQogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICB9CgoKCiAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxpbmcgc2V0IGFycmF5IGVsZW1lbnQgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgIGlmIChmdW5jdGlvblNvdXJjZURhdGFbaV0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBWYWx1ZSA9IGZ1bmN0aW9uU291cmNlRGF0YVtpXS52YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnM6ICcsIFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1ZhbHVlOiAnLCBWYWx1ZSxpKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlVG9TZXQgPSBmdW5jdGlvblNvdXJjZURhdGFbaV0uVmFsdWVUb1NldAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IFJlbW92ZUJyYWNrZXRzKFZhbHVlKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEFycmF5RWxlbWVudCA9ICcnCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NlcHJhdGluZyBvdXQgaW5kZXggaWRlbnRpZmllci4geHl6IGZyb20gQXJyYXlbeHl6XQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5yZXBsYWNlKCddJywgJycpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgU3BsaXQgPSBlbGVtZW50LnNwbGl0KCdbJykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBydW4gaWYgd2UgbmVlZCB0byBzZXQgZGlyZWN0IEFycmF5IGVsZW1lbnQgdmFsdWUuIGxpa2UgQXJyYXlbMl09IHh5eCAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKFNwbGl0WzFdKSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQgKyAnXScKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBTcGxpdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGosIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QgKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTmV3VmFsdWVUb1NldDogJywgTmV3VmFsdWVUb1NldCk7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgZmFsc2UsIE5ld1ZhbHVlVG9TZXQsIHRva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBydW4gaWYgd2UgbmVlZCB0byBkeW5hbWljYWxseSBzZXQgQXJyYXkgZWxlbWVudCB2YWx1ZS4gbGlrZSBBcnJheVtpXT0geHl4CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9DcmVhdGVBcnJheUVsZW1lbnQgZnVuY3Rpb24gd2lsbCBjcmVhdGUgZHluYW1pYyBBcnJheSB2YWx1ZXMuIGxpa2UgQXJyYXlbMF0sIEFycmF5WzFdIGV0Yy4gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IFNwbGl0WzFdCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZyBpdGVyYXRvciBhcyBwZXIgdXNlciBpbnB1dCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgaXRlcmF0b3IgbGlrZSBjb3VudD1jb3VudCArIDEsIEFycmF5W2NvdW50XQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0ludGVyYXRvciA9IDAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRva2VuID0gQ29tcGxldGVUb2tlblZhbHVlTGlzdC5maW5kKGVsID0+IGVsLm5hbWUgPT0gaW5kZXgpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT0gdW5kZWZpbmVkKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhdG9yID0gdG9rZW4udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhdG9yID0gaXRlcmF0b3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBDcmVhdGVBcnJheUVsZW1lbnQoVmFsdWUsIG5ld0ludGVyYXRvcikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIGlzIHdyaXR0ZW4gdG8gZmluZCBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09IGEqMTAwK2FnZSphLiBub3RpY2UgYQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmluZCBhIHdheSB0byBzaW1wbGlmeSB0aGlzIGluIGxvbmcgdGVybQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFZhbHVlVG9TZXQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcqJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnKycpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJy0nKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcvJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGF0YTogJywgQXJyYXlFbGVtZW50LCBkYXRhLCBTcGxpdCk7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYnVpbGRpbmcgYSBuZXcgdmFsdWUgdG8gY29udmVydCBhKjEwMCthZ2UqYSBpbnRvIDUqMTAwK2FnZSphIGFuZCB0aGVuIHNlbmRpbmcgaXQgdG8gQ2FsY3VsYXRlVmFsdWVzKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmV3VmFsdWVUb1NldCA9ICcnCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaW5jbHVkZXMoU3BsaXRbMV0pICYmIGRhdGEubGVuZ3RoID4gMSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgaGF2ZSBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09IGEqMTAwK2FnZSphLiBub3RpY2UgYQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCBWYWx1ZVRvU2V0Lmxlbmd0aDsgbSsrKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWYWx1ZVRvU2V0W21dID09IFNwbGl0WzFdICYmICEoL15bYS16XSskL2kudGVzdChWYWx1ZVRvU2V0W20gKyAxXSkpKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpcyBiZWVuIHNldCAuIHJlcGxhY2luZyBpbmRleCB2YWx1ZSBhIHdpdGggaXRlYXJ0b3IgdmFsdWUgMCwxLDIsIGV0Yy4gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gTmV3VmFsdWVUb1NldCArIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IE5ld1ZhbHVlVG9TZXQgKyBWYWx1ZVRvU2V0W21dCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXQgPSBmYWxzZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dhdmUgaXQgYSBkaWZmZXJlbnQgbmFtZSBzbyBpdCB3b3VsZCBub3QgZnVjayB1cCB3aXRoIGZvciBsb29wIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKE5ld1ZhbHVlVG9TZXQsIGosIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsICkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpdGVyYXQsIE5ld1ZhbHVlVG9TZXQsIHRva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb25kaXRpb24gZW5hYmxlcyBwcm9ncmFtIHRvIG9ubHkgcnVuICBBcnJheVthXT0geHl6IHdoZW4gaXRlcmF0b3IgaXMgYS4gSXQgZGlzYWxsb3dzIHJ1bm5pbmcgQXJyYXlbYmxhYmxhYmxhXT14eXoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT3JpZ2luYWxJdGVyYXRvciA9PSBTcGxpdFsxXSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNwbGl0WzFdID09IFZhbHVlVG9TZXQpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gdHJ1ZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT1hZ2VvbmUqMTAwCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmluY2x1ZGVzKFNwbGl0WzFdKSAmJiBPcmlnaW5hbEl0ZXJhdG9yID09IFNwbGl0WzFdKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBmYWxzZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9taWdodCBoYXZlIHRvIGFkZCBtb3JlIGNvbmRpdGlvbnMgaW4gdGhlIGZ1dHVyZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiBlbHNlICBpZiAoZnVuY3Rpb25Tb3VyY2VEYXRhW2ldLnR5cGUgPT0gJ0Zvckxvb3BTdGFydCcpCgoKCiAgICAgICAgICAgICAgICB7CgogIHZhciBGbGFnUHJpbWFsTG9vcCA9IDAKICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIHZhciBTb3VyY2VkYXRhVG9rZW5zID0gW10KCiAgICAgCi8vY29uc29sZS5sb2coJ3VwZGF0ZWRfdG9rZW5zOiAnLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgIGxldCBGb3JMb29wTWV0YURhdGE9IEZvckxvb3BTZXRNZXRhZGF0YShmdW5jdGlvblNvdXJjZURhdGEsaSxDb21wbGV0ZVRva2VuVmFsdWVMaXN0KQogICAgIAoKdmFyIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydD1Gb3JMb29wTWV0YURhdGEuRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0CnZhciBDeWNsZT1Gb3JMb29wTWV0YURhdGEuQ3ljbGUKdmFyIE9yaWdpbmFsSXRlcmF0b3I9Rm9yTG9vcE1ldGFEYXRhLk9yaWdpbmFsSXRlcmF0b3IKdmFyIEl0ZXJhdGlvblN0YXJ0PUZvckxvb3BNZXRhRGF0YS5JdGVyYXRpb25TdGFydAp2YXIgaXRlcmF0b3I9Rm9yTG9vcE1ldGFEYXRhLml0ZXJhdG9yCnZhciBlbGVtZW50PUZvckxvb3BNZXRhRGF0YS5lbGVtZW50CnZhciBlbGVtZW50VmFsdWU9Rm9yTG9vcE1ldGFEYXRhLmVsZW1lbnRWYWx1ZQoKICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIGZ1bmN0aW9uU291cmNlRGF0YSwgY2hlY2ssIFN0b3JlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0YXJ0SW5kZXgsIGZ1bmN0aW9uU291cmNlRGF0YSwgY2hlY2ssIFN0b3JlUmVzdWx0OiAnLCBzdGFydEluZGV4LCBmdW5jdGlvblNvdXJjZURhdGEsIGNoZWNrLCBTdG9yZVJlc3VsdCk7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhmdW5jdGlvblNvdXJjZURhdGEsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KQogICAgICAgICAgICAgICAgICAgICAgICBTdG9yZVJlc3VsdCA9IFJldHVybnZhbHVlLlN0b3JlUmVzdWx0CgoKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0CgoKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KGZ1bmN0aW9uU291cmNlRGF0YSwgaSwgJ3snLCBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQpCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2VucyA9IGdldFNvdXJjZWRhdGEoRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBmdW5jdGlvblNvdXJjZURhdGEsICd9JywgU291cmNlZGF0YVRva2VucykKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zLmZvckVhY2goZWw9PnsKCmVsLmlzTmVzdGVkTG9vcD1mYWxzZQoKICAgICAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAgICAgbGV0IEZpbmROZXN0ZWRMb29wPSBTb3VyY2VkYXRhVG9rZW5zLmZpbmQoZWw9PiBlbC50eXBlPT0nRm9yTG9vcFN0YXJ0JykKICAgICAgICAgICAgICAgICAgIGlmKEZpbmROZXN0ZWRMb29wIT11bmRlZmluZWQpCiAgICAgICAgICAgICAgICAgICB7CiAgCiAgICAgICAgICAgICAgICAgICAgICAgbGV0IE5lc3RlZExvb3BpbmRleD1Tb3VyY2VkYXRhVG9rZW5zLmluZGV4T2YoRmluZE5lc3RlZExvb3ApKzIKICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmVzdGVkTG9vcGxlbmd0aD0oU291cmNlZGF0YVRva2Vuc1tOZXN0ZWRMb29waW5kZXhdLkVuZEluZGV4LVNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5zdGFydEluZGV4KSsxCgogICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgeD1OZXN0ZWRMb29waW5kZXg7eDxOZXN0ZWRMb29waW5kZXgrTmVzdGVkTG9vcGxlbmd0aDt4KyspCiAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zW3hdLmlzTmVzdGVkTG9vcD10cnVlCgogICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAKCgoKCiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5jbHVkZXMoJygnKSAmJiBlbGVtZW50LmluY2x1ZGVzKCcsJykpCiAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIEZsYWdQcmltYWxMb29wID0gMQoKCiAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ3ljbGU6ICcsIEN5Y2xlLEl0ZXJhdGlvblN0YXJ0KTsKCgogICAgICAgICAgICAgICAgICAgIC8vSXRlcmF0aW5nIG92ZXIgZm9ybG9vcCBzb3VyY2VkYXRhCiAgICAgICAgICAgICAgICAgICAgLy90aGlzIGxpbmUgJ2l0ZXJhdG9yIDw9IEN5Y2xlJyBkZXRlcm1pbmVzIHN0YXJ0IG9mIHRoZSBsb29wIGFuZCB0aGUgZHVyYXRpb24gb2YgdGhlIGxvb3AKCiAgICAgICAgICAgICAgICAgICAgZm9yIChpdGVyYXRvciA9IEl0ZXJhdGlvblN0YXJ0OyBpdGVyYXRvciA8PSBDeWNsZTsgaXRlcmF0b3IrKykgewogICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9ybG9vcGluZGV4ID0gQ29tcGxldGVUb2tlblZhbHVlTGlzdC5maW5kKGVsID0+IGVsLm5hbWUgPT0gT3JpZ2luYWxJdGVyYXRvcikKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIAoKCgogICAgICAgICAgICAgICAgICAgICAgICBmb3Jsb29waW5kZXgudmFsdWUgPSBpdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnQ29tcGxldGVUb2tlblZhbHVlTGlzdDogJywgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7CgogICAgICAgICAgICAgICAgICAgICAgICAvL2ZsYWcgdG8gYXZvaWQgcnVubmluZyB0aGlzIGNvZGUgaWYgbG9vcCBpcyBwcmltYWwgYmVjYXVzZSB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBjb21wZWx0ZWx5IGRpZmZlcmVudAogICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmxhZ1ByaW1hbExvb3AgPSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3JMb29wQXJyYXlvclN0cmluZ091dHB1dChlbGVtZW50VmFsdWUsIGl0ZXJhdG9yLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCB0aGlzKQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgU291cmNlZGF0YVRva2Vucy5sZW5ndGg7IGkrKykKCgogICAgICAgICAgICAgICAgICAgICAgICB7CgoKbGV0IGlzTmVzdGVkPVNvdXJjZWRhdGFUb2tlbnNbaV0uaXNOZXN0ZWRMb29wCgoKCgppZiAoU291cmNlZGF0YVRva2Vuc1tpXS50eXBlID09ICdGb3JMb29wU3RhcnQnKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkRmxhZ1ByaW1hbExvb3AgPSAwCiAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICB2YXIgTmVzdGVkU291cmNlZGF0YVRva2VucyA9IFtdICAgICAgCgogICAgICAgICAgICAgICAgICAgIGxldCBOZXN0ZWRGb3JMb29wTWV0YURhdGE9IEZvckxvb3BTZXRNZXRhZGF0YShTb3VyY2VkYXRhVG9rZW5zLGksQ29tcGxldGVUb2tlblZhbHVlTGlzdCkKICAgICAKICAgLy8gIGNvbnNvbGUubG9nKCdOZXN0ZWRGb3JMb29wTWV0YURhdGE6ICcsIE5lc3RlZEZvckxvb3BNZXRhRGF0YSk7Cgp2YXIgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0PU5lc3RlZEZvckxvb3BNZXRhRGF0YS5Gb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQKdmFyIE5lc3RlZEN5Y2xlPU5lc3RlZEZvckxvb3BNZXRhRGF0YS5DeWNsZSsxCnZhciBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yPU5lc3RlZEZvckxvb3BNZXRhRGF0YS5PcmlnaW5hbEl0ZXJhdG9yCnZhciBOZXN0ZWRJdGVyYXRpb25TdGFydD1OZXN0ZWRGb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQKdmFyIE5lc3RlZGl0ZXJhdG9yPU5lc3RlZEZvckxvb3BNZXRhRGF0YS5pdGVyYXRvcgp2YXIgTmVzdGVkZWxlbWVudD1OZXN0ZWRGb3JMb29wTWV0YURhdGEuZWxlbWVudAp2YXIgTmVzdGVkZWxlbWVudFZhbHVlPU5lc3RlZEZvckxvb3BNZXRhRGF0YS5lbGVtZW50VmFsdWUKCiAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdGFydEluZGV4LCBTb3VyY2VkYXRhVG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQ6ICcsIHN0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCk7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhTb3VyY2VkYXRhVG9rZW5zLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCkKICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBSZXR1cm52YWx1ZS5TdG9yZVJlc3VsdAoKCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdAoKCiAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChTb3VyY2VkYXRhVG9rZW5zLCBpLCAneycsIE5lc3RlZEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCkKICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQ6ICcsIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgTmVzdGVkU291cmNlZGF0YVRva2VucyA9IGdldFNvdXJjZWRhdGEoTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBTb3VyY2VkYXRhVG9rZW5zLCAnfScsIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMpCiAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zOiAnLCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zKTsKICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgCiBmb3IgKE5lc3RlZGl0ZXJhdG9yID0gMDsgTmVzdGVkaXRlcmF0b3IgPE5lc3RlZEN5Y2xlOyBOZXN0ZWRpdGVyYXRvcisrKSB7CnsKCmxldCB5ID0gTmVzdGVkaXRlcmF0b3IKCgpsZXQgTmVzdGVkZm9ybG9vcGluZGV4ID0gQ29tcGxldGVUb2tlblZhbHVlTGlzdC5maW5kKGVsID0+IGVsLm5hbWUgPT0gTmVzdGVkT3JpZ2luYWxJdGVyYXRvcikKICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZm9ybG9vcGluZGV4OiAnLCBmb3Jsb29waW5kZXgpOwoKCgogICAgICAgICAgICAgICAgICAgICAgICBOZXN0ZWRmb3Jsb29waW5kZXgudmFsdWUgPSB5CgoKZm9yKGxldCBpbmRleD0wO2luZGV4PE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoO2luZGV4KyspCnsKCgpsZXQgZWw9IE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdCgppZihlbC52YWx1ZT09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKQoKewoKCgpJZlRva2VuUHJpbnQoTmVzdGVkU291cmNlZGF0YVRva2VucyxDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpbmRleCwgdGhpcywgeSwgTmVzdGVkT3JpZ2luYWxJdGVyYXRvcikKCgp9CgogZWxzZSBpZiAoZWwudmFsdWUgPT0gJz0nICYmIGVsLmlzTmVzdGVkTG9vcD09dHJ1ZSkgewogICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCBpbmRleCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgeSwgTmVzdGVkT3JpZ2luYWxJdGVyYXRvcikKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgIGlmIChlbC50eXBlID09ICdjb25kaXRpb24nICYmIGVsLmlzTmVzdGVkTG9vcD09dHJ1ZSkKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2Vuc1tpXTogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IENvbmRpdGlvblN0YXJ0SW5kZXggPSBpbmRleAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4XS52YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlQ29uZGl0aW9ucyBldmFsdWF0ZXMgY29uZGl0aW9uIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mIGZyb20gd2hlcmUgcHJpbnRpbmcgc2hvdWxkIHJlc3VtZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb2YgaSBkZXBlbmRzIG9uIHRoZSBjb25kaXRpb25zCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24uaW5jbHVkZXMoJ3x8JykgfHwgY29uZGl0aW9uLmluY2x1ZGVzKCcmJicpKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoY29uZGl0aW9uLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpbmRleCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBmYWxzZSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJsb2NrTGVuZ3RoID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJsb2NrU3RhcnQgPSAwCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnNbaW5kZXhdLnZhbHVlICE9ICd7JykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4ICsgMV0udmFsdWUgPT0gJ3snKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQmxvY2tMZW5ndGggPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4ICsgMV0uRW5kSW5kZXggLSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4ICsgMV0uc3RhcnRJbmRleAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBCbG9ja0xlbmd0aCArIGluZGV4ICsgMQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Ugewpjb25zb2xlLmxvZygnTmVzdGVkU291cmNlZGF0YVRva2VuczogJywgTmVzdGVkU291cmNlZGF0YVRva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2luZGV4IDogJywgaW5kZXggKTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeD0gSGFuZGxlQ29uZGl0aW9ucyhOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLCBpbmRleCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd4OiAnLCB4KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ICE9IHVuZGVmaW5lZCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IENvbmRpdGlvblN0YXJ0SW5kZXgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2k6ICcsIGkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2luZGV4IDogJywgaW5kZXggKTsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CgogICAgICAgICAgICAgICAgICAgLy8gaSA9IGkgKyBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aAogICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2k6ICcsIGkpOwoKCiBlbHNlICBpZiAoZWwudHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIiAmJiBlbC5pc05lc3RlZExvb3A9PXRydWUpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWUgPSBlbC52YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnM6ICcsIFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1ZhbHVlOiAnLCBWYWx1ZSxpKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlVG9TZXQgPSBlbC5WYWx1ZVRvU2V0CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gUmVtb3ZlQnJhY2tldHMoVmFsdWUpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQXJyYXlFbGVtZW50ID0gJycKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2VwcmF0aW5nIG91dCBpbmRleCBpZGVudGlmaWVyLiB4eXogZnJvbSBBcnJheVt4eXpdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnJlcGxhY2UoJ10nLCAnJykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBTcGxpdCA9IGVsZW1lbnQuc3BsaXQoJ1snKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBpZiB3ZSBuZWVkIHRvIHNldCBkaXJlY3QgQXJyYXkgZWxlbWVudCB2YWx1ZS4gbGlrZSBBcnJheVsyXT0geHl4ICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoU3BsaXRbMV0pKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTcGxpdCA9IFNwbGl0LmlvaW4oJ1snKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQgKyAnXScKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBTcGxpdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGluZGV4LCB1cGRhdGVkX3Rva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgZmFsc2UsIE5ld1ZhbHVlVG9TZXQsIHRva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBydW4gaWYgd2UgbmVlZCB0byBkeW5hbWljYWxseSBzZXQgQXJyYXkgZWxlbWVudCB2YWx1ZS4gbGlrZSBBcnJheVtpXT0geHl4CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9DcmVhdGVBcnJheUVsZW1lbnQgZnVuY3Rpb24gd2lsbCBjcmVhdGUgZHluYW1pYyBBcnJheSB2YWx1ZXMuIGxpa2UgQXJyYXlbMF0sIEFycmF5WzFdIGV0Yy4gICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IFNwbGl0WzFdCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZyBpdGVyYXRvciBhcyBwZXIgdXNlciBpbnB1dCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgaXRlcmF0b3IgbGlrZSBjb3VudD1jb3VudCArIDEsIEFycmF5W2NvdW50XQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0ludGVyYXRvciA9IDAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRva2VuID0gdXBkYXRlZF90b2tlbnMuZmluZChlbCA9PiBlbC5uYW1lID09IGluZGV4KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IHVuZGVmaW5lZCkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ludGVyYXRvciA9IHRva2VuLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ludGVyYXRvciA9IGl0ZXJhdG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KFZhbHVlLCBuZXdJbnRlcmF0b3IpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBpcyB3cml0dGVuIHRvIGZpbmQgb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPSBhKjEwMCthZ2UqYS4gbm90aWNlIGEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgYSB3YXkgdG8gc2ltcGxpZnkgdGhpcyBpbiBsb25nIHRlcm0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBWYWx1ZVRvU2V0CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnKicpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJysnKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCctJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLycpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJywnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RhdGE6ICcsIEFycmF5RWxlbWVudCwgZGF0YSwgU3BsaXQpOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2J1aWxkaW5nIGEgbmV3IHZhbHVlIHRvIGNvbnZlcnQgYSoxMDArYWdlKmEgaW50byA1KjEwMCthZ2UqYSBhbmQgdGhlbiBzZW5kaW5nIGl0IHRvIENhbGN1bGF0ZVZhbHVlcygpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IE5ld1ZhbHVlVG9TZXQgPSAnJwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmluY2x1ZGVzKFNwbGl0WzFdKSAmJiBkYXRhLmxlbmd0aCA+IDEpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGhhdmUgb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPSBhKjEwMCthZ2UqYS4gbm90aWNlIGEKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgVmFsdWVUb1NldC5sZW5ndGg7IG0rKykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmFsdWVUb1NldFttXSA9PSBTcGxpdFsxXSAmJiAhKC9eW2Etel0rJC9pLnRlc3QoVmFsdWVUb1NldFttICsgMV0pKSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgaXMgYmVlbiBzZXQgLiByZXBsYWNpbmcgaW5kZXggdmFsdWUgYSB3aXRoIGl0ZWFydG9yIHZhbHVlIDAsMSwyLCBldGMuICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IE5ld1ZhbHVlVG9TZXQgKyBpdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBOZXdWYWx1ZVRvU2V0ICsgVmFsdWVUb1NldFttXQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0ID0gZmFsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nYXZlIGl0IGEgZGlmZmVyZW50IG5hbWUgc28gaXQgd291bGQgbm90IGZ1Y2sgdXAgd2l0aCBmb3IgbG9vcCBpdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IENhbGN1bGF0ZVZhbHVlcyhOZXdWYWx1ZVRvU2V0LCBqLCB1cGRhdGVkX3Rva2VucywgKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXQsIE5ld1ZhbHVlVG9TZXQsIHRva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb25kaXRpb24gZW5hYmxlcyBwcm9ncmFtIHRvIG9ubHkgcnVuICBBcnJheVthXT0geHl6IHdoZW4gaXRlcmF0b3IgaXMgYS4gSXQgZGlzYWxsb3dzIHJ1bm5pbmcgQXJyYXlbYmxhYmxhYmxhXT14eXoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT3JpZ2luYWxJdGVyYXRvciA9PSBTcGxpdFsxXSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNwbGl0WzFdID09IFZhbHVlVG9TZXQpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gdHJ1ZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09YWdlb25lKjEwMAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5pbmNsdWRlcyhTcGxpdFsxXSkgJiYgT3JpZ2luYWxJdGVyYXRvciA9PSBTcGxpdFsxXSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGosIHVwZGF0ZWRfdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWlnaHQgaGF2ZSB0byBhZGQgbW9yZSBjb25kaXRpb25zIGluIHRoZSBmdXR1cmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IGZhbHNlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGosIHVwZGF0ZWRfdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCgoKCgp9CgoKCgoKCgp9CgoKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgp9CgoKCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZSA9PSAnPScgICYmIGlzTmVzdGVkPT1mYWxzZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhTb3VyY2VkYXRhVG9rZW5zLCBpLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0hhbmRsaW5nIHByaW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKCiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAgaWYgKFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUgPT0gJ+CkquCljeCksOCkv+CkguCknycgJiYgaXNOZXN0ZWQ9PWZhbHNlKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIG9wZXJhdGlvbnMgbGlrZSBwcmludChhcnJheVszXSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZvciBsb29vcCBwcmludHM6ICcsIGZ1bmN0aW9uU291cmNlRGF0YVtpXSxpKTsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmVG9rZW5QcmludChTb3VyY2VkYXRhVG9rZW5zLENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGksIHRoaXMsIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0hhbmRsaW5nIHNldCBhcnJheSBlbGVtZW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlICBpZiAoU291cmNlZGF0YVRva2Vuc1tpXS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlID0gU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnM6ICcsIFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1ZhbHVlOiAnLCBWYWx1ZSxpKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlVG9TZXQgPSBTb3VyY2VkYXRhVG9rZW5zW2ldLlZhbHVlVG9TZXQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBSZW1vdmVCcmFja2V0cyhWYWx1ZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBBcnJheUVsZW1lbnQgPSAnJwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TZXByYXRpbmcgb3V0IGluZGV4IGlkZW50aWZpZXIuIHh5eiBmcm9tIEFycmF5W3h5el0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmVwbGFjZSgnXScsICcnKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFNwbGl0ID0gZWxlbWVudC5zcGxpdCgnWycpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGlmIHdlIG5lZWQgdG8gc2V0IGRpcmVjdCBBcnJheSBlbGVtZW50IHZhbHVlLiBsaWtlIEFycmF5WzJdPSB4eXggICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihTcGxpdFsxXSkpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTcGxpdCA9IFNwbGl0ICsgJ10nCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gU3BsaXQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IENhbGN1bGF0ZVZhbHVlcyhWYWx1ZVRvU2V0LCBqLCB1cGRhdGVkX3Rva2VucywgKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBmYWxzZSwgTmV3VmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBpZiB3ZSBuZWVkIHRvIGR5bmFtaWNhbGx5IHNldCBBcnJheSBlbGVtZW50IHZhbHVlLiBsaWtlIEFycmF5W2ldPSB4eXgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0NyZWF0ZUFycmF5RWxlbWVudCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBkeW5hbWljIEFycmF5IHZhbHVlcy4gbGlrZSBBcnJheVswXSwgQXJyYXlbMV0gZXRjLiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gU3BsaXRbMV0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIGl0ZXJhdG9yIGFzIHBlciB1c2VyIGlucHV0IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvciBpdGVyYXRvciBsaWtlIGNvdW50PWNvdW50ICsgMSwgQXJyYXlbY291bnRdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SW50ZXJhdG9yID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsID0+IGVsLm5hbWUgPT0gaW5kZXgpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT0gdW5kZWZpbmVkKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhdG9yID0gdG9rZW4udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhdG9yID0gaXRlcmF0b3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBDcmVhdGVBcnJheUVsZW1lbnQoVmFsdWUsIG5ld0ludGVyYXRvcikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIGlzIHdyaXR0ZW4gdG8gZmluZCBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09IGEqMTAwK2FnZSphLiBub3RpY2UgYQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmluZCBhIHdheSB0byBzaW1wbGlmeSB0aGlzIGluIGxvbmcgdGVybQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFZhbHVlVG9TZXQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcqJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnKycpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJy0nKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcvJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGF0YTogJywgQXJyYXlFbGVtZW50LCBkYXRhLCBTcGxpdCk7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYnVpbGRpbmcgYSBuZXcgdmFsdWUgdG8gY29udmVydCBhKjEwMCthZ2UqYSBpbnRvIDUqMTAwK2FnZSphIGFuZCB0aGVuIHNlbmRpbmcgaXQgdG8gQ2FsY3VsYXRlVmFsdWVzKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmV3VmFsdWVUb1NldCA9ICcnCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaW5jbHVkZXMoU3BsaXRbMV0pICYmIGRhdGEubGVuZ3RoID4gMSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgaGF2ZSBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09IGEqMTAwK2FnZSphLiBub3RpY2UgYQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCBWYWx1ZVRvU2V0Lmxlbmd0aDsgbSsrKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWYWx1ZVRvU2V0W21dID09IFNwbGl0WzFdICYmICEoL15bYS16XSskL2kudGVzdChWYWx1ZVRvU2V0W20gKyAxXSkpKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpcyBiZWVuIHNldCAuIHJlcGxhY2luZyBpbmRleCB2YWx1ZSBhIHdpdGggaXRlYXJ0b3IgdmFsdWUgMCwxLDIsIGV0Yy4gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gTmV3VmFsdWVUb1NldCArIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IE5ld1ZhbHVlVG9TZXQgKyBWYWx1ZVRvU2V0W21dCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXQgPSBmYWxzZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dhdmUgaXQgYSBkaWZmZXJlbnQgbmFtZSBzbyBpdCB3b3VsZCBub3QgZnVjayB1cCB3aXRoIGZvciBsb29wIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKE5ld1ZhbHVlVG9TZXQsIGosIHVwZGF0ZWRfdG9rZW5zLCApCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGl0ZXJhdCwgTmV3VmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbmRpdGlvbiBlbmFibGVzIHByb2dyYW0gdG8gb25seSBydW4gIEFycmF5W2FdPSB4eXogd2hlbiBpdGVyYXRvciBpcyBhLiBJdCBkaXNhbGxvd3MgcnVubmluZyBBcnJheVtibGFibGFibGFdPXh5egogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPcmlnaW5hbEl0ZXJhdG9yID09IFNwbGl0WzFdKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU3BsaXRbMV0gPT0gVmFsdWVUb1NldCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSB0cnVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT1hZ2VvbmUqMTAwCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmluY2x1ZGVzKFNwbGl0WzFdKSAmJiBPcmlnaW5hbEl0ZXJhdG9yID09IFNwbGl0WzFdKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBmYWxzZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsdXBkYXRlZF90b2tlbnMsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9taWdodCBoYXZlIHRvIGFkZCBtb3JlIGNvbmRpdGlvbnMgaW4gdGhlIGZ1dHVyZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxpbmcgQ09ORElUSU9OQUwgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAoKICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlICBpZiAoU291cmNlZGF0YVRva2Vuc1tpXS50eXBlID09ICdjb25kaXRpb24nKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdTb3VyY2VkYXRhVG9rZW5zW2ldOiAnLCBTb3VyY2VkYXRhVG9rZW5zW2ldLGkpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uU3RhcnRJbmRleCA9IGkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uID0gU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlQ29uZGl0aW9ucyBldmFsdWF0ZXMgY29uZGl0aW9uIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mIGZyb20gd2hlcmUgcHJpbnRpbmcgc2hvdWxkIHJlc3VtZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb2YgaSBkZXBlbmRzIG9uIHRoZSBjb25kaXRpb25zCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24uaW5jbHVkZXMoJ3x8JykgfHwgY29uZGl0aW9uLmluY2x1ZGVzKCcmJicpKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoY29uZGl0aW9uLCB1cGRhdGVkX3Rva2VucywgaSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBmYWxzZSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJsb2NrTGVuZ3RoID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJsb2NrU3RhcnQgPSAwCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUgIT0gJ3snKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNvdXJjZWRhdGFUb2tlbnNbaSArIDFdLnZhbHVlID09ICd7JykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJsb2NrTGVuZ3RoID0gU291cmNlZGF0YVRva2Vuc1tpICsgMV0uRW5kSW5kZXggLSBTb3VyY2VkYXRhVG9rZW5zW2kgKyAxXS5zdGFydEluZGV4CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gQmxvY2tMZW5ndGggKyBpICsgMQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKysKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBIYW5kbGVDb25kaXRpb25zKFNvdXJjZWRhdGFUb2tlbnMsIGksIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpOwoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSB1bmRlZmluZWQpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IENvbmRpdGlvblN0YXJ0SW5kZXgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2k6ICcsIGkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqOiAnLCBqKTsKCiAgICAgICAgICAgICAgICAgICAgaSA9IGkgKyBTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aAogICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2o6ICcsIGopOwoKCiAgICAgICAgICAgICAgICB9CgoKCgoKCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAgaWYgKGZ1bmN0aW9uU291cmNlRGF0YVtpXS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlID0gZnVuY3Rpb25Tb3VyY2VEYXRhW2ldLnZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2VuczogJywgU291cmNlZGF0YVRva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmFsdWU6ICcsIFZhbHVlLGkpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWVUb1NldCA9IGZ1bmN0aW9uU291cmNlRGF0YVtpXS5WYWx1ZVRvU2V0CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gUmVtb3ZlQnJhY2tldHMoVmFsdWUpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQXJyYXlFbGVtZW50ID0gJycKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2VwcmF0aW5nIG91dCBpbmRleCBpZGVudGlmaWVyLiB4eXogZnJvbSBBcnJheVt4eXpdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnJlcGxhY2UoJ10nLCAnJykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBTcGxpdCA9IGVsZW1lbnQuc3BsaXQoJ1snKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBpZiB3ZSBuZWVkIHRvIHNldCBkaXJlY3QgQXJyYXkgZWxlbWVudCB2YWx1ZS4gbGlrZSBBcnJheVsyXT0geHl4ICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoU3BsaXRbMV0pKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTcGxpdCA9IFNwbGl0LmpvaW4oJ1snKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdCArICddJwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5RWxlbWVudCA9IFNwbGl0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaSwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGZhbHNlLCBOZXdWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGlmIHdlIG5lZWQgdG8gZHluYW1pY2FsbHkgc2V0IEFycmF5IGVsZW1lbnQgdmFsdWUuIGxpa2UgQXJyYXlbaV09IHh5eAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ3JlYXRlQXJyYXlFbGVtZW50IGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGR5bmFtaWMgQXJyYXkgdmFsdWVzLiBsaWtlIEFycmF5WzBdLCBBcnJheVsxXSBldGMuICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBTcGxpdFsxXQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgaXRlcmF0b3IgYXMgcGVyIHVzZXIgaW5wdXQgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIGl0ZXJhdG9yIGxpa2UgY291bnQ9Y291bnQgKyAxLCBBcnJheVtjb3VudF0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdJbnRlcmF0b3IgPSAwCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QuZmluZChlbCA9PiBlbC5uYW1lID09IGluZGV4KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IHVuZGVmaW5lZCkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ludGVyYXRvciA9IHRva2VuLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ludGVyYXRvciA9IGl0ZXJhdG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KFZhbHVlLCBuZXdJbnRlcmF0b3IpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBcnJheUVsZW1lbnQ6ICcsIEFycmF5RWxlbWVudCk7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBpcyB3cml0dGVuIHRvIGZpbmQgb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPSBhKjEwMCthZ2UqYS4gbm90aWNlIGEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgYSB3YXkgdG8gc2ltcGxpZnkgdGhpcyBpbiBsb25nIHRlcm0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBWYWx1ZVRvU2V0CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnKicpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJysnKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCctJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLycpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJywnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RhdGE6ICcsIEFycmF5RWxlbWVudCwgZGF0YSwgU3BsaXQpOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2J1aWxkaW5nIGEgbmV3IHZhbHVlIHRvIGNvbnZlcnQgYSoxMDArYWdlKmEgaW50byA1KjEwMCthZ2UqYSBhbmQgdGhlbiBzZW5kaW5nIGl0IHRvIENhbGN1bGF0ZVZhbHVlcygpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IE5ld1ZhbHVlVG9TZXQgPSAnJwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmluY2x1ZGVzKFNwbGl0WzFdKSAmJiBkYXRhLmxlbmd0aCA+IDEpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGhhdmUgb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPSBhKjEwMCthZ2UqYS4gbm90aWNlIGEKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgVmFsdWVUb1NldC5sZW5ndGg7IG0rKykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmFsdWVUb1NldFttXSA9PSBTcGxpdFsxXSAmJiAhKC9eW2Etel0rJC9pLnRlc3QoVmFsdWVUb1NldFttICsgMV0pKSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgaXMgYmVlbiBzZXQgLiByZXBsYWNpbmcgaW5kZXggdmFsdWUgYSB3aXRoIGl0ZWFydG9yIHZhbHVlIDAsMSwyLCBldGMuICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IE5ld1ZhbHVlVG9TZXQgKyBpdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBOZXdWYWx1ZVRvU2V0ICsgVmFsdWVUb1NldFttXQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0ID0gZmFsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nYXZlIGl0IGEgZGlmZmVyZW50IG5hbWUgc28gaXQgd291bGQgbm90IGZ1Y2sgdXAgd2l0aCBmb3IgbG9vcCBpdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IENhbGN1bGF0ZVZhbHVlcyhOZXdWYWx1ZVRvU2V0LCBpLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCApCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaXRlcmF0LCBOZXdWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29uZGl0aW9uIGVuYWJsZXMgcHJvZ3JhbSB0byBvbmx5IHJ1biAgQXJyYXlbYV09IHh5eiB3aGVuIGl0ZXJhdG9yIGlzIGEuIEl0IGRpc2FsbG93cyBydW5uaW5nIEFycmF5W2JsYWJsYWJsYV09eHl6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9yaWdpbmFsSXRlcmF0b3IgPT0gU3BsaXRbMV0pIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTcGxpdFsxXSA9PSBWYWx1ZVRvU2V0KSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IHRydWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09YWdlb25lKjEwMAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5pbmNsdWRlcyhTcGxpdFsxXSkgJiYgT3JpZ2luYWxJdGVyYXRvciA9PSBTcGxpdFsxXSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGksIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCxDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWlnaHQgaGF2ZSB0byBhZGQgbW9yZSBjb25kaXRpb25zIGluIHRoZSBmdXR1cmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IGZhbHNlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGksIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgoKCiBlbHNlIGlmIChmdW5jdGlvblNvdXJjZURhdGFbaV0udHlwZSA9PSAnV2hpbGVMb29wU3RhcnQnKSB7CiAgICAgY29uc29sZS5sb2coJ2Z1bmN0aW9uU291cmNlRGF0YTogJywgZnVuY3Rpb25Tb3VyY2VEYXRhKTsKCgogICAgICAgICAgICAgICAgICAgIGxldCBUb2tlbnNDdXJyZW50SW5kZXggPSBpICsgMwoKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgbGV0IENvbmRpdGlvblZhbHVlID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBmdW5jdGlvblNvdXJjZURhdGFbaSArIDFdLnZhbHVlCgogICAgICAgICAgICAgICAgICAgIGxldCBFeHRyYXRjZWRWYXJpYWJsZSA9IFtdCgogICAgICAgICAgICAgICAgICAgIGxldCB2YXJpYWJsZSA9ICcnCiAgICAgICAgICAgICAgICAgICAgbGV0IFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gMAogICAgICAgICAgICAgICAgICAgIGxldCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gW10KCgoKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBlbGVtZW50LmNoYXJBdChpKQoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKHgpKQoKICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUgKyB4CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhcmlhYmxlKGVsZW1lbnQuY2hhckF0KGkgKyAxKSkgJiYgaXNWYXJpYWJsZSh4KSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QuZmluZChlbCA9PiBlbC5uYW1lID09IHZhcmlhYmxlKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4dHJhdGNlZFZhcmlhYmxlLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlOiB2YXJpYWJsZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9ICcnCgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFdoaWxlTG9vcFNvdXJjZWRhdGEoc3RhcnRJbmRleCwgZnVuY3Rpb25Tb3VyY2VEYXRhLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBIYW5kbGVCbG9ja3MoZnVuY3Rpb25Tb3VyY2VEYXRhLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCkKCgoKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0CgoKCgogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChmdW5jdGlvblNvdXJjZURhdGEsIGksICd7JywgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQpCiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1doaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0OiAnLCBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCk7CiAgICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gZ2V0V2hpbGVMb29wU291cmNlZGF0YShXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCwgZnVuY3Rpb25Tb3VyY2VEYXRhLCAnfScsIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMpLlN0b3JlUmVzdWx0CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1doaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnM6ICcsIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoKTsKCgoKCiAgICAgICAgICAgICAgICAgICAgLy9jb25zdGFudGx5IGFjY2Vzc2luZyB0aGUgY29uZGl0aW9udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKEdldENvbmRpdGlvblZhbHVlKGVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGogKyAxKSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU0VDVElPTiB3aGlsZSBsb29wIGNvbnRleHQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZSA9PSAnPScpIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoV2hpbGVMb29wU291cmNlZGF0YVRva2VucywgaSwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsaW5nIENPTkRJVElPTkFMIHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udHlwZSA9PSAnY29uZGl0aW9uJykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4PSBIYW5kbGVDb25kaXRpb25zKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIGksIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXghPXVuZGVmaW5lZCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Cmk9aW5kZXgKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpPWkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIAoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUgPT0gJ+CkquCljeCksOCkv+CkguCknycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQoV2hpbGVMb29wU291cmNlZGF0YVRva2VucyxDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpLCB0aGlzKSAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSAgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udHlwZSA9PSAiU2V0QXJyYXlJbmRleFZhbHVlIikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBWYWx1ZSA9IFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdTb3VyY2VkYXRhVG9rZW5zOiAnLCBTb3VyY2VkYXRhVG9rZW5zKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdWYWx1ZTogJywgVmFsdWUsaSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBWYWx1ZVRvU2V0ID0gV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS5WYWx1ZVRvU2V0CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gUmVtb3ZlQnJhY2tldHMoVmFsdWUpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQXJyYXlFbGVtZW50ID0gJycKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2VwcmF0aW5nIG91dCBpbmRleCBpZGVudGlmaWVyLiB4eXogZnJvbSBBcnJheVt4eXpdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnJlcGxhY2UoJ10nLCAnJykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBTcGxpdCA9IGVsZW1lbnQuc3BsaXQoJ1snKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBpZiB3ZSBuZWVkIHRvIHNldCBkaXJlY3QgQXJyYXkgZWxlbWVudCB2YWx1ZS4gbGlrZSBBcnJheVsyXT0geHl4ICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoU3BsaXRbMV0pKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTcGxpdCA9IFNwbGl0LmpvaW4oJ1snKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdCArICddJwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5RWxlbWVudCA9IFNwbGl0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaSwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGZhbHNlLCBOZXdWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGlmIHdlIG5lZWQgdG8gZHluYW1pY2FsbHkgc2V0IEFycmF5IGVsZW1lbnQgdmFsdWUuIGxpa2UgQXJyYXlbaV09IHh5eAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ3JlYXRlQXJyYXlFbGVtZW50IGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGR5bmFtaWMgQXJyYXkgdmFsdWVzLiBsaWtlIEFycmF5WzBdLCBBcnJheVsxXSBldGMuICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBTcGxpdFsxXQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgaXRlcmF0b3IgYXMgcGVyIHVzZXIgaW5wdXQgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIGl0ZXJhdG9yIGxpa2UgY291bnQ9Y291bnQgKyAxLCBBcnJheVtjb3VudF0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdJbnRlcmF0b3IgPSAwCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QuZmluZChlbCA9PiBlbC5uYW1lID09IGluZGV4KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9IHVuZGVmaW5lZCkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ludGVyYXRvciA9IHRva2VuLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ludGVyYXRvciA9IGl0ZXJhdG9yCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KFZhbHVlLCBuZXdJbnRlcmF0b3IpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBcnJheUVsZW1lbnQ6ICcsIEFycmF5RWxlbWVudCk7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBpcyB3cml0dGVuIHRvIGZpbmQgb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPSBhKjEwMCthZ2UqYS4gbm90aWNlIGEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgYSB3YXkgdG8gc2ltcGxpZnkgdGhpcyBpbiBsb25nIHRlcm0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBWYWx1ZVRvU2V0CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnKicpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJysnKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCctJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLycpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJywnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RhdGE6ICcsIEFycmF5RWxlbWVudCwgZGF0YSwgU3BsaXQpOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2J1aWxkaW5nIGEgbmV3IHZhbHVlIHRvIGNvbnZlcnQgYSoxMDArYWdlKmEgaW50byA1KjEwMCthZ2UqYSBhbmQgdGhlbiBzZW5kaW5nIGl0IHRvIENhbGN1bGF0ZVZhbHVlcygpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IE5ld1ZhbHVlVG9TZXQgPSAnJwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmluY2x1ZGVzKFNwbGl0WzFdKSAmJiBkYXRhLmxlbmd0aCA+IDEpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGhhdmUgb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPSBhKjEwMCthZ2UqYS4gbm90aWNlIGEKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG0gPSAwOyBtIDwgVmFsdWVUb1NldC5sZW5ndGg7IG0rKykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmFsdWVUb1NldFttXSA9PSBTcGxpdFsxXSAmJiAhKC9eW2Etel0rJC9pLnRlc3QoVmFsdWVUb1NldFttICsgMV0pKSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgaXMgYmVlbiBzZXQgLiByZXBsYWNpbmcgaW5kZXggdmFsdWUgYSB3aXRoIGl0ZWFydG9yIHZhbHVlIDAsMSwyLCBldGMuICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IE5ld1ZhbHVlVG9TZXQgKyBpdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBOZXdWYWx1ZVRvU2V0ICsgVmFsdWVUb1NldFttXQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0ID0gZmFsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9nYXZlIGl0IGEgZGlmZmVyZW50IG5hbWUgc28gaXQgd291bGQgbm90IGZ1Y2sgdXAgd2l0aCBmb3IgbG9vcCBpdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IENhbGN1bGF0ZVZhbHVlcyhOZXdWYWx1ZVRvU2V0LCBpLCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCApCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgQ29tcGxldGVUb2tlblZhbHVlTGlzdCwgaXRlcmF0LCBOZXdWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29uZGl0aW9uIGVuYWJsZXMgcHJvZ3JhbSB0byBvbmx5IHJ1biAgQXJyYXlbYV09IHh5eiB3aGVuIGl0ZXJhdG9yIGlzIGEuIEl0IGRpc2FsbG93cyBydW5uaW5nIEFycmF5W2JsYWJsYWJsYV09eHl6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9yaWdpbmFsSXRlcmF0b3IgPT0gU3BsaXRbMV0pIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTcGxpdFsxXSA9PSBWYWx1ZVRvU2V0KSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IHRydWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09YWdlb25lKjEwMAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5pbmNsdWRlcyhTcGxpdFsxXSkgJiYgT3JpZ2luYWxJdGVyYXRvciA9PSBTcGxpdFsxXSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGksIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCBDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCxDb21wbGV0ZVRva2VuVmFsdWVMaXN0LCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbWlnaHQgaGF2ZSB0byBhZGQgbW9yZSBjb25kaXRpb25zIGluIHRoZSBmdXR1cmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IGZhbHNlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGksIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIENvbXBsZXRlVG9rZW5WYWx1ZUxpc3QsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICBpPWkrMStXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aCsxCiAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnajogJywgaSk7CiAgICAgICAgICAgICAgICB9CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgp9CgoKCgoKICB9ICAgICAgICAgICAgICAgICAgICAgCgoKLy9za2lwcGluZyBwYXJzaW5nIGluZGV4IHNvIHRoYXQgZnVuY3Rpb24gY29udGV4dCBpcyBydW4gYnkgc2luZ2xlIGVudGl0eSBhbmQgZ2xvYmFsIGV4ZWN1dGlvbiBkb2Vzbid0IHJ1biB0aGlzIGNvZGUgdG9vCiAgICBqPW11dGFibGVfdG9rZW5zW2orMV0uRW5kSW5kZXgKCgoKCgp9CgogICAgICAgICAgICAgIGVsc2UgIGlmICh0b2tlblR5cGUgPT0gJ2NvbmRpdGlvbicpCgogICAgICAgICAgICAgICAgewoKCgoKICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlCgogICAgICAgICAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBjYWxjdWxhdGUgdmFsdWUgb2Ygb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCgogICAgICAgICAgICAgICAgICAgIGxldCBDb25kaXRpb25WYWx1ZSA9IEdldENvbmRpdGlvblZhbHVlKGVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBqKQogICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDb25kaXRpb25WYWx1ZTogJywgQ29uZGl0aW9uVmFsdWUpOwogICAgICAgICAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZygnajogJyxqKTsKCgoKCiAgICAgICAgICAgICAgICAgICAgLy9pZiB2YWx1ZSBpcyBmYWxzZSwganVzdCBza2lwIHRoZSBpZiBsb29wIGNvbnRleHQsIGlmIG5vdCBpdCB3aWxsIGJlIHJhbiBpbiBmaW5hbCBwcmludCBtb2R1bGUKCiAgICAgICAgICAgICAgICAgICAgaWYgKENvbmRpdGlvblZhbHVlID09IGZhbHNlKSB7CgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgSW5pdGlhbGl6ZUxvb3AgPSB0b2tlbnMuaW5kZXhPZihtdXRhYmxlX3Rva2Vuc1tqXSkKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlIEJsb2NrcyBpcyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGNhcmUgb2YgbmVzdGVkIGJsb2NrIGJ5IHRha2luZyBjYXJlIG9mIG5lc3RlZCB7IGFuZCB9IGJyYWNrZXRzCiAgICAgICAgICAgICAgICAgICAgICAgIC8vaXQgdXNlcyB0aGUgc3RhY2sgdG8gcHVzaCBhbmQgcG9wIGJyYWNrZXRzIHRvIGFjY3VyYXRlbHkgaWRlbnRpZnkgc3RhcnQgYW5kIHRoZSBlbmQgb2YgdGhlIGJsb2NrCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhtdXRhYmxlX3Rva2VucywgaikKCiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBSZXR1cm52YWx1ZS5qCiAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKQoKCiAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25vcm1hbCBwcmludHMnLCBtdXRhYmxlX3Rva2Vuc1tqKzFdKTsKICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQobXV0YWJsZV90b2tlbnMsdXBkYXRlZF90b2tlbnMsIGosIHRoaXMpIC8vZm9yIG9wZXJhdGlvbnMgbGlrZSBwcmludChhcnJheVszXSkKCgoKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlblR5cGUgPT0gJ1doaWxlTG9vcFN0YXJ0JykgewoKCiAgICAgICAgICAgICAgICAgICAgbGV0IFRva2Vuc0N1cnJlbnRJbmRleCA9IGogKyAzCgogICAgICAgICAgICAgICAgICAgIGxldCBDb25kaXRpb25WYWx1ZSA9IGZhbHNlCgogICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlCgogICAgICAgICAgICAgICAgICAgIGxldCBFeHRyYXRjZWRWYXJpYWJsZSA9IFtdCgogICAgICAgICAgICAgICAgICAgIGxldCB2YXJpYWJsZSA9ICcnCiAgICAgICAgICAgICAgICAgICAgbGV0IFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gMAogICAgICAgICAgICAgICAgICAgIGxldCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zID0gW10KCgoKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBlbGVtZW50LmNoYXJBdChpKQoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKHgpKQoKICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gdmFyaWFibGUgKyB4CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhcmlhYmxlKGVsZW1lbnQuY2hhckF0KGkgKyAxKSkgJiYgaXNWYXJpYWJsZSh4KSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZWwgPT4gZWwubmFtZSA9PSB2YXJpYWJsZSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBFeHRyYXRjZWRWYXJpYWJsZS5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZTogdmFyaWFibGUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRva2VuLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGUgPSAnJwoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KQoKCgogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RvcmVSZXN1bHQKCgoKCiAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KQogICAgICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAgICAgV2hpbGVMb29wU291cmNlZGF0YVRva2VucyA9IGdldFdoaWxlTG9vcFNvdXJjZWRhdGEoV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQsIG11dGFibGVfdG9rZW5zLCAnfScsIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMpLlN0b3JlUmVzdWx0CgoKCgogICAgICAgICAgICAgICAgICAgIC8vY29uc3RhbnRseSBhY2Nlc3NpbmcgdGhlIGNvbmRpdGlvbnZhbHVlCgogICAgICAgICAgICAgICAgICAgIHdoaWxlIChHZXRDb25kaXRpb25WYWx1ZShlbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaiArIDEpKSB7CgogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TRUNUSU9OIHdoaWxlIGxvb3AgY29udGV4dAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlID09ICc9JykgewoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLCBpLCB1cGRhdGVkX3Rva2VucykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsaW5nIENPTkRJVElPTkFMIHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udHlwZSA9PSAnY29uZGl0aW9uJykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4PSBIYW5kbGVDb25kaXRpb25zKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsIGksIHVwZGF0ZWRfdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2luZGV4OiAnLCBpbmRleCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXghPXVuZGVmaW5lZCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Cmk9aW5kZXgKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaT1pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKQogICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgIAoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWZUb2tlblByaW50KFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsdXBkYXRlZF90b2tlbnMsIGksIHRoaXMpIC8vZm9yIG9wZXJhdGlvbnMgbGlrZSBwcmludChhcnJheVszXSkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlICBpZiAoV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlID0gV2hpbGVMb29wU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnM6ICcsIFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1ZhbHVlOiAnLCBWYWx1ZSxpKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFZhbHVlVG9TZXQgPSBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW2ldLlZhbHVlVG9TZXQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBSZW1vdmVCcmFja2V0cyhWYWx1ZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBBcnJheUVsZW1lbnQgPSAnJwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TZXByYXRpbmcgb3V0IGluZGV4IGlkZW50aWZpZXIuIHh5eiBmcm9tIEFycmF5W3h5el0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmVwbGFjZSgnXScsICcnKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFNwbGl0ID0gZWxlbWVudC5zcGxpdCgnWycpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGlmIHdlIG5lZWQgdG8gc2V0IGRpcmVjdCBBcnJheSBlbGVtZW50IHZhbHVlLiBsaWtlIEFycmF5WzJdPSB4eXggICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihTcGxpdFsxXSkpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTcGxpdCA9IFNwbGl0ICsgJ10nCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gU3BsaXQKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IENhbGN1bGF0ZVZhbHVlcyhWYWx1ZVRvU2V0LCBqLCB1cGRhdGVkX3Rva2VucywgKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBmYWxzZSwgTmV3VmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBpZiB3ZSBuZWVkIHRvIGR5bmFtaWNhbGx5IHNldCBBcnJheSBlbGVtZW50IHZhbHVlLiBsaWtlIEFycmF5W2ldPSB4eXgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0NyZWF0ZUFycmF5RWxlbWVudCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBkeW5hbWljIEFycmF5IHZhbHVlcy4gbGlrZSBBcnJheVswXSwgQXJyYXlbMV0gZXRjLiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gU3BsaXRbMV0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIGl0ZXJhdG9yIGFzIHBlciB1c2VyIGlucHV0IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvciBpdGVyYXRvciBsaWtlIGNvdW50PWNvdW50ICsgMSwgQXJyYXlbY291bnRdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SW50ZXJhdG9yID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsID0+IGVsLm5hbWUgPT0gaW5kZXgpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT0gdW5kZWZpbmVkKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhdG9yID0gdG9rZW4udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhdG9yID0gaXRlcmF0b3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBDcmVhdGVBcnJheUVsZW1lbnQoVmFsdWUsIG5ld0ludGVyYXRvcikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FycmF5RWxlbWVudDogJywgQXJyYXlFbGVtZW50KTsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIGlzIHdyaXR0ZW4gdG8gZmluZCBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09IGEqMTAwK2FnZSphLiBub3RpY2UgYQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmluZCBhIHdheSB0byBzaW1wbGlmeSB0aGlzIGluIGxvbmcgdGVybQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFZhbHVlVG9TZXQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcqJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnKycpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJy0nKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcvJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGF0YTogJywgQXJyYXlFbGVtZW50LCBkYXRhLCBTcGxpdCk7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYnVpbGRpbmcgYSBuZXcgdmFsdWUgdG8gY29udmVydCBhKjEwMCthZ2UqYSBpbnRvIDUqMTAwK2FnZSphIGFuZCB0aGVuIHNlbmRpbmcgaXQgdG8gQ2FsY3VsYXRlVmFsdWVzKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmV3VmFsdWVUb1NldCA9ICcnCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaW5jbHVkZXMoU3BsaXRbMV0pICYmIGRhdGEubGVuZ3RoID4gMSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgaGF2ZSBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09IGEqMTAwK2FnZSphLiBub3RpY2UgYQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCBWYWx1ZVRvU2V0Lmxlbmd0aDsgbSsrKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWYWx1ZVRvU2V0W21dID09IFNwbGl0WzFdICYmICEoL15bYS16XSskL2kudGVzdChWYWx1ZVRvU2V0W20gKyAxXSkpKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpcyBiZWVuIHNldCAuIHJlcGxhY2luZyBpbmRleCB2YWx1ZSBhIHdpdGggaXRlYXJ0b3IgdmFsdWUgMCwxLDIsIGV0Yy4gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gTmV3VmFsdWVUb1NldCArIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IE5ld1ZhbHVlVG9TZXQgKyBWYWx1ZVRvU2V0W21dCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXQgPSBmYWxzZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dhdmUgaXQgYSBkaWZmZXJlbnQgbmFtZSBzbyBpdCB3b3VsZCBub3QgZnVjayB1cCB3aXRoIGZvciBsb29wIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKE5ld1ZhbHVlVG9TZXQsIGosIHVwZGF0ZWRfdG9rZW5zLCApCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGl0ZXJhdCwgTmV3VmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbmRpdGlvbiBlbmFibGVzIHByb2dyYW0gdG8gb25seSBydW4gIEFycmF5W2FdPSB4eXogd2hlbiBpdGVyYXRvciBpcyBhLiBJdCBkaXNhbGxvd3MgcnVubmluZyBBcnJheVtibGFibGFibGFdPXh5egogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPcmlnaW5hbEl0ZXJhdG9yID09IFNwbGl0WzFdKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU3BsaXRbMV0gPT0gVmFsdWVUb1NldCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSB0cnVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT1hZ2VvbmUqMTAwCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmluY2x1ZGVzKFNwbGl0WzFdKSAmJiBPcmlnaW5hbEl0ZXJhdG9yID09IFNwbGl0WzFdKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBmYWxzZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsdXBkYXRlZF90b2tlbnMsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9taWdodCBoYXZlIHRvIGFkZCBtb3JlIGNvbmRpdGlvbnMgaW4gdGhlIGZ1dHVyZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgIGVsc2UgIGlmICh0b2tlblR5cGUgPT0gJ0Zvckxvb3BTdGFydCcpCgoKCiAgICAgICAgICAgICAgICB7CgogIHZhciBGbGFnUHJpbWFsTG9vcCA9IDAKICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIHZhciBTb3VyY2VkYXRhVG9rZW5zID0gW10KCiAgICAgCi8vY29uc29sZS5sb2coJ3VwZGF0ZWRfdG9rZW5zOiAnLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgIGxldCBGb3JMb29wTWV0YURhdGE9IEZvckxvb3BTZXRNZXRhZGF0YShtdXRhYmxlX3Rva2VucyxqLHVwZGF0ZWRfdG9rZW5zKQogICAgIAogICAgIC8vY29uc29sZS5sb2coJ0Zvckxvb3BNZXRhRGF0YTogJywgRm9yTG9vcE1ldGFEYXRhKTsKCnZhciBGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQ9Rm9yTG9vcE1ldGFEYXRhLkZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydAp2YXIgQ3ljbGU9Rm9yTG9vcE1ldGFEYXRhLkN5Y2xlCnZhciBPcmlnaW5hbEl0ZXJhdG9yPUZvckxvb3BNZXRhRGF0YS5PcmlnaW5hbEl0ZXJhdG9yCnZhciBJdGVyYXRpb25TdGFydD1Gb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQKdmFyIGl0ZXJhdG9yPUZvckxvb3BNZXRhRGF0YS5pdGVyYXRvcgp2YXIgZWxlbWVudD1Gb3JMb29wTWV0YURhdGEuZWxlbWVudAp2YXIgZWxlbWVudFZhbHVlPUZvckxvb3BNZXRhRGF0YS5lbGVtZW50VmFsdWUKCiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U291cmNlZGF0YShzdGFydEluZGV4LCBtdXRhYmxlX3Rva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3N0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQ6ICcsIHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpOwoKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgUmV0dXJudmFsdWUgPSBIYW5kbGVCbG9ja3MobXV0YWJsZV90b2tlbnMsIHN0YXJ0SW5kZXgsIFN0b3JlUmVzdWx0KQogICAgICAgICAgICAgICAgICAgICAgICBTdG9yZVJlc3VsdCA9IFJldHVybnZhbHVlLlN0b3JlUmVzdWx0CgoKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0CgoKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCkKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zID0gZ2V0U291cmNlZGF0YShGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQsIG11dGFibGVfdG9rZW5zLCAnfScsIFNvdXJjZWRhdGFUb2tlbnMpCiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2VuczogJywgU291cmNlZGF0YVRva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2Vucy5mb3JFYWNoKGVsPT57CgplbC5pc05lc3RlZExvb3A9ZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgfSkKCgogICAgICAgICAgICAgICAgICAgIGxldCBGaW5kTmVzdGVkTG9vcD0gU291cmNlZGF0YVRva2Vucy5maW5kKGVsPT4gZWwudHlwZT09J0Zvckxvb3BTdGFydCcpCiAgICAgICAgICAgICAgICAgICBpZihGaW5kTmVzdGVkTG9vcCE9dW5kZWZpbmVkKQogICAgICAgICAgICAgICAgICAgewogIAogICAgICAgICAgICAgICAgICAgICAgIGxldCBOZXN0ZWRMb29waW5kZXg9U291cmNlZGF0YVRva2Vucy5pbmRleE9mKEZpbmROZXN0ZWRMb29wKSsyCiAgICAgICAgICAgICAgICAgICAgICAgbGV0IE5lc3RlZExvb3BsZW5ndGg9KFNvdXJjZWRhdGFUb2tlbnNbTmVzdGVkTG9vcGluZGV4XS5FbmRJbmRleC1Tb3VyY2VkYXRhVG9rZW5zW05lc3RlZExvb3BpbmRleF0uc3RhcnRJbmRleCkrMQoKICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHg9TmVzdGVkTG9vcGluZGV4O3g8TmVzdGVkTG9vcGluZGV4K05lc3RlZExvb3BsZW5ndGg7eCsrKQogICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgU291cmNlZGF0YVRva2Vuc1t4XS5pc05lc3RlZExvb3A9dHJ1ZQoKICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgCgoKCgogICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmluY2x1ZGVzKCcoJykgJiYgZWxlbWVudC5pbmNsdWRlcygnLCcpKQogICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICBGbGFnUHJpbWFsTG9vcCA9IDEKCgogICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0N5Y2xlOiAnLCBDeWNsZSxJdGVyYXRpb25TdGFydCk7CgoKICAgICAgICAgICAgICAgICAgICAvL0l0ZXJhdGluZyBvdmVyIGZvcmxvb3Agc291cmNlZGF0YQogICAgICAgICAgICAgICAgICAgIC8vdGhpcyBsaW5lICdpdGVyYXRvciA8PSBDeWNsZScgZGV0ZXJtaW5lcyBzdGFydCBvZiB0aGUgbG9vcCBhbmQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsb29wCgogICAgICAgICAgICAgICAgICAgIGZvciAoaXRlcmF0b3IgPSBJdGVyYXRpb25TdGFydDsgaXRlcmF0b3IgPD0gQ3ljbGU7IGl0ZXJhdG9yKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvcmxvb3BpbmRleCA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZWwgPT4gZWwubmFtZSA9PSBPcmlnaW5hbEl0ZXJhdG9yKQogICAgICAgICAgICAgICAgICAgICAgICAKCgoKICAgICAgICAgICAgICAgICAgICAgICAgZm9ybG9vcGluZGV4LnZhbHVlID0gaXRlcmF0b3IKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3VwZGF0ZWRfdG9rZW5zOiAnLCB1cGRhdGVkX3Rva2Vucyk7CgogICAgICAgICAgICAgICAgICAgICAgICAvL2ZsYWcgdG8gYXZvaWQgcnVubmluZyB0aGlzIGNvZGUgaWYgbG9vcCBpcyBwcmltYWwgYmVjYXVzZSB0aGUgcGF5bG9hZCBuZWVkcyB0byBiZSBjb21wZWx0ZWx5IGRpZmZlcmVudAogICAgICAgICAgICAgICAgICAgICAgICBpZiAoRmxhZ1ByaW1hbExvb3AgPSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3JMb29wQXJyYXlvclN0cmluZ091dHB1dChlbGVtZW50VmFsdWUsIGl0ZXJhdG9yLCB1cGRhdGVkX3Rva2VucywgdGhpcykKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoOyBpKyspCgoKICAgICAgICAgICAgICAgICAgICAgICAgewoKCmxldCBpc05lc3RlZD1Tb3VyY2VkYXRhVG9rZW5zW2ldLmlzTmVzdGVkTG9vcAoKCmlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gJ0Zvckxvb3BTdGFydCcpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRGbGFnUHJpbWFsTG9vcCA9IDAKICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIHZhciBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zID0gW10gICAgICAKCiAgICAgICAgICAgICAgICAgICAgbGV0IE5lc3RlZEZvckxvb3BNZXRhRGF0YT0gRm9yTG9vcFNldE1ldGFkYXRhKFNvdXJjZWRhdGFUb2tlbnMsaSx1cGRhdGVkX3Rva2VucykKICAgICAKICAgLy8gIGNvbnNvbGUubG9nKCdOZXN0ZWRGb3JMb29wTWV0YURhdGE6ICcsIE5lc3RlZEZvckxvb3BNZXRhRGF0YSk7Cgp2YXIgTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0PU5lc3RlZEZvckxvb3BNZXRhRGF0YS5Gb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQKdmFyIE5lc3RlZEN5Y2xlPU5lc3RlZEZvckxvb3BNZXRhRGF0YS5DeWNsZSsxCnZhciBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yPU5lc3RlZEZvckxvb3BNZXRhRGF0YS5PcmlnaW5hbEl0ZXJhdG9yCnZhciBOZXN0ZWRJdGVyYXRpb25TdGFydD1OZXN0ZWRGb3JMb29wTWV0YURhdGEuSXRlcmF0aW9uU3RhcnQKdmFyIE5lc3RlZGl0ZXJhdG9yPU5lc3RlZEZvckxvb3BNZXRhRGF0YS5pdGVyYXRvcgp2YXIgTmVzdGVkZWxlbWVudD1OZXN0ZWRGb3JMb29wTWV0YURhdGEuZWxlbWVudAp2YXIgTmVzdGVkZWxlbWVudFZhbHVlPU5lc3RlZEZvckxvb3BNZXRhRGF0YS5lbGVtZW50VmFsdWUKCiAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCkgewogICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzdGFydEluZGV4LCBTb3VyY2VkYXRhVG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQ6ICcsIHN0YXJ0SW5kZXgsIFNvdXJjZWRhdGFUb2tlbnMsIGNoZWNrLCBTdG9yZVJlc3VsdCk7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBSZXR1cm52YWx1ZSA9IEhhbmRsZUJsb2NrcyhTb3VyY2VkYXRhVG9rZW5zLCBzdGFydEluZGV4LCBTdG9yZVJlc3VsdCkKICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQgPSBSZXR1cm52YWx1ZS5TdG9yZVJlc3VsdAoKCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdAoKCiAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICBOZXN0ZWRGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPSBnZXRMb29wSW5kZXhTdGFydChTb3VyY2VkYXRhVG9rZW5zLCBpLCAneycsIE5lc3RlZEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCkKICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQ6ICcsIEZvckxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgTmVzdGVkU291cmNlZGF0YVRva2VucyA9IGdldFNvdXJjZWRhdGEoTmVzdGVkRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBTb3VyY2VkYXRhVG9rZW5zLCAnfScsIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMpCiAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zOiAnLCBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zKTsKICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgCiBmb3IgKE5lc3RlZGl0ZXJhdG9yID0gMDsgTmVzdGVkaXRlcmF0b3IgPE5lc3RlZEN5Y2xlOyBOZXN0ZWRpdGVyYXRvcisrKSB7CnsKCmxldCB5ID0gTmVzdGVkaXRlcmF0b3IKCgpsZXQgTmVzdGVkZm9ybG9vcGluZGV4ID0gdXBkYXRlZF90b2tlbnMuZmluZChlbCA9PiBlbC5uYW1lID09IE5lc3RlZE9yaWdpbmFsSXRlcmF0b3IpCiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2Zvcmxvb3BpbmRleDogJywgZm9ybG9vcGluZGV4KTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgTmVzdGVkZm9ybG9vcGluZGV4LnZhbHVlID0geQoKCmZvcihsZXQgaW5kZXg9MDtpbmRleDxOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDtpbmRleCsrKQp7CgoKbGV0IGVsPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4XQoKaWYoZWwudmFsdWU9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykKCnsKCgoKSWZUb2tlblByaW50KE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsdXBkYXRlZF90b2tlbnMsIGluZGV4LCB0aGlzLCB5LCBOZXN0ZWRPcmlnaW5hbEl0ZXJhdG9yKQoKCn0KCiBlbHNlIGlmIChlbC52YWx1ZSA9PSAnPScgJiYgZWwuaXNOZXN0ZWRMb29wPT10cnVlKSB7CiAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYXNzaWduaW5nIHZhbHVlcyB0byB2YXJpYWJsZXMKICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMsIGluZGV4LCB1cGRhdGVkX3Rva2VucywgeSwgTmVzdGVkT3JpZ2luYWxJdGVyYXRvcikKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgIGlmIChlbC50eXBlID09ICdjb25kaXRpb24nICYmIGVsLmlzTmVzdGVkTG9vcD09dHJ1ZSkKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2Vuc1tpXTogJywgU291cmNlZGF0YVRva2Vuc1tpXSxpKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IENvbmRpdGlvblN0YXJ0SW5kZXggPSBpbmRleAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4XS52YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxlQ29uZGl0aW9ucyBldmFsdWF0ZXMgY29uZGl0aW9uIGFuZCByZXR1cm4gdGhlIGluZGV4IG9mIGZyb20gd2hlcmUgcHJpbnRpbmcgc2hvdWxkIHJlc3VtZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFsdWUgb2YgaSBkZXBlbmRzIG9uIHRoZSBjb25kaXRpb25zCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24uaW5jbHVkZXMoJ3x8JykgfHwgY29uZGl0aW9uLmluY2x1ZGVzKCcmJicpKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gR2V0Q29uZGl0aW9uVmFsdWUoY29uZGl0aW9uLCB1cGRhdGVkX3Rva2VucywgaW5kZXgpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gZmFsc2UpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCbG9ja0xlbmd0aCA9IDAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCbG9ja1N0YXJ0ID0gMAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChOZXN0ZWRTb3VyY2VkYXRhVG9rZW5zW2luZGV4XS52YWx1ZSAhPSAneycpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleCArIDFdLnZhbHVlID09ICd7JykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJsb2NrTGVuZ3RoID0gTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleCArIDFdLkVuZEluZGV4IC0gTmVzdGVkU291cmNlZGF0YVRva2Vuc1tpbmRleCArIDFdLnN0YXJ0SW5kZXgKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gQmxvY2tMZW5ndGggKyBpbmRleCArIDEKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKY29uc29sZS5sb2coJ05lc3RlZFNvdXJjZWRhdGFUb2tlbnM6ICcsIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdpbmRleCA6ICcsIGluZGV4ICk7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHg9IEhhbmRsZUNvbmRpdGlvbnMoTmVzdGVkU291cmNlZGF0YVRva2VucywgaW5kZXgsIHVwZGF0ZWRfdG9rZW5zKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3g6ICcsIHgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHggIT0gdW5kZWZpbmVkKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0geAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gQ29uZGl0aW9uU3RhcnRJbmRleAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnaW5kZXggOiAnLCBpbmRleCApOwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdqOiAnLCBqKTsKCiAgICAgICAgICAgICAgICAgICAvLyBpID0gaSArIE5lc3RlZFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoCiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CgoKIGVsc2UgIGlmIChlbC50eXBlID09ICJTZXRBcnJheUluZGV4VmFsdWUiICYmIGVsLmlzTmVzdGVkTG9vcD09dHJ1ZSkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBWYWx1ZSA9IGVsLnZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2VuczogJywgU291cmNlZGF0YVRva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmFsdWU6ICcsIFZhbHVlLGkpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWVUb1NldCA9IGVsLlZhbHVlVG9TZXQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBSZW1vdmVCcmFja2V0cyhWYWx1ZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBBcnJheUVsZW1lbnQgPSAnJwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TZXByYXRpbmcgb3V0IGluZGV4IGlkZW50aWZpZXIuIHh5eiBmcm9tIEFycmF5W3h5el0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmVwbGFjZSgnXScsICcnKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IFNwbGl0ID0gZWxlbWVudC5zcGxpdCgnWycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGlmIHdlIG5lZWQgdG8gc2V0IGRpcmVjdCBBcnJheSBlbGVtZW50IHZhbHVlLiBsaWtlIEFycmF5WzJdPSB4eXggICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihTcGxpdFsxXSkpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdCArICddJwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5RWxlbWVudCA9IFNwbGl0CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaW5kZXgsIHVwZGF0ZWRfdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBmYWxzZSwgTmV3VmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJ1biBpZiB3ZSBuZWVkIHRvIGR5bmFtaWNhbGx5IHNldCBBcnJheSBlbGVtZW50IHZhbHVlLiBsaWtlIEFycmF5W2ldPSB4eXgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0NyZWF0ZUFycmF5RWxlbWVudCBmdW5jdGlvbiB3aWxsIGNyZWF0ZSBkeW5hbWljIEFycmF5IHZhbHVlcy4gbGlrZSBBcnJheVswXSwgQXJyYXlbMV0gZXRjLiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gU3BsaXRbMV0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIGl0ZXJhdG9yIGFzIHBlciB1c2VyIGlucHV0IAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvciBpdGVyYXRvciBsaWtlIGNvdW50PWNvdW50ICsgMSwgQXJyYXlbY291bnRdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SW50ZXJhdG9yID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9rZW4gPSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsID0+IGVsLm5hbWUgPT0gaW5kZXgpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT0gdW5kZWZpbmVkKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhdG9yID0gdG9rZW4udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhdG9yID0gaXRlcmF0b3IKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBDcmVhdGVBcnJheUVsZW1lbnQoVmFsdWUsIG5ld0ludGVyYXRvcikKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIGlzIHdyaXR0ZW4gdG8gZmluZCBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09IGEqMTAwK2FnZSphLiBub3RpY2UgYQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmluZCBhIHdheSB0byBzaW1wbGlmeSB0aGlzIGluIGxvbmcgdGVybQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IFZhbHVlVG9TZXQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcqJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnKycpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJy0nKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcvJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGF0YTogJywgQXJyYXlFbGVtZW50LCBkYXRhLCBTcGxpdCk7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYnVpbGRpbmcgYSBuZXcgdmFsdWUgdG8gY29udmVydCBhKjEwMCthZ2UqYSBpbnRvIDUqMTAwK2FnZSphIGFuZCB0aGVuIHNlbmRpbmcgaXQgdG8gQ2FsY3VsYXRlVmFsdWVzKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgTmV3VmFsdWVUb1NldCA9ICcnCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaW5jbHVkZXMoU3BsaXRbMV0pICYmIGRhdGEubGVuZ3RoID4gMSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vd2UgaGF2ZSBvcGVyYXRpb25zIGxpa2UgQXJyYXlbYV09IGEqMTAwK2FnZSphLiBub3RpY2UgYQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbSA9IDA7IG0gPCBWYWx1ZVRvU2V0Lmxlbmd0aDsgbSsrKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChWYWx1ZVRvU2V0W21dID09IFNwbGl0WzFdICYmICEoL15bYS16XSskL2kudGVzdChWYWx1ZVRvU2V0W20gKyAxXSkpKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZSBpcyBiZWVuIHNldCAuIHJlcGxhY2luZyBpbmRleCB2YWx1ZSBhIHdpdGggaXRlYXJ0b3IgdmFsdWUgMCwxLDIsIGV0Yy4gICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gTmV3VmFsdWVUb1NldCArIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTmV3VmFsdWVUb1NldCA9IE5ld1ZhbHVlVG9TZXQgKyBWYWx1ZVRvU2V0W21dCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXQgPSBmYWxzZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dhdmUgaXQgYSBkaWZmZXJlbnQgbmFtZSBzbyBpdCB3b3VsZCBub3QgZnVjayB1cCB3aXRoIGZvciBsb29wIGl0ZXJhdG9yCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKE5ld1ZhbHVlVG9TZXQsIGosIHVwZGF0ZWRfdG9rZW5zLCApCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGl0ZXJhdCwgTmV3VmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvbmRpdGlvbiBlbmFibGVzIHByb2dyYW0gdG8gb25seSBydW4gIEFycmF5W2FdPSB4eXogd2hlbiBpdGVyYXRvciBpcyBhLiBJdCBkaXNhbGxvd3MgcnVubmluZyBBcnJheVtibGFibGFibGFdPXh5egogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPcmlnaW5hbEl0ZXJhdG9yID09IFNwbGl0WzFdKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU3BsaXRbMV0gPT0gVmFsdWVUb1NldCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSB0cnVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT1hZ2VvbmUqMTAwCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLmluY2x1ZGVzKFNwbGl0WzFdKSAmJiBPcmlnaW5hbEl0ZXJhdG9yID09IFNwbGl0WzFdKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBmYWxzZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9TZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsdXBkYXRlZF90b2tlbnMsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9taWdodCBoYXZlIHRvIGFkZCBtb3JlIGNvbmRpdGlvbnMgaW4gdGhlIGZ1dHVyZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoVmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ1ZhbHVlVG9TZXQ6ICcsIFZhbHVlVG9TZXQpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKCgoKCn0KCgoKCgoKCn0KCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCn0KCgoKCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZSA9PSAnPScgICYmIGlzTmVzdGVkPT1mYWxzZSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2lnbm9yVXBkYXRlVmFsdWVzKFNvdXJjZWRhdGFUb2tlbnMsIGksIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcikKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9IYW5kbGluZyBwcmludCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCgogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIGlzTmVzdGVkPT1mYWxzZSkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIG9wZXJhdGlvbnMgbGlrZSBwcmludChhcnJheVszXSkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZvciBsb29vcCBwcmludHM6ICcsIFNvdXJjZWRhdGFUb2tlbnNbaV0saSk7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQoU291cmNlZGF0YVRva2Vucyx1cGRhdGVkX3Rva2VucywgaSwgdGhpcywgaXRlcmF0b3IsIE9yaWdpbmFsSXRlcmF0b3IpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vSGFuZGxpbmcgc2V0IGFycmF5IGVsZW1lbnQgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWUgPSBTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnU291cmNlZGF0YVRva2VuczogJywgU291cmNlZGF0YVRva2Vucyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVmFsdWU6ICcsIFZhbHVlLGkpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWVUb1NldCA9IFNvdXJjZWRhdGFUb2tlbnNbaV0uVmFsdWVUb1NldAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IFJlbW92ZUJyYWNrZXRzKFZhbHVlKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIEFycmF5RWxlbWVudCA9ICcnCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NlcHJhdGluZyBvdXQgaW5kZXggaWRlbnRpZmllci4geHl6IGZyb20gQXJyYXlbeHl6XQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5yZXBsYWNlKCddJywgJycpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgU3BsaXQgPSBlbGVtZW50LnNwbGl0KCdbJykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBydW4gaWYgd2UgbmVlZCB0byBzZXQgZGlyZWN0IEFycmF5IGVsZW1lbnQgdmFsdWUuIGxpa2UgQXJyYXlbMl09IHh5eCAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKFNwbGl0WzFdKSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdC5qb2luKCdbJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQgKyAnXScKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheUVsZW1lbnQgPSBTcGxpdAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGosIHVwZGF0ZWRfdG9rZW5zLCApCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGZhbHNlLCBOZXdWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGlmIHdlIG5lZWQgdG8gZHluYW1pY2FsbHkgc2V0IEFycmF5IGVsZW1lbnQgdmFsdWUuIGxpa2UgQXJyYXlbaV09IHh5eAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ3JlYXRlQXJyYXlFbGVtZW50IGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGR5bmFtaWMgQXJyYXkgdmFsdWVzLiBsaWtlIEFycmF5WzBdLCBBcnJheVsxXSBldGMuICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBTcGxpdFsxXQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldHRpbmcgaXRlcmF0b3IgYXMgcGVyIHVzZXIgaW5wdXQgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm9yIGl0ZXJhdG9yIGxpa2UgY291bnQ9Y291bnQgKyAxLCBBcnJheVtjb3VudF0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdJbnRlcmF0b3IgPSAwCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbiA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZWwgPT4gZWwubmFtZSA9PSBpbmRleCkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPSB1bmRlZmluZWQpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnRlcmF0b3IgPSB0b2tlbi52YWx1ZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnRlcmF0b3IgPSBpdGVyYXRvcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChWYWx1ZSwgbmV3SW50ZXJhdG9yKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgaXMgd3JpdHRlbiB0byBmaW5kIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT0gYSoxMDArYWdlKmEuIG5vdGljZSBhCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maW5kIGEgd2F5IHRvIHNpbXBsaWZ5IHRoaXMgaW4gbG9uZyB0ZXJtCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gVmFsdWVUb1NldAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJyonKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcrJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLScpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJy8nKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCcsJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkYXRhOiAnLCBBcnJheUVsZW1lbnQsIGRhdGEsIFNwbGl0KTsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9idWlsZGluZyBhIG5ldyB2YWx1ZSB0byBjb252ZXJ0IGEqMTAwK2FnZSphIGludG8gNSoxMDArYWdlKmEgYW5kIHRoZW4gc2VuZGluZyBpdCB0byBDYWxjdWxhdGVWYWx1ZXMoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBOZXdWYWx1ZVRvU2V0ID0gJycKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5pbmNsdWRlcyhTcGxpdFsxXSkgJiYgZGF0YS5sZW5ndGggPiAxKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93ZSBoYXZlIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT0gYSoxMDArYWdlKmEuIG5vdGljZSBhCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IFZhbHVlVG9TZXQubGVuZ3RoOyBtKyspCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFZhbHVlVG9TZXRbbV0gPT0gU3BsaXRbMV0gJiYgISgvXlthLXpdKyQvaS50ZXN0KFZhbHVlVG9TZXRbbSArIDFdKSkpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIGlzIGJlZW4gc2V0IC4gcmVwbGFjaW5nIGluZGV4IHZhbHVlIGEgd2l0aCBpdGVhcnRvciB2YWx1ZSAwLDEsMiwgZXRjLiAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBOZXdWYWx1ZVRvU2V0ICsgaXRlcmF0b3IKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gTmV3VmFsdWVUb1NldCArIFZhbHVlVG9TZXRbbV0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdCA9IGZhbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2F2ZSBpdCBhIGRpZmZlcmVudCBuYW1lIHNvIGl0IHdvdWxkIG5vdCBmdWNrIHVwIHdpdGggZm9yIGxvb3AgaXRlcmF0b3IKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoTmV3VmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMsICkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0LCBOZXdWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29uZGl0aW9uIGVuYWJsZXMgcHJvZ3JhbSB0byBvbmx5IHJ1biAgQXJyYXlbYV09IHh5eiB3aGVuIGl0ZXJhdG9yIGlzIGEuIEl0IGRpc2FsbG93cyBydW5uaW5nIEFycmF5W2JsYWJsYWJsYV09eHl6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9yaWdpbmFsSXRlcmF0b3IgPT0gU3BsaXRbMV0pIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTcGxpdFsxXSA9PSBWYWx1ZVRvU2V0KSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IHRydWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Igb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPWFnZW9uZSoxMDAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaW5jbHVkZXMoU3BsaXRbMV0pICYmIE9yaWdpbmFsSXRlcmF0b3IgPT0gU3BsaXRbMV0pIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IGZhbHNlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWVUb1NldCA9IENhbGN1bGF0ZVZhbHVlcyhWYWx1ZVRvU2V0LCBqLCB1cGRhdGVkX3Rva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdWYWx1ZVRvU2V0OiAnLCBWYWx1ZVRvU2V0KTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCx1cGRhdGVkX3Rva2VucywgaXRlcmF0b3IsIFZhbHVlVG9TZXQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21pZ2h0IGhhdmUgdG8gYWRkIG1vcmUgY29uZGl0aW9ucyBpbiB0aGUgZnV0dXJlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBmYWxzZQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWVUb1NldCA9IENhbGN1bGF0ZVZhbHVlcyhWYWx1ZVRvU2V0LCBqLCB1cGRhdGVkX3Rva2VucykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZygnVmFsdWVUb1NldDogJywgVmFsdWVUb1NldCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCgogICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gJ2NvbmRpdGlvbicpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ1NvdXJjZWRhdGFUb2tlbnNbaV06ICcsIFNvdXJjZWRhdGFUb2tlbnNbaV0saSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBDb25kaXRpb25TdGFydEluZGV4ID0gaQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb24gPSBTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9IYW5kbGVDb25kaXRpb25zIGV2YWx1YXRlcyBjb25kaXRpb24gYW5kIHJldHVybiB0aGUgaW5kZXggb2YgZnJvbSB3aGVyZSBwcmludGluZyBzaG91bGQgcmVzdW1lCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSBvZiBpIGRlcGVuZHMgb24gdGhlIGNvbmRpdGlvbnMKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbi5pbmNsdWRlcygnfHwnKSB8fCBjb25kaXRpb24uaW5jbHVkZXMoJyYmJykpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBHZXRDb25kaXRpb25WYWx1ZShjb25kaXRpb24sIHVwZGF0ZWRfdG9rZW5zLCBpKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gZmFsc2UpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCbG9ja0xlbmd0aCA9IDAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBCbG9ja1N0YXJ0ID0gMAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlICE9ICd7JykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2kgKyAxXS52YWx1ZSA9PSAneycpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCbG9ja0xlbmd0aCA9IFNvdXJjZWRhdGFUb2tlbnNbaSArIDFdLkVuZEluZGV4IC0gU291cmNlZGF0YVRva2Vuc1tpICsgMV0uc3RhcnRJbmRleAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSA9IEJsb2NrTGVuZ3RoICsgaSArIDEKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gSGFuZGxlQ29uZGl0aW9ucyhTb3VyY2VkYXRhVG9rZW5zLCBpLCB1cGRhdGVkX3Rva2Vucyk7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9IHVuZGVmaW5lZCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gaQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gQ29uZGl0aW9uU3RhcnRJbmRleAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnaTogJywgaSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2o6ICcsIGopOwoKICAgICAgICAgICAgICAgICAgICBqID0gaiArIFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoCiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnajogJywgaik7CgoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL0VORCBGT1IgTE9PUCBFWEVDVVRJT04KCgoKCiAgICAgICAgICAgIH0KCgoKCgoKCiAgICAgICAgICAgIHZhciB0MSA9IHBlcmZvcm1hbmNlLm5vdygpCiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dCAhPSAnJykgewogICAgICAgICAgICAgICAgdGhpcy5UaW1lVGFrZW4gPSAiQ29tcGlsZWQgU3VjY2VzZnVsbHkgaW4gIiArICh0MSAtIHQwKS50b1ByZWNpc2lvbig0KSArICIgbXMuIgoKICAgICAgICAgICAgfQoKCgogICAgICAgICAgICB0aGlzLmxpbmVieWxpbmVPdXRwdXQgPSB0aGlzLm91dHB1dC5zcGxpdCgnXG4nKQoKCiAgICAgICAgICAgIHRoaXMubGluZWJ5bGluZU91dHB1dCA9IHRoaXMubGluZWJ5bGluZU91dHB1dC5maWx0ZXIoZnVuY3Rpb24oaXRlbSkgewogICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09ICIiCiAgICAgICAgICAgIH0pCgoKCgoKCgogICAgICAgICAgICAvL1NFQ1RJT04gLSBDYWxjdWxhdGluZyByZW1haW5pbmcgdmFsdWVzCgoKICAgICAgICAgICAgLy9zbyB0aGF0IHJlcGxhY2UgeCB3aXRoIHZhbHVlcwoKICAgICAgICAgICAgLyoKICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMuZm9yRWFjaCgoZWwsIGkpID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsLnZhbHVlCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZpbmcgdGhlICIoIiIgYW5kICIpIgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ2xlYW5lZEVsZW1lbnQgPSBSZW1vdmVCcmFja2V0cyhlbGVtZW50KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9ICcnCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3doeSBwdXJlZXZhbD8KICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wZXJhdGlvbnMgbGlrZSA1MCs2MCB3ZXJlIHNldCBhcyBbNSwwLCssNiwwXSBpbnN0ZWFkIG9mIFs1MCwrLDYwXS4gYmFzaWNhbGx5IGRpcmVjdCBjYWxjdWxhdGlvbiB3YXMgbm90IHdvcmtpbmcKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHVyZWV2YWwgZmluZHMgc3VjaCBwdXJlIG9wZXJhdGlvbnMgYW5kIHRoZW4gY2FsY3VsYXRlIHRoZW0gdG8gZGlyZWN0bHkgc2V0IHRoZWlyIHZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgc2hpdCBpcyBvbmx5IGZvciBwdXJlb3BlcmF0aW9ucwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHB1cmV2YWwgPSAvXihbLStdP1swLTldKlwuP1swLTldK1tcL1wrXC1cKl0pKyhbLStdP1swLTldKlwuP1swLTldKykqJC9nbS50ZXN0KENsZWFuZWRFbGVtZW50KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdXJldmFsID09IHRydWUpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vuc1tpXS52YWx1ZSA9IGV2YWwodXBkYXRlZF90b2tlbnNbaV0udmFsdWUpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxjdWxhdGlvbihDbGVhbmVkRWxlbWVudCkgPT0gdHJ1ZSAmJiAhcHVyZXZhbCkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtcyA9IENsZWFuZWRFbGVtZW50LnNwbGl0KCcnKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtaW5nIGNhbGN1bGF0aW9ucwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMuZm9yRWFjaCgoZWwsIGkpID0+IHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXh0b0NoYW5nZSA9ICcnIC8vdG8ga25vdyB3aGljaCB2YWx1ZSB0byByZXBsYWNlIGxpa2UgImFubmErZGFkYS1iYWQiIHdpdGggIjUrNi03IgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBlbC52YWx1ZSAvLyByZWFkaW5nIHRoZSBjdXJyZW50IHZhbHVlLCBmb3IgbG9uIHN0cmluZyB2YXJpYWJsZSBuYW1lcyBpdCdzIHN0aWxsIGxpa2UgImFubmErZGFkYS1iYWQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC50b1N0cmluZygpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgU3RyaW5nVmFyID0gW10KICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwdXJldmFsID0gL14oWy0rXT9bYS16XSpcLj9bYS16XStbXC9cK1wtXCpdKSsoWy0rXT9bYS16XSpcLj9bYS16XSspKiQvZ20udGVzdChlbGVtZW50KQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5jbHVkZXMoJz4nKSB8fCBlbGVtZW50LmluY2x1ZGVzKCc8JykgfHwgZWxlbWVudC5pbmNsdWRlcygnPT0nKSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNwbGl0RWxlbWVudHNBcnJheShlbGVtZW50KQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyhTdHJpbmdWYXIsIHVwZGF0ZWRfdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRlVXBkYXRlZF90b2tlbnN3aXRoVmFsdWVzKFN0cmluZ1ZhciwgaSwgdXBkYXRlZF90b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIGErYi1jCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHVyZXZhbCA9PSB0cnVlIHx8IGVsZW1lbnQuY2hhckF0KDApID09ICIoIikgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNwbGl0RWxlbWVudHNBcnJheShlbGVtZW50KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyhTdHJpbmdWYXIsIHVwZGF0ZWRfdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0ZVVwZGF0ZWRfdG9rZW5zd2l0aFZhbHVlcyhTdHJpbmdWYXIsIGksIHVwZGF0ZWRfdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICB9KQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgLyoKICAgICAgICAgICAgICAgICAgICAgICAgIFJlSW50aWFsaXplZFZhcmlhYmxlcy5mb3JFYWNoKGVsPT57CgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZz0wCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBTa2lwSW5kZXg9MAoKICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBtPTA7bTx1cGRhdGVkX3Rva2Vucy5sZW5ndGg7bSsrKQogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWwubmFtZT09dXBkYXRlZF90b2tlbnNbbV0ubmFtZSAmJiBmbGFnPT0wKQogICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWwudmFsdWUuY2hhckF0KDApPT0nIicpCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJ1aWx0U3RyaW5nPSBCdWlsZFN0cmluZyhlbC52YWx1ZSwgKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWc9MTsKICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnNbbV0udmFsdWU9ZWwudmFsdWU7CgoKICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICBTa2lwSW5kZXg9bQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICBpZiggbSE9U2tpcEluZGV4ICYmIGZsYWc9PTEgJiYgZWwubmFtZT09dXBkYXRlZF90b2tlbnNbbV0ubmFtZSkKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnNwbGljZShtLDEpCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAgICAgKi8KCgoKCiAgICAgICAgICAgIC8vU0VDVElPTiAtIEl0ZXJhdGluZyBvdmVyIHRva2VucyBhbmQgdGhlbiBQUklOVElORyBGSU5BTCB1c2luZyB2YWx1ZXMgc3RvcmVkIGluIHVwZGF0ZWQgdG9rZW5zCgogICAgICAgICAgICAvKiAgICAgICAgCgogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykgewoKCiAgICAgICAgICAgICAgICB2YXIgbXV0YWJsZV90b2tlbnMgPSB0b2tlbnMKICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlCiAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gJ+CkquCljeCksOCkv+CkguCknycgKQoKICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBSZW1vdmVCcmFja2V0cyhtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlKQoKCgoKICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNfYXJyYXkucHVzaChiKQoKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgLy9TRUNUSU9OIC0gT3V0cHV0dGluZyB0aGUgY29kZQogICAgICAgICAgICAgICAgICAgIC8vIGZpbmRpbmcgdGhlIHJlbHZhbnQgdmFsdWUgYW5kIHRoZW4gb3V0cHV0IGl0IGFzIEhUTUwKICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gYiApIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQgKyBlbC52YWx1ZSArICJcbiI7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgdG8gYmUgY29udGludWVkCgogICAgICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIC8vSGFuZGxpbmcgQ29uZGl0aW9ucwoKICAgICAgICAgICAgICAgIGlmKG11dGFibGVfdG9rZW5zW2pdLnR5cGU9PSJjb25kaXRpb24iKQogICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbj0gdXBkYXRlZF90b2tlbnMuZmluZChlbD0+IGVsLm9yaWdpbmFsdmFsdWU9PW11dGFibGVfdG9rZW5zW2pdLnZhbHVlKQoKCgogICAgICAgICAgICAgICAgICAgIGxldCBDb25kaXRpb25WYWx1ZT10b2tlbi52YWx1ZQoKICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgaWYoQ29uZGl0aW9uVmFsdWU9PWZhbHNlKQogICAgICAgICAgICAgICAgICAgewoKbGV0IEluaXRpYWxpemVMb29wPSB0b2tlbnMuaW5kZXhPZihtdXRhYmxlX3Rva2Vuc1tqXSkKCgoKCgp3aGlsZShtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlIT0nfScgKQp7CgoKCiAgICBsZXQgeD0gbXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZS5sZW5ndGgKICAgIAogICAgCnRva2Vucy5zcGxpY2UoaisxLCAxKTsKIAoKICAgIGorKzsKCgp9CgoKCgogICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIGlmKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIC9eKFstK10/WzAtOV0qXC4/WzAtOV0rW1wvXCtcLVwqXSkrKFstK10/WzAtOV0qXC4/WzAtOV0rKSokL2dtLnRlc3QobXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZSkgKQogICAgICAgICAgICAgICAgewogCiAgICAgICAgICAgICAgICBsZXQgYT0gZXZhbChtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlKQoKICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQgKyAiXG4iICsgYSArICJcbiIKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgCgogICAgICAgIAogICAgICAgICAgICAgIAoKCgoKICAgICAgLy8gdGhpcyBpcyB0byBoYW5kbGUg4KSq4KWN4KSw4KS/4KSC4KSfICgiQWdlIGlzIisgQWdlKSBldGMuCgogICAgICAgICAgICAgICAgaWYoaXNTdHJpbmdhbmRWYWx1ZShtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSkpCnsKCgogICAgICAgIAoKICAgICAgICAgICAgICAgICAgICBsZXQgeD1tdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZQogICAgICAgICAgICAgICAgICAgIGxldCBzdHJpbmc9JycKICAgICAgICAgICAgICAgICAgICBsZXQgbmV3ZWw9JycKCiAgICAgICAgICAgICAgICAgICAgeD1SZW1vdmVCcmFja2V0cyh4KQoKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAvL3ggPSB4LnJlcGxhY2UoLyAvZywnJykKCiAgICAgICAgICAgICAgICAgICAgeD14LnNwbGl0KCIrIikKCiAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIHguZm9yRWFjaChlbGVtZW50ID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbWVudC5jaGFyQXQoMCk9PSAiICIgfHwgZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGgtMSk9PSIgIiAmJiAhKGVsZW1lbnQuaW5jbHVkZXMoJyInKSkpewoKICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICBuZXdlbD0gZWxlbWVudC5yZXBsYWNlKC9ccy9nLCAnJyk7CgogICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3ZWw9ZWxlbWVudAogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgIGxldCB5PSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsPT4gZWwubmFtZT09IG5ld2VsKQoKICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgIAovLwogICAgICAgICAgICAgICAgICAgICAgIGlmKHkhPXVuZGVmaW5lZCkKICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nPXN0cmluZyArICcgJyArIHkudmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAvLwoKCiAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgIGVsc2V7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudD0gZWxlbWVudC5yZXBsYWNlKC8iL2csICcnKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nPXN0cmluZysgJyAnICsgZWxlbWVudAogICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIH0pOwoKCgogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0ICsgIlxuIiArIHN0cmluZyArICJcbiIKfQoKCi8vVEhJUyBJUyB0byBoYW5kbGUgb3BlcmF0aW9ucyBsaWtlIOCkquCljeCksOCkv+CkguCknyAoIk5hbWUgaXMgR09BVCIpLCDgpKrgpY3gpLDgpL/gpILgpJ8gKCJHb29kYnllIikKCmVsc2V7CgoKCiAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZT0gUmVtb3ZlQnJhY2tldHMobXV0YWJsZV90b2tlbnNbal0udmFsdWUpCiAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICBsZXQgQ2xlYW5lZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvIC9nLCcnKQoKICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgaWYoL14oWy0rXT9bMC05XSpcLj9bMC05XStbXC9cK1wtXCpdKSsoWy0rXT9bMC05XSpcLj9bMC05XSspKiQvZ20udGVzdChDbGVhbmVkVmFsdWUpIT10cnVlKQoKICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvIi9nLCAiIik7CiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8nL2csICIiKTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dCArICJcbiIgKyB2YWx1ZSArICJcbiIgCiB9CiAgICAgICAgICAgICAgICAgICAgICAgIAoKfQoKCiAgICAgICAgICAgIH0KCgogICAgICAgICAgIAogICAgICAgICAgICB9KQoKICAgICAgICB9CiAgICAgICAgKi8KCgogICAgICAgIH0KCiAgICB9Cgp9OyAK"},{"version":3,"sources":["HelloWorld.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;;;AAIA;AACA;;;AAGA;AACA;AACA;;;;AAIA;;;AAGA;AACA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;AACA;;;;;AAKA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;;;;;AAMA;;;AAGA;;;;;;AAMA;AACA;;;;;AAKA;;AAEA;;;;;;AAMA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;;;;;;AAMA;;;;AAIA;;AAEA;;AAEA;;;;;AAKA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;AAEA;;AAEA;;;;;AAKA;;;;AAIA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;;AAKA;;AAEA;;;;;AAKA;AACA;;;;;AAKA;;;;;AAKA;;AAEA;;;;;AAKA;AACA;;;AAGA;AACA;;;;;AAKA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;;;AAKA;AACA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;;AAGA;;;;;AAKA;AACA;;;;;AAKA;;;AAGA;;;;;AAKA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;;;;;AAKA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;;AAGA;AACA;;;;AAIA;;AAEA;;AAEA;;;;AAIA;AACA;;;;;AAKA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;;;;;AAKA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;;;AAIA;AACA;;;;;AAKA;;;AAGA;;;;AAIA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;;;;AAIA;;;AAGA;;AAEA;;AAEA;;AAEA;;;;AAIA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;;AAEA;;;;;AAKA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;;;AAKA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;AACA;;AAEA;AACA;;;;;AAKA;;;;AAIA;;;;AAIA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;;;;AAIA;;;AAGA;AACA;;;;AAIA;;;;AAIA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;;;;AAIA;;;;;AAKA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;;;;AAKA;;;AAGA;;;;;AAKA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;;AAGA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;;AAIA;AACA;;;;;AAKA;;AAEA;;;;AAIA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;;;AAKA;;AAEA;AACA;AACA;;;;AAIA;;;AAGA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;AAKA;;;;AAIA;;;AAGA;;AAEA;AACA;;AAEA;;;;;AAKA;;;;;;;;AAQA;;AAEA;;;AAGA;;;;AAIA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;AAGA;;AAEA;;;AAGA;AACA;;;AAGA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;;AAEA;;AAEA;;;;;AAKA;AACA;;AAEA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;AACA;;AAEA;;;;;AAKA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;AAKA;;;;;AAKA;;AAEA;;;AAGA;AACA;AACA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;;;;AAKA;AACA;;;AAGA;;AAEA;AACA;AACA;;;;AAIA;;AAEA;;;;;AAKA;;;;;AAKA;;;;AAIA;;;;AAIA;AACA;;;AAGA;;;AAGA;AACA;;;;AAIA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;;;;AAIA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;;;;;AAKA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;;;;AAKA;AACA;AACA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;;;;;AAKA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AAYA;;;;;;;AAOA;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;;;;;AAMA;;AAEA;;AAEA;AACA;AACA;;;;;AAKA;;;;;AAKA;;;AAGA;AACA;;;AAGA;;AAEA;;;AAGA;;;;;;AAMA;;AAEA;;;AAGA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;AAEA;AACA;;;;;AAKA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;AAKA;;;;;;;AAOA;AACA;;;;;AAKA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;AACA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;;;;;AAKA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;;AAKA;;AAEA;;AAEA;;;;AAIA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA;;AAEA;;;AAGA;;;;;;;;;AASA;;;AAGA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;;AAMA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;;AAKA;AACA;;;;AAIA;AACA;;;;;;AAMA;AACA;;AAEA;;;AAGA;AACA;;;;AAIA;;;AAGA;AACA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;;AAGA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;AAGA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;;;;;AAKA;;;AAGA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;AAIA;;AAEA;AACA;;;AAGA;;;;;AAKA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;;AAKA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;AACA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;;;;;;;;;AASA;;;;;;;;AAQA;;;;;;;AAOA;;;;;AAKA;;;;;;;;AAQA;;;AAGA;;;AAGA;;;;;AAKA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;;;;AAKA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;AACA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;;;;AAIA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;;AAIA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;;;;;AAKA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;;AAGA;;;;;;;;;;;AAWA;;;;;AAKA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;AACA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;;;;;;;AAOA;AACA;;;AAGA;;;;AAIA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;;;AAKA;;;;AAIA;;;;AAIA;;;;;AAKA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA;;;;;;AAMA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;AAEA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;;;;;;;;;AASA;;;;;;;;;AASA;;;;;;AAMA;;;AAGA;;;;;AAKA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;AACA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;;;;AAIA;;;AAGA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;;;;;;AAMA;;;AAGA;AACA;;;;;;AAMA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;AAEA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;AAKA;;AAEA;;;AAGA;;AAEA;AACA;;;;;AAKA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;AAGA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;;;AAKA;;;;AAIA;;;;AAIA;;;;;AAKA;;;;;AAKA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA;;;;;;AAMA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;AAEA;;;;;AAKA;AACA;;AAEA;AACA;AACA;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;AACA;AACA;;;;;;;;;AASA;;;;;;;;;AASA;;;;;;AAMA;;;AAGA;;;;;AAKA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;AACA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;;;;AAKA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;;AAKA;;AAEA;;AAEA;AACA;;;;AAIA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA;;AAEA;;;AAGA;;;;;;;;;AASA;;;AAGA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;;AAKA;AACA;;;;AAIA;AACA;;;;;;AAMA;AACA;;AAEA;;;AAGA;AACA;;;;AAIA;;;AAGA;AACA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;;AAGA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;AAGA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;;;;;AAKA;;;AAGA;;;;AAIA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;AAIA;;AAEA;AACA;;;AAGA;;;;;AAKA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;;AAKA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;AACA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;;;;;;;;;AASA;;;;;;;;AAQA;;;;;;;AAOA;;;;;AAKA;;;;;;;;;AASA;;AAEA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;;;;AAKA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;AACA;;AAEA;;;;;AAKA;;AAEA;;;;;AAKA;;;AAGA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;;;;AAIA;;AAEA;;;;AAIA;;;;;AAKA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;;AAEA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;;AAIA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;;;;;AAKA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;;;;AAKA;;;;;;;;AAQA;AACA;AACA;;AAEA;;;;AAIA;;;AAGA;AACA;AACA;;;;;;;;AAQA;;;AAGA;;AAEA;AACA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;;AAGA;;;;;AAKA;;AAEA;;;;AAIA;;;;;AAKA;;;;;AAKA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;AACA;AACA;;AAEA;;;;AAIA;;;;AAIA;;;;AAIA;;;AAGA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;;;;;AAKA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA;;;AAGA;AACA;AACA;;;;;AAKA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;AACA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;AACA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;;;;AAKA;;;;AAIA;;AAEA;;;;;;AAMA;;;AAGA;;AAEA;AACA;;;;;;AAMA;;;;AAIA;;;;AAIA;AACA;;AAEA;;;;;;AAMA;AACA;;;;AAIA;;;AAGA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;AAUA;;AAEA;AACA;;;;;AAKA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;;;AAIA;;;AAGA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;;;;;AAKA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;;;;AAIA;AACA;;;AAGA;;AAEA;;;;AAIA;AACA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;AAIA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA","file":"HelloWorld.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"hello\">\n   \n   <div id=\"compiler\">\n   <div id=\"textarea\">\n    <textarea v-model=\"code\" type=\"text\" name=\"code\" id=\"codearea\"></textarea>\n\n    <button id=\"subm\" @click=\"RUN()\">RUN</button>\n   \n   </div>\n\n    <div id=\"output\">\n\n<div id=\"bharatDIV\">\n        <p style=\"color:orange\" id=\"bharatP\">BH</p> <p id=\"bharatP\" style=\"color:white\">AR</p> <p id=\"bharatP\" style=\"color:green\">AT</p>  <p id=\"versionNumber\" >  v1.0</p>\n\n<p style=\"    text-align: left;\n    color: #2fff2f;\n    font-family: monospace;\n\">{{TimeTaken}}</p>\n        \n\n\n<p id=\"linebylineOutput\" v-for=\"(output,index) in this.linebylineOutput\" :key=\"index\">\n\n\n {{output}} \n\n<input v-if=\"output.includes('Enter')\"  type=\"text\" v-model=\"input\" class=\"input\"/>\n\n\n</p>\n\n</div>\n\n\n\n\n    </div>\n</div>\n    <div id=\"errorstack\">\n\n<div v-for=\"(error,index) in this.error\" :key=\"index\">\n\n{{error}}\n</div>\n\n\n    </div>\n\n    \n      \n  </div>\n</template>\n\n<script>\n\nimport prompts from 'prompts'\n\n    import {\n        SourceDataReplaceforEasyParsing\n    } from '../FunctionScripts/functions'\nimport * as TypeCheck from '../FunctionScripts/TypeChecking'\nimport * as AdvancedTypeCheck from '../FunctionScripts/AdvancedTypeChecking'\nimport * as BuildOperation from '../FunctionScripts/BuildOperations'\nimport {\n    PushArray,\n    PushCalculation,\n    PushConditionalKeyword,\n    PushCondition,\n    PushForLoop,\n    PushWhileLoop,\n    PushWhileLoopCondition,\n    PushForLoopAruguments,\n    PushExpression,\n    PushKeyword,\n    PushNumber,\n    PushOperator,\n    PushRealTimePrintOperation,\n    PushString,\n    PushStringandValueOperation,\n    PushVariable,\n    PushVariableValue,\n    PushFunctionData,\n    PushInput\n\n} from '../FunctionScripts/PushFunctions'\nimport {\n    RemoveBrackets,\n    ResetValue,\n    isArrayOperation,\n    CreateArrayElement,\n    CalculateValues,\n    GetArrayorStringElement,\n    SetArrayorStringElement,\n    PrintArrayElement,\n    handlemultConditions,\n    HandleBlocks,\n    SplitElementsArray,\n    SetValues,\n    PushSetArrayIndexValue,\n    PushGetArrayIndexValue,\n    UpdateUpdated_tokenswithValues,\n    GetConditionValue,\n    ForLoopArrayorStringOutput,\n    AssignorUpdateValues,\n    HandleConditions,\n    getLoopIndexStart,\n    ForLoopSetMetadata\n} from '../FunctionScripts/MiscImportantFunctions'\n\n\n\nexport default {\n    name: \"HelloWorld\",\n    props: {\n        msg: String\n    },\n\n    data() {\n        return {\n            code: 'Name=\"Swanand Kadam\" Name=\"Swanand Kadam is goat\" Array=[ 20,30,\"swanand\"] Age=2020-1996 ageone=20 agetwo=30 x=ageone+agetwo City=\"Pune\" प्रिंट (x)  प्रिंट (Name)  प्रिंट (\"You live, you learn\")  प्रिंट (Age)  अगर (ageone>agetwo) {प्रिंट (\"condition worked\")} प्रिंट (Array[2] + Age + \"is young age\" + Age) अगर (ageone==20) {प्रिंट (\"condition 2 worked\") y=x+ageone प्रिंट (y) }',\n            output: '',\n            error: [],\n            OperationObjects: [],\n            linebylineOutput: '',\n            TimeTaken: '',\n            inputIndexes:[],\n            input:''\n\n        };\n    },\n\n    methods: {\n        RUN: function() {\n\n\nconsole.log(prompts);\n\n\nvar t0 = performance.now()\n\n            //to stop accumulating output on succesive RUN\n            this.output = ''\n            this.input='',\n            this.linebylineOutput = this.output.split(\"\\n\")\n            this.inputIndexes=[]\n            this.error = []\n            this.OperationObjects = []\n            var sourcedata = this.code;\n            var cleaned_sourcedata = []\n            var i = 0;\n            var tokens = [];\n            var mixedimpurity = []\n            var updated_tokens = []\n            var functionContextupdated_tokens=[]\n            var variables_array = []\n            var assigned_variables = []\n            var terms = []\n            var terms2 = []\n            var operation = ''\n            var CalculationStack = []\n            var foundToken = ''\n            var ReIntializedVariables = []\n\n            //emptying accumulatedvalue stored for operations like Name= Name+Array[i]\n            //See AssignorUpdateValues fuction for more\n            ResetValue()\n\n\nfunction sleep(milliseconds) {\n  const date = Date.now();\n  let currentDate = null;\n  do {\n    currentDate = Date.now();\n  } while (currentDate - date < milliseconds);\n}\n\n\n            //preparing sourcedata for easy parsing by handling new lines, enters etc.\n            //cleaning up the data to get my version of sourcedata. it's better to get version suitable for me because users can type what they wish but I need to maintain \n            //integrity of program in every possible conditio. So. I created my own condition below\n\n            function GetCleanSourcedata(sourcedata, cleaned_sourcedata, impurities) {\n\n                sourcedata = SourceDataReplaceforEasyParsing(sourcedata)\n\n                sourcedata.forEach((element, i) => {\n\n\n                    //finding the elements which has =\" in it so that to seprate them e.g. anna=\"swanand\" also finding the elements which starts with =. e.g \"=78787890\"\n\n\n\n                    if (!element.includes('==')&&(element.indexOf('=\"') > -1 || element.indexOf('=') > 0 || element.charAt(0) == \"=\") && element != '==')\n\n\n                    {\n\n\n\n                        impurities.push(element) //push such element as impurity in impurities\n\n\n\n                        let elements = element.split(\"=\")\n                        let index = cleaned_sourcedata.length\n\n\n                        cleaned_sourcedata[index] = (elements[0])\n                        cleaned_sourcedata[index + 1] = (\"=\")\n                        cleaned_sourcedata[index + 2] = (elements[1])\n\n\n\n                    }\n\n\n                    //as long as element is pure, push it to new and clean version of sourcedata\n                    if (!impurities.includes(element)) {\n\n\n\n                        cleaned_sourcedata.push(element)\n\n                    }\n\n                    //\n\n                })\n\n\n                //removing empty \"\" values for final version of sourcedata\n                //SECTION FInal sourcedata cleaning\n\n                cleaned_sourcedata = cleaned_sourcedata.filter(function(item) {\n                    \n                    return item !== \"\"\n                })\n\n\n\n                return cleaned_sourcedata;\n\n            }\n\n\n            let Result = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity)\n\n            cleaned_sourcedata = Result\n            console.log('cleaned_sourcedata: ', cleaned_sourcedata);\n\n\n\n\n            //SECTION - Start of Bharat Parser\n\n\n            //Checking for type of characters\n\n            const isVariable = TypeCheck.isVariable()\n            const isNumber = TypeCheck.isNumber()\n\n            const isOperator = TypeCheck.isOperator()\n\n            const isKeyword = TypeCheck.isKeyword()\n            const isConditionalKeyword = TypeCheck.isConditionalKeyword()\n            const isForLoop = TypeCheck.isForLoop()\n            const isWhileLoop = TypeCheck.isWhileLoop()\n            const isFunction = TypeCheck.isFunction()\n            //needs work\n            const isExpression = TypeCheck.isExpression()\n\n            const isArray = TypeCheck.isArray()\n            const isInput = TypeCheck.isInput() \n\n            const isSetArrayIndexValue = TypeCheck.isSetArrayIndexValue()\n\n            // const isEmptyArrayInit = TypeCheck.isEmptyArrayInit()\n\n            const isString = TypeCheck.isString()\n\n            const isPureEval = AdvancedTypeCheck.isPureEval()\n\n            //if parser encounters anything like (\" or (, then that's a realtime print. \n            //buildstring will be applied now to create a string and push it into tokens\n\n            const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString()\n\n\n\n            const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n            const isCalculation = AdvancedTypeCheck.isCalculation()\n\n            const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n\n\n\n            // to solve [a,n,n,a] into [anna]\n\n            //SECTION Build Operations \n\n            const BuildString = BuildOperation.BuildString()\n\n            const BuildArray = BuildOperation.BuildArray()\n\n            const BuildCondition = BuildOperation.BuildCondition()\n\n\n            //this function is the first step to handlle operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n            \n\n\n            //counting how many times do we have &&, || condition present\n            function Count(item, element) {\n\n                let count = 0\n\n\n                for (let i = 0; i < element.length; i++) {\n\n                    if (element.charAt(i) == item && element.charAt(i + 1) == item) {\n\n                        count += 1\n\n\n\n                    }\n\n\n\n                }\n\n                return count;\n\n\n            }\n\n\n\n            //This will run for every print statement encountered in the program, not just for loops\n\n            function IfTokenPrint(Tokens,updated_tokens, j, global, iterator, OriginalIterator)\n            \n            \n            \n\n\n            {\n\n\n                var token = Tokens[j].value\n                \n                \n                \n\n\n                var NextTokenValue = Tokens[j + 1].value\n                NextTokenValue=NextTokenValue.replace(\"+\", ' + ')\n                \n                \n\n\n                var StringVar = []\n\n                var b = RemoveBrackets(NextTokenValue)\n                \n                \n\n\n\n                if (isVariable(b)) {\n\n                    variables_array.push(b)\n                    // \n\n                }\n\n\n                //SECTION - Outputting the code\n                // finding the relvant value and then output it as HTML\n\n                //This loop is only for printing direct values like print(name), print(array)\n\n                updated_tokens.forEach((el, i) => {\n                    \n\n\n\n\n                    //THIS IS THE REAL GAME\n\n\n\n                    if (el.name == b) {\n\n                        //for calculations like x=ageone+agetwo\n\n                        //If we have already caluculated value, use that or else move forward\n\n\n\n\n                        if (assigned_variables.includes(el)) {\n\n\n                            global.output = global.output + el.value + \"\\n\";\n                            \n\n\n                        } else {\n\n\n                            if (isNumber(el.value)) {\n\n\n\n                                global.output = global.output + el.value + \"\\n\";\n                                \n\n                                assigned_variables.push(el);\n                                \n\n\n                            }\n\n                            //operations like age=2020-1996\n\n                            else if (isPureEval(el.value)) {\n\n\n\n\n                                let outputpure = eval(el.value)\n\n\n\n                                el.value = outputpure\n\n\n                                global.output = global.output + outputpure + \"\\n\";\n\n                                assigned_variables.push(el);\n\n                            }\n\n\n\n                            //operations like name=\"swanand kadam\", variable assignments as strings\n\n                           else if (!isPureEval(el.value) && !isNumber(el.value))\n\n\n                            {\n\n\n\n\n                                if (!(el.name.includes(']') && el.name.includes('['))) {\n\n                                    global.output = global.output + el.value + \"\\n\";\n\n                                  \n\n\n                                    assigned_variables.push(el);\n                                }\n\n\n\n\n                            }\n\n\n\n\n                        }\n\n                    }\n\n\n\n\n                    // work to be continued\n                })\n\n\n                //ANCHOR - CONDITION 2\n                if (Tokens[j + 1].type == 'Array')\n\n\n\n\n                {\n\n                    //console.log('Tokens[j + 1]: ', Tokens[j + 1]);\n                    //To run only if iterator is present\n\n                    //This runs on for loop - Print(Array[a]) etc\n\n                    //this runs only if for(i) and in the loop, array[i], not on array[x]. Iterator and index should be same\n\n                    if (iterator != undefined && Tokens[j + 1].IndexInput == OriginalIterator)\n\n                    {\n\n\n\n                        let Value = NextTokenValue\n                        // console.log('Value: ', Value);\n\n                        let ArrayElement = CreateArrayElement(Value, iterator)\n\n\n                        let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                        global.output = global.output + output + \"\\n\";\n                        //console.log('output: ', output);\n\n\n                        assigned_variables.push(Tokens[j + 1]);\n\n\n                    }\n\n\n                    //This runs to Print(Array[2]) like specific array values\n                   \n                   else if (Tokens[j].IndexInput != OriginalIterator)\n\n\n                    {\n\n                       // console.log('Tokens[j]: ', Tokens[j + 1]);\n                        //\n\n                        let Value = NextTokenValue\n\n                        let IndexToChange = Tokens[j + 1].IndexInput\n\n\n                        let ArrayElement = CreateArrayElement(Value, IndexToChange)\n\n\n                        let element = ArrayElement.replace(']', '')\n\n\n                        let Split = element.split('[')\n\n\n\n\n                        if (Split[1].includes('-') || Split[1].includes('+')) {\n\n\n                            let output = CalculateValues(Split[1], j, updated_tokens)\n\n                            Split[1] = output\n\n                            Split = Split.join('[') + ']'\n                            ArrayElement = Split\n                            //console.log('ArrayElement: ', ArrayElement);\n\n\n                        }\n\n\n                        let token = updated_tokens.find(el => el.name == Split[1])\n\n                      if(token != undefined && OriginalIterator != Split[1]) {\n\n                            Split[1] = token.value\n\n                            Split = Split.join('[') + ']'\n                            ArrayElement = Split\n\n\n                        } else {\n\n                            ArrayElement = ArrayElement\n                            //console.log('ArrayElement: ', ArrayElement);\n\n                        }\n\n\n                        let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                        global.output = global.output + output + \"\\n\";\n                       // console.log('output: ', output);\n\n\n\n\n                    }\n\n\n                }\n\n\n\n\n                //printing direct numbers and direct calcultions like print(10), print(10*10)\n\n               else if (token == 'प्रिंट' && (isPureEval(NextTokenValue) || isNumber(RemoveBrackets(NextTokenValue)))) {\n\n\n                    let a = eval(NextTokenValue)\n                    console.log('NextTokenValue: ', NextTokenValue);\n\n                    global.output = global.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n\n\n\n                //foroperations like print('you live, you learn')\n               else if (Tokens[j + 1].mode == \"RealTimePrint\" && !NextTokenValue.includes('+') && !NextTokenValue.includes('='))\n\n                {\n\n\n                    let output = RemoveBrackets(NextTokenValue)\n                    console.log('NextTokenValue: ', NextTokenValue);\n\n                    output = output.replace(/\"/g, '');\n                    output = output.replace(/'/g, '');\n\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n                    //console.log('global.output: ', global.output);\n\n\n\n                }\n\n                //operations like print(Age + 'is young age')\n\n               else if (Tokens[j + 1].mode == \"RealTimePrint\" && NextTokenValue.includes('+')) {\n\n\n\n                    let x = SplitElementsArray(NextTokenValue)\n                    console.log('x: ', x);\n                    \n                    \n\n\n                    StringVar = SetValues(x, updated_tokens)\n\n\n\n\n                    StringVar = StringVar.join('')\n                    StringVar = StringVar.split(\"+\")\n\n                    let output = StringVar.join(' ')\n                    output = RemoveBrackets(output)\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n\n\n\n\n                }\n\n\n               else if (isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != \"RealTimePrint\")\n               \n\n                {\n\n\n                    let output = CalculateValues(NextTokenValue, j, updated_tokens)\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n\n\n\n                }\n                // \n\n\n\n\n            }\n\n\n            //END OF Functions and Imported Functions\n\n\n\n            //SECTION - Parsing STARTS here\n\n            //SECTION - Checking each token and adding to tokens array\n\n\n\n            let tempthis = this;\n            let variableArray = [] //TO REMOVE DUPLICATE VARIABLES, SEE 482\n\n            function Parse(cleaned_sourcedata, i) {\n\n                var element = cleaned_sourcedata[i];\n\n\n                var string = []\n\n\n\n\n                if (isVariable(element) == true) {\n\n\n                    if (cleaned_sourcedata[i + 1] == '=') {\n\n\n\n                        PushVariable(element, tokens)\n\n\n                        if (variableArray.includes(element)) {\n\n                           // let UpdateElementValue = element\n\n                            let x = tokens.find(el => el.value == element)\n\n                            let index = tokens.indexOf(x)\n\n\n\n                            //\n\n\n                            ReIntializedVariables.push({\n                                name: element\n                            })\n\n                            //\n\n                            //tokens[index+2].value= cleaned_sourcedata[i+2]\n\n\n\n                        }\n\n                        variableArray.push(element)\n\n\n\n\n                    } else if (cleaned_sourcedata[i - 1] == '=') {\n\n\n                        PushVariableValue(element, tokens)\n\n                    }\n\n                }\n\n                else if (isNumber(element) == true) {\n\n                    PushNumber(element, tokens)\n\n                }\n\n                else if(isInput(element)==true)\n                \n                {\n\n\n                    PushInput(element,tokens,cleaned_sourcedata,i)\n                    \n\n                    \n\n                }\n\n                else if (isOperator(element) == true) {\n                    PushOperator(element, tokens)\n\n                }\n\n               else if (isKeyword(element) == true) {\n\n                    PushKeyword(element, tokens)\n\n                }\n                else if (isFunction(element) == true) {\n\nPushFunctionData(element,tokens, cleaned_sourcedata,i)\n\n                }\n\n                //check if it accpets Arry[2a] as index : \n                else if (isArray(element) == true) {\n\n\n\n\n                    if (element.charAt(element.length - 1) == ']') {\n\n\n\n                        PushArray(element, tokens)\n\n                    } else {\n\n\n                        let BuiltArray = BuildArray(element, i, cleaned_sourcedata)\n\n                        PushArray(BuiltArray, tokens)\n\n\n\n                    }\n                }\n\n                //for Numbers[a]=x\n                else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == true) {\n\n\n\n\n                    PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n\n\n\n                }\n\n                \n\n                //for x=Numbers[a]\n\n               else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == false) {\n\n\n\n                    PushGetArrayIndexValue(element, tokens, cleaned_sourcedata, i)\n\n\n\n\n                }\n\n                /*  if (isEmptyArrayInit(element, cleaned_sourcedata, i) == true) {\n\n\n\n                    PushEmptyArrayInit(tokens, cleaned_sourcedata, i)\n\n\n                }\n*/\n\n\n\n               else if (isConditionalKeyword(element) == true) {\n\n\n\n                    if (isWhileLoop(element) == true) {\n\n                        PushWhileLoop(element, tokens, cleaned_sourcedata, i)\n                        // PushWhileLoopCondition(element, cleaned_sourcedata, i, tokens)\n\n\n                    } else {\n\n                        PushConditionalKeyword(element, tokens)\n                    }\n\n\n                    let foundcondition = BuildCondition(element, i, cleaned_sourcedata)\n                    // console.log('foundcondition: ', foundcondition);\n\n\n\n                    PushCondition(foundcondition, tokens)\n\n\n\n\n                }\n\n\n                else if (isForLoop(element) == true) {\n\n                    PushForLoop(element, tokens)\n                    PushForLoopAruguments(element, cleaned_sourcedata, i, tokens)\n\n                    updated_tokens.push({\n\nname:cleaned_sourcedata[i+1],\nvalue:0,\ntype: 'ForLoopIterator'\n\n                    })\n\n\n                }\n\n\n\n\n              else if (isCalculation(element) == true) {\n\n\n                    let element = ''\n\n                    if (cleaned_sourcedata[i + 1] != undefined) {\n\n\n\n                        // this is to perform long operations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n\n                        while (isCalculation(cleaned_sourcedata[i]))\n\n\n\n                        {\n\n\n                            element = element + cleaned_sourcedata[i];\n\n\n                            i++;\n\n                        }\n\n\n\n\n                    }\n\n\n                    //PushCalculation(element,tokens)\n\n\n\n\n                    //  \n                    terms = element.split('')\n\n                    //removing the \"(\"\" and \")\"\n\n                    var CleanedElement = RemoveBrackets(element)\n\n\n                    // to stop prevention of expressions like is\"+ getting added as a calculation\n                    if (!(CleanedElement.includes('\"')) && element.charAt(0) != '/' && element.charAt(0) != '*') {\n\n                        PushCalculation(element, tokens, cleaned_sourcedata, i)\n\n\n\n                    }\n\n\n                    // terms2 = CleanedElement.split(operation)\n\n                    //checkpoint: to perform calculations \n                    //I have identified the operation(seperated) and terms (seperated)\n\n\n\n                    /*      tempthis.OperationObjects.push({\n                                  terms: terms2,\n\n\n                              }\n\n\n\n                          )\n                          */\n\n\n\n\n                }\n\n                //finding operations like print(\"swanand\"). The realtimeprint operations\n\n\n\n              else  if (isRealTimePrintMultipleString(element) == true) {\n\n\n\n                    //\n                    let foundString = ''\n\n                    let k = i\n                    //  console.log('element: ', element);\n                    let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n                    //console.log('conditionEnd: ', conditionEnd);\n\n\n                    var flag = 0;\n\n\n\n\n                    for (k; k < cleaned_sourcedata.length; k++) {\n\n                        let element = cleaned_sourcedata[k]\n                        // console.log('element: ', element);\n                        let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n\n\n                        if (cleaned_sourcedata[k].includes('दुहराओ') || cleaned_sourcedata[k].includes('प्रिंट') || cleaned_sourcedata[k].includes('अगर') || cleaned_sourcedata[k + 1] == '='|| cleaned_sourcedata[k] == '}') {\n\n\n                            //foundString=foundString+  ' '+ cleaned_sourcedata[k]\n\n                            //\n                            break;\n\n\n                        }\n\n                        if (conditionEnd == ')\"')\n\n                        {\n\n                            foundString = foundString + ' ' + cleaned_sourcedata[k];\n                            break;\n\n                        }\n\n                       else if (flag == 1) {\n\n                            foundString = foundString + ' ' + cleaned_sourcedata[k]\n\n                        }\n\n                        else if (flag == 0) {\n\n                            foundString = cleaned_sourcedata[k];\n\n                            flag = 1;\n\n                        }\n\n\n\n\n                    }\n\n\n\n                    if ((!foundString.includes(\">\")) && (!foundString.includes('/')) && (!foundString.includes('*')) && (!foundString.includes('<')) && (!foundString.includes('==')))\n\n\n                    {\n\n                        //console.log('foundString: ', foundString);\n                        PushRealTimePrintOperation(foundString, tokens)\n\n                    }\n\n\n\n\n                }\n\n\n                \n\n\n\n\n                //storing only the string values to tokens ( not the strings in print statements)\n\n               else if (isString(element))\n\n\n                {\n\n\n\n                    let calculatedString = BuildString(element, i, cleaned_sourcedata)\n\n\n\n                    calculatedString = calculatedString.replace(/['\"]+/g, '')\n\n                    if (!(calculatedString.includes(\"प्रिंट\")))\n\n                        PushString(calculatedString, tokens)\n\n                    //\n\n\n\n                }\n\n\n\n\n                //Found Solution using regexp- print(a) without space is getting accepted as expression\n\n\n               else if (/^(?=.*?प्रिंट)(?=.*[a-z])/.test(element)) {\n\n                    PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n\n\n                    PushExpression(element.slice(6), tokens) //Pushing remaining expression like (a), (gagaks) etc\n                }\n\n\n                //error prone change made here\n\n             else   if (isExpression(element) == true && !isCalculation(element) && !element.includes('[') && !element.includes(']') && (!isConditionalKeyword(cleaned_sourcedata[i - 1])) && (cleaned_sourcedata[i - 1] != 'मे' && cleaned_sourcedata[i - 1] != 'कार्य'  )) {\n\n\n\nif(element.charAt(0)!='(')\n{\n\nlet CheckFunctionExpression= element.split('(')\n\n\nlet passedValues=RemoveBrackets(CheckFunctionExpression[1])\npassedValues=passedValues.split(',')\nlet token= tokens.find(el=> el.value==CheckFunctionExpression[0])\n\n\nif(token!=undefined)\n{\n\n\n\ntoken.FunctionInvocationExists=true\ntoken.ExecutionIndex=i-1\ntoken.passedValues=passedValues\n\n\n\n}\n\n}\n\n                    PushExpression(element, tokens)\n                    \n\n\n\n                }\n             else   if (isExpression(element) == true && element.includes('[') && element.includes(']')) {\n\n                    PushArray(element, tokens)\n\n                }\n\n\n             else   if (!isKeyword(element) && !isNumber(element) && !isVariable(element) && !isExpression(element) && !isOperator(element)) {\n\n\n                    //ANCHOR \n                    /*Hnadling Impurity error-The main problem is figuring out how to solve \"=7000\" like things\n                    instead asking developers to add space manually\n                    Handling Alphanumeric strings to solve issues like ' anna=2362934'\n\n                    let impurity = element.split('=')\n\n                    let findString = impurity[1]\n\n\n                    //to accept long numbers i.e a=749374593745937\n\n                    if (isVariable(impurity[0]) && isNumber(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n                    //to accept a=STRING\n                    if (isVariable(impurity[0]) && isVariable(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n\n\n                    impurity.forEach((element, i) => {\n\n                        if (isVariable(element) == true) {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            //continue;\n                        }\n\n                        // ANCHOR \n\n                        //Issue: Right now, only isNumber is resolved, a=, =23828qw aren't resolved.\n                        //Solution: Work on all the modules\n\n\n                        if (isNumber(element) == true) {\n\n\n                            PushNumber(element, tokens)\n\n                        }\n\n                        //ANCHOR \n                        //You might have to remove this extra filters since you are only working on numbers (Future Issue)\n                        if (isOperator(element) == true) {\n                            PushOperator(element, token)\n\n                        }\n\n\n\n                        if (isKeyword(element) == true) {\n\n                            PushKeyword(element)\n\n                        }\n\n                        if (isExpression(element) == true) {\n\n\n                            PushExpression(element, tokens)\n\n                        }\n\n\n\n\n                    })\n */\n\n                }\n               \n\n\n\n            }\n\n            //SECTION - Checking each token and adding to tokens array\n            // PARSING INITIATION\n\n\n            for (i; i < cleaned_sourcedata.length; i++) {\n\n\n                Parse(cleaned_sourcedata, i)\n            }\n\n            //ANCHOR \n            //CLEANING UP THE TOKENS ARRAY\n            //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n            tokens = tokens.filter(el => el.value != '')\n            console.log('tokens: ', tokens);\n\n\n\n\n            //To find undefined variables\n            let difference = variables_array.filter(x => !assigned_variables.includes(x))\n\n            //\n\n            if (difference.length > 0)\n\n            {\n                this.error.push(' Variable ' + difference.toString().split(',') + ' is undefined ')\n\n            }\n\n\n\n\n            //SECTION - Printing Outputs, considering conditions, finding values in updated_tokens\n\n\n\n\n            for (var j = 0; j < tokens.length; j++) {\n\n                // Checking for assignment operators\n\n               \n                let mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n                let tokenType = mutable_tokens[j].type\n\n\n\n                var StringVar = []\n\n                let VarWithoutbrackets = RemoveBrackets(mutable_tokens[j].value)\n\n                VarWithoutbrackets = VarWithoutbrackets.replace(/ /g, '')\n\n\n                if (mutable_tokens[j].type == \"SetArrayIndexValue\")\n\n\n\n                {\n\n                    let ValueToSet = mutable_tokens[j].ValueToSet\n\n\n                    //For Numbers[a]=ageone+100 like calculations\n\n                    if (isCalculation(ValueToSet)) {\n\n                        ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n\n\n                        GetArrayorStringElement(mutable_tokens[j].value, updated_tokens, ValueToSet)\n\n\n                    }\n                    //For Numbers[a]=ageone , direct setting\n                    else {\n\n\n                        GetArrayorStringElement(mutable_tokens[j].value, updated_tokens, ValueToSet)\n\n                    }\n\n\n\n\n                }\n\n              else if (mutable_tokens[j].value == '=') {\n\n                    //assigning values to variables\n\n                    let variable = mutable_tokens[j - 1].value\n\n\n\n\n                    //\n                    let varvalue = mutable_tokens[j + 1].value\n\n\n                    //\n\n                    //finding if elements is already assgined in updated tokens\n                    //to solve name='swanand' and name= 'other swanand'\n                    //both shpuld be printed accordinggly\n\n\n\n                    let m = updated_tokens.find((el, i) => el.name == varvalue)\n\n                    varvalue = m != undefined ? m.value : varvalue\n\n\n\n\n                    let n = updated_tokens.find((el, i) => el.name == variable)\n\n\n\n\n                    // \n\n\n\n                    if (n == undefined) {\n\n\n\n                        //to check if the assigned value needs to be calculated. this is futher diveded in two types\n                        if (isCalculation(varvalue))\n\n\n                        {\n\n\n                            //type 1- Age= 2020-2000 \n                            if (isPureEval(varvalue))\n\n\n\n                            {\n\n\n                                let value = eval(varvalue)\n\n                                //write function for this, so repeatable\n                                updated_tokens.push({\n                                    name: variable,\n\n                                    value: value,\n\n                                    identifier: j,\n                                    type: mutable_tokens[j + 1].type\n                                })\n\n\n                            }\n\n                            //type 2- X= ageone+agetwo\n                            else {\n\n\n                                //performing the calculation\n                                // \n                                let value = CalculateValues(varvalue, j, updated_tokens)\n\n\n\n\n                                updated_tokens.push({\n                                    name: variable,\n\n                                    value: value,\n\n                                    identifier: j,\n                                    type: mutable_tokens[j + 1].type\n                                })\n\n\n\n                            }\n\n\n\n                        }\n\n\n                        //if there is no need to calculate, push values as it is\n                        else {\n\n                            updated_tokens.push({\n                                name: variable,\n\n                                value: varvalue,\n\n                                identifier: j,\n                                type: mutable_tokens[j + 1].type\n                            })\n\n\n                        }\n\n\n                    }\n\n\n\n\n                    //if it's already assgined, reassign it with updated value\n                    else {\n\n                        if (isCalculation(varvalue)) {\n\n                            let NewValue = CalculateValues(varvalue, j, updated_tokens)\n                            n.value = NewValue\n\n\n                        } else {\n\n                            n.value = varvalue\n                        }\n\n\n\n\n                    }\n                    //\n                    //\n\n                    // \n\n\n                }\n\n\n\n                else if(tokenType=='AcceptInput')\n                {\n\nlet SetInputValueAs= mutable_tokens[j].AcceptAs\n\n\n\n\n                                    var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n \n(async () => {\n  const response = await prompts({\n    type: 'number',\n    name: 'value',\n    message: 'How old are you?',\n    validate: value => value < 18 ? `Nightclub is 18+ only` : true\n  });\n \n  console.log(response); // => { value: 24 }\n})();\n                                   \n                                   \n\n\n\n\n\n                                   \n                                   \n\n\n                }\n\n\n\n\n\n\n                    else if (tokenType=='function')\n{\n\n//checking if function is invoked somewhere later in the program\nlet functionInvocation=mutable_tokens[j].FunctionInvocationExists\n\n\n\n  if(functionInvocation)\n  {\nlet functionSourceData=[]\n\n let result = HandleBlocks(mutable_tokens, j, functionSourceData )\n\n functionSourceData=result.StoreResult\n\nlet functionArguments=mutable_tokens[j].arguments\nlet functionName=mutable_tokens[j].value\n\nlet passedValues=mutable_tokens[j].passedValues\n\n\n\n//Creating a seperate execution context and setting fucntion context name:value pair in 'functionContextupdated_tokens'\nfunctionArguments.forEach((el,index) => {\n\n\n   let val= passedValues[index]\n   val = val.replace(/\"/g, \"\");\n                    val = val.replace(/'/g, \"\");\n\n                    passedValues[index]=val\n    \nfunctionContextupdated_tokens.push({\n    \n    \n\n\n\n                                    name: el,\n\n                                    value: passedValues[index],\n\n                                    identifier: j+index,\n                                    type: 'value',\n                                    context:'FunctionExecutionContext'\n                            \n\n\n\n})\n\n\n\n\n});\n\n\nvar CompleteTokenValueList=[...updated_tokens,...functionContextupdated_tokens]\nconsole.log('CompleteTokenValueList: ', CompleteTokenValueList);\n\n\nfor(let i=1;i<functionSourceData.length;i++)\n\n{\n\n\nlet el=functionSourceData[i]\n\n\n\n\n\nif(el.value=='प्रिंट')\n\n{\n\n\n IfTokenPrint(mutable_tokens,functionContextupdated_tokens, j+i, this) \n\n\n}\n\nelse  if (el.type== 'condition')\n\n                {\n\n\n\n\n                    let element = functionSourceData[i].value\n\n                    //this function is the first step to calculate value of operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n                    let ConditionValue = GetConditionValue(element, CompleteTokenValueList, i)\n                    //  console.log('j: ',j);\n\n\n\n\n                    //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                    if (ConditionValue == false) {\n\n                        let InitializeLoop = tokens.indexOf(functionSourceData[i])\n\n                        //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                        //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                        let Returnvalue = HandleBlocks(functionSourceData, i)\n\n                        i = Returnvalue.i\n                    }\n\n\n\n\n                }\n\n\n\n  \n\n\n                            //Handling set array element statements in for loop\n                          else  if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                            {\n\n                                let Value = functionSourceData[i].value\n                                //console.log('SourcedataTokens: ', SourcedataTokens);\n                                //                              console.log('Value: ', Value,i);\n\n                                let ValueToSet = functionSourceData[i].ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                    //\n\n                                    Split = Split + ']'\n\n\n                                    ArrayElement = Split\n                                    // console.log('ValueToSet: ', ValueToSet);\n\n                                    NewValueToSet = CalculateValues(ValueToSet, j, CompleteTokenValueList )\n                                    console.log('NewValueToSet: ', NewValueToSet);\n\n\n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, false, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n\n\n                                    let index = Split[1]\n\n\n                                    // setting iterator as per user input \n                                    //for iterator like count=count + 1, Array[count]\n\n                                    let newInterator = 0\n                                    let token = CompleteTokenValueList.find(el => el.name == index)\n\n                                    if (token != undefined) {\n\n                                        newInterator = token.value\n\n                                    } else {\n\n                                        newInterator = iterator\n                                    }\n\n\n\n                                    ArrayElement = CreateArrayElement(Value, newInterator)\n\n\n\n\n                                }\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n                                //console.log('data: ', ArrayElement, data, Split);\n\n\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                    //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, j, CompleteTokenValueList, )\n\n\n\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n\n\n                                    //  console.log('ValueToSet: ', ValueToSet);\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, j, CompleteTokenValueList)\n                                        // console.log('ValueToSet: ', ValueToSet);\n\n                                        // \n\n                                        SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n\n\n\n                                    //SetArrayorStringElement(ArrayElement,CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n                                //might have to add more conditions in the future\n                                else {\n\n                                    let iterator = false\n\n                                    ValueToSet = CalculateValues(ValueToSet, j, CompleteTokenValueList)\n                                    //   console.log('ValueToSet: ', ValueToSet);\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n\n\n\n else  if (functionSourceData[i].type == 'ForLoopStart')\n\n\n\n                {\n\n  var FlagPrimalLoop = 0\n                   \n                    var SourcedataTokens = []\n\n     \n//console.log('updated_tokens: ', updated_tokens);\n\n     let ForLoopMetaData= ForLoopSetMetadata(functionSourceData,i,CompleteTokenValueList)\n     \n\nvar ForLoopSourcedataIndexStart=ForLoopMetaData.ForLoopSourcedataIndexStart\nvar Cycle=ForLoopMetaData.Cycle\nvar OriginalIterator=ForLoopMetaData.OriginalIterator\nvar IterationStart=ForLoopMetaData.IterationStart\nvar iterator=ForLoopMetaData.iterator\nvar element=ForLoopMetaData.element\nvar elementValue=ForLoopMetaData.elementValue\n\n                    function getSourcedata(startIndex, functionSourceData, check, StoreResult) {\n                        //console.log('startIndex, functionSourceData, check, StoreResult: ', startIndex, functionSourceData, check, StoreResult);\n\n\n\n                        let Returnvalue = HandleBlocks(functionSourceData, startIndex, StoreResult)\n                        StoreResult = Returnvalue.StoreResult\n\n\n                        return StoreResult\n\n\n                    }\n\n\n\n\n                    ForLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', ForLoopSourcedataIndexStart)\n                    \n                    //\n\n                    SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, functionSourceData, '}', SourcedataTokens)\n                    \n                    \n                    \n                    SourcedataTokens.forEach(el=>{\n\nel.isNestedLoop=false\n\n                    })\n\n\n                    let FindNestedLoop= SourcedataTokens.find(el=> el.type=='ForLoopStart')\n                   if(FindNestedLoop!=undefined)\n                   {\n  \n                       let NestedLoopindex=SourcedataTokens.indexOf(FindNestedLoop)+2\n                       let NestedLooplength=(SourcedataTokens[NestedLoopindex].EndIndex-SourcedataTokens[NestedLoopindex].startIndex)+1\n\n                       \n                       for(let x=NestedLoopindex;x<NestedLoopindex+NestedLooplength;x++)\n                       {\n\n\n                            SourcedataTokens[x].isNestedLoop=true\n\n                       }\n\n\n                   }\n\n\n\n                  \n\n\n\n\n                    if (element.includes('(') && element.includes(','))\n                    \n\n                    {\n\n                        FlagPrimalLoop = 1\n\n\n                    }\n\n\n\n                 \n               // console.log('Cycle: ', Cycle,IterationStart);\n\n\n                    //Iterating over forloop sourcedata\n                    //this line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                    for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n                        \n\n\n                        let forloopindex = CompleteTokenValueList.find(el => el.name == OriginalIterator)\n                        \n                        \n\n\n\n                        forloopindex.value = iterator\n\n                        //console.log('CompleteTokenValueList: ', CompleteTokenValueList);\n\n                        //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                        if (FlagPrimalLoop = 0) {\n                            ForLoopArrayorStringOutput(elementValue, iterator, CompleteTokenValueList, this)\n\n                        }\n\n\n                        for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                        {\n\n\nlet isNested=SourcedataTokens[i].isNestedLoop\n\n\n\n\nif (SourcedataTokens[i].type == 'ForLoopStart') {\n\n                           var NestedFlagPrimalLoop = 0\n                   \n                    var NestedSourcedataTokens = []      \n\n                    let NestedForLoopMetaData= ForLoopSetMetadata(SourcedataTokens,i,CompleteTokenValueList)\n     \n   //  console.log('NestedForLoopMetaData: ', NestedForLoopMetaData);\n\nvar NestedForLoopSourcedataIndexStart=NestedForLoopMetaData.ForLoopSourcedataIndexStart\nvar NestedCycle=NestedForLoopMetaData.Cycle+1\nvar NestedOriginalIterator=NestedForLoopMetaData.OriginalIterator\nvar NestedIterationStart=NestedForLoopMetaData.IterationStart\nvar Nestediterator=NestedForLoopMetaData.iterator\nvar Nestedelement=NestedForLoopMetaData.element\nvar NestedelementValue=NestedForLoopMetaData.elementValue\n\n                   \n                    function getSourcedata(startIndex, SourcedataTokens, check, StoreResult) {\n                        //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n\n\n                        let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                        StoreResult = Returnvalue.StoreResult\n\n\n                        return StoreResult\n\n\n                    }\n\n\n\n\n                    NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n                    //console.log('ForLoopSourcedataIndexStart: ', ForLoopSourcedataIndexStart);\n                    \n                    \n\n                   NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                   //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n                   \n\n                          \n                   \n                   \n for (Nestediterator = 0; Nestediterator <NestedCycle; Nestediterator++) {\n{\n\nlet y = Nestediterator\n\n\nlet Nestedforloopindex = CompleteTokenValueList.find(el => el.name == NestedOriginalIterator)\n                        //console.log('forloopindex: ', forloopindex);\n\n\n\n                        Nestedforloopindex.value = y\n\n\nfor(let index=0;index<NestedSourcedataTokens.length;index++)\n{\n\n\nlet el= NestedSourcedataTokens[index]\n\nif(el.value== 'प्रिंट')\n\n{\n\n\n\nIfTokenPrint(NestedSourcedataTokens,CompleteTokenValueList, index, this, y, NestedOriginalIterator)\n\n\n}\n\n else if (el.value == '=' && el.isNestedLoop==true) {\n     \n\n                                //assigning values to variables\n                           \n\n                                AssignorUpdateValues(NestedSourcedataTokens, index, CompleteTokenValueList, y, NestedOriginalIterator)\n\n                            }\n\n\n                            else  if (el.type == 'condition' && el.isNestedLoop==true)\n\n\n\n                            {\n\n\n\n\n                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                let ConditionStartIndex = index\n                                let condition = NestedSourcedataTokens[index].value\n                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                //value of i depends on the conditions\n\n                                if (condition.includes('||') || condition.includes('&&'))\n\n                                {\n\n\n                                    let value = GetConditionValue(condition, CompleteTokenValueList, index)\n                                    \n\n\n\n                                    if (value == false) {\n\n\n\n                                        let BlockLength = 0\n                                        let BlockStart = 0\n\n                                        while (NestedSourcedataTokens[index].value != '{')\n\n                                        {\n\n                                            if (NestedSourcedataTokens[index + 1].value == '{')\n\n                                            {\n\n\n                                                BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                                index = BlockLength + index + 1\n\n\n\n\n                                                break;\n\n                                            }\n\n\n\n                                            index++\n                                        }\n\n                                    } else {\n\n\n                                        index = index\n\n\n                                    }\n\n\n\n\n                                } else {\nconsole.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n                                console.log('index : ', index );\n\n\n                                    let x= HandleConditions(NestedSourcedataTokens, index, CompleteTokenValueList);\n                                    console.log('x: ', x);\n                                    \n\n\n\n                                    if (x != undefined) {\n\n\n                                        index = x\n                                        \n\n\n                                    } else {\n                                        index = ConditionStartIndex\n                                        //console.log('i: ', i);\n                                    }\n\n                                }\n\n                                console.log('index : ', index );\n\n\n\n\n                            }\n\n\n                        \n                    //console.log('i: ', i);\n\n                   // i = i + NestedSourcedataTokens.length\n                    //console.log('i: ', i);\n\n\n else  if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop==true)\n\n\n\n\n                            {\n\n                                let Value = el.value\n                                //console.log('SourcedataTokens: ', SourcedataTokens);\n                                //                              console.log('Value: ', Value,i);\n\n                                let ValueToSet = el.ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n                                \n\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.ioin('[')\n                                    \n                                    //\n\n                                    Split = Split + ']'\n\n\n                                    ArrayElement = Split\n                                    // console.log('ValueToSet: ', ValueToSet);\n\n                                    NewValueToSet = CalculateValues(ValueToSet, index, updated_tokens)\n\n\n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, false, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n\n\n                                    let index = Split[1]\n\n\n                                    // setting iterator as per user input \n                                    //for iterator like count=count + 1, Array[count]\n\n                                    let newInterator = 0\n                                    let token = updated_tokens.find(el => el.name == index)\n\n                                    if (token != undefined) {\n\n                                        newInterator = token.value\n\n                                    } else {\n\n                                        newInterator = iterator\n                                    }\n\n\n\n                                    ArrayElement = CreateArrayElement(Value, newInterator)\n\n\n\n\n                                }\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n                                //console.log('data: ', ArrayElement, data, Split);\n\n\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                    //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, j, updated_tokens, )\n\n\n\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n\n\n                                    //  console.log('ValueToSet: ', ValueToSet);\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                        // console.log('ValueToSet: ', ValueToSet);\n\n                                        // \n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n\n\n\n                                    //SetArrayorStringElement(ArrayElement,updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n                                //might have to add more conditions in the future\n                                else {\n\n                                    let iterator = false\n\n                                    ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                    //   console.log('ValueToSet: ', ValueToSet);\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n                            }\n\n\n\n\n}\n\n\n\n\n\n\n\n                            else if (SourcedataTokens[i].value == '='  && isNested==false) {\n                                \n\n                                //assigning values to variables\n\n\n                                AssignorUpdateValues(SourcedataTokens, i, CompleteTokenValueList, iterator, OriginalIterator)\n                                \n\n\n\n                            }\n\n\n\n\n                            //Handling print statements in for loop\n\n                          else  if (SourcedataTokens[i].value == 'प्रिंट' && isNested==false)\n\n\n\n\n                            {\n\n\n                                //for operations like print(array[3])\n\n                                // console.log('for looop prints: ', functionSourceData[i],i);\n\n\n                                IfTokenPrint(SourcedataTokens,CompleteTokenValueList, i, this, iterator, OriginalIterator)\n\n                                //\n\n\n                            }\n\n\n\n                            //Handling set array element statements in for loop\n                          else  if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                            {\n\n                                let Value = SourcedataTokens[i].value\n                                //console.log('SourcedataTokens: ', SourcedataTokens);\n                                //                              console.log('Value: ', Value,i);\n\n                                let ValueToSet = SourcedataTokens[i].ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                    //\n\n                                    Split = Split + ']'\n\n\n                                    ArrayElement = Split\n                                    // console.log('ValueToSet: ', ValueToSet);\n\n                                    NewValueToSet = CalculateValues(ValueToSet, j, updated_tokens, )\n\n\n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, false, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n\n\n                                    let index = Split[1]\n\n\n                                    // setting iterator as per user input \n                                    //for iterator like count=count + 1, Array[count]\n\n                                    let newInterator = 0\n                                    let token = updated_tokens.find(el => el.name == index)\n\n                                    if (token != undefined) {\n\n                                        newInterator = token.value\n\n                                    } else {\n\n                                        newInterator = iterator\n                                    }\n\n\n\n                                    ArrayElement = CreateArrayElement(Value, newInterator)\n\n\n\n\n                                }\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n                                //console.log('data: ', ArrayElement, data, Split);\n\n\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                    //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, j, updated_tokens, )\n\n\n\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n\n\n                                    //  console.log('ValueToSet: ', ValueToSet);\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                        // console.log('ValueToSet: ', ValueToSet);\n\n                                        // \n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n\n\n\n                                    //SetArrayorStringElement(ArrayElement,updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n                                //might have to add more conditions in the future\n                                else {\n\n                                    let iterator = false\n\n                                    ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                    //   console.log('ValueToSet: ', ValueToSet);\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n\n\n                            // Handling CONDITIONAL statements in for loop\n\n                          else  if (SourcedataTokens[i].type == 'condition')\n\n\n\n                            {\n\n\n\n\n                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                let ConditionStartIndex = i\n                                let condition = SourcedataTokens[i].value\n                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                //value of i depends on the conditions\n\n                                if (condition.includes('||') || condition.includes('&&'))\n\n                                {\n\n\n                                    let value = GetConditionValue(condition, updated_tokens, i)\n                                    \n\n\n\n                                    if (value == false) {\n\n\n\n                                        let BlockLength = 0\n                                        let BlockStart = 0\n\n                                        while (SourcedataTokens[i].value != '{')\n\n                                        {\n\n                                            if (SourcedataTokens[i + 1].value == '{')\n\n                                            {\n\n\n                                                BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                                                i = BlockLength + i + 1\n\n\n\n\n                                                break;\n\n                                            }\n\n\n\n                                            i++\n                                        }\n\n                                    } else {\n\n\n                                        i = i\n\n\n                                    }\n\n\n\n\n                                } else {\n\n\n                                    i = HandleConditions(SourcedataTokens, i, CompleteTokenValueList);\n\n\n\n                                    if (i != undefined) {\n\n\n                                        i = i\n\n\n                                    } else {\n                                        i = ConditionStartIndex\n                                        //console.log('i: ', i);\n                                    }\n\n                                }\n\n\n\n\n                            }\n\n\n                        }\n\n\n\n                    }\n                    //console.log('j: ', j);\n\n                    i = i + SourcedataTokens.length\n                    //console.log('j: ', j);\n\n\n                }\n\n\n\n\n\n\n\n\n\n\n                                           else  if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                            {\n\n                                let Value = functionSourceData[i].value\n                                \n                                //console.log('SourcedataTokens: ', SourcedataTokens);\n                                //                              console.log('Value: ', Value,i);\n\n                                let ValueToSet = functionSourceData[i].ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                    //\n\n                                    Split = Split + ']'\n\n\n                                    ArrayElement = Split\n                                    // console.log('ValueToSet: ', ValueToSet);\n\n                                    NewValueToSet = CalculateValues(ValueToSet, i, CompleteTokenValueList, )\n\n\n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, false, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n\n\n                                    let index = Split[1]\n\n\n                                    // setting iterator as per user input \n                                    //for iterator like count=count + 1, Array[count]\n\n                                    let newInterator = 0\n                                    let token = CompleteTokenValueList.find(el => el.name == index)\n\n                                    if (token != undefined) {\n\n                                        newInterator = token.value\n\n                                    } else {\n\n                                        newInterator = iterator\n                                    }\n\n\n\n                                    ArrayElement = CreateArrayElement(Value, newInterator)\n                                    console.log('ArrayElement: ', ArrayElement);\n\n\n\n\n                                }\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n                                //console.log('data: ', ArrayElement, data, Split);\n\n\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                    //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, i, CompleteTokenValueList, )\n\n\n\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n\n\n                                    //  console.log('ValueToSet: ', ValueToSet);\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, i, CompleteTokenValueList)\n                                        // console.log('ValueToSet: ', ValueToSet);\n\n                                        // \n\n                                        SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n\n\n\n                                    //SetArrayorStringElement(ArrayElement,CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n                                //might have to add more conditions in the future\n                                else {\n\n                                    let iterator = false\n\n                                    ValueToSet = CalculateValues(ValueToSet, i, CompleteTokenValueList)\n                                    //   console.log('ValueToSet: ', ValueToSet);\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n\n\n\n\n\n else if (functionSourceData[i].type == 'WhileLoopStart') {\n     console.log('functionSourceData: ', functionSourceData);\n\n\n                    let TokensCurrentIndex = i + 3\n\n                    \n\n                    let ConditionValue = false\n\n                    let element = functionSourceData[i + 1].value\n\n                    let ExtratcedVariable = []\n\n                    let variable = ''\n                    let WhileLoopSourcedataIndexStart = 0\n                    let WhileLoopSourcedataTokens = []\n\n\n\n                    for (let i = 0; i < element.length; i++) {\n                        let x = element.charAt(i)\n\n\n                        if (isVariable(x))\n\n                        {\n\n                            variable = variable + x\n\n\n\n                        }\n                        if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n\n                            let token = CompleteTokenValueList.find(el => el.name == variable)\n\n                            ExtratcedVariable.push({\n                                variable: variable,\n                                value: token.value\n\n                            })\n\n\n                            variable = ''\n\n\n                        }\n\n                    }\n\n\n\n\n                    function getWhileLoopSourcedata(startIndex, functionSourceData, check, StoreResult) {\n\n\n\n                        StoreResult = HandleBlocks(functionSourceData, startIndex, StoreResult)\n\n\n\n                        return StoreResult\n\n\n\n\n                    }\n\n\n\n\n                    WhileLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', WhileLoopSourcedataIndexStart)\n                    console.log('WhileLoopSourcedataIndexStart: ', WhileLoopSourcedataIndexStart);\n                    //\n                    WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, functionSourceData, '}', WhileLoopSourcedataTokens).StoreResult\n                    console.log('WhileLoopSourcedataTokens: ', WhileLoopSourcedataTokens.length);\n\n\n\n\n                    //constantly accessing the conditionvalue\n\n                    while (GetConditionValue(element, CompleteTokenValueList, j + 1)) {\n\n                        for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n                           \n\n\n\n\n                            //SECTION while loop context\n\n                            if (WhileLoopSourcedataTokens[i].value == '=') {\n\n\n\n\n                                AssignorUpdateValues(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                                //\n\n                                // \n\n\n                            }\n\n\n\n                            // Handling CONDITIONAL statements in for loop\n\n                        else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                            {\n\n\n\n\n                               let index= HandleConditions(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n                             \n                             if(index!=undefined)\n                             {\ni=index\n\n\n                             }\n\n\n\n                             else{\n                                 i=i\n                             }\n                               \n                              \n\n                                 \n                                   \n                     \n\n\n                                }\n\n\n                           \n                        \n\n\n\n\n                        else  if (WhileLoopSourcedataTokens[i].value == 'प्रिंट')\n                          \n                          \n\n\n\n                            {\n\n\n                                IfTokenPrint(WhileLoopSourcedataTokens,CompleteTokenValueList, i, this) //for operations like print(array[3])\n\n\n\n\n                            }\n\n\n\n                                           else  if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                            {\n\n                                let Value = WhileLoopSourcedataTokens[i].value\n                                \n                                //console.log('SourcedataTokens: ', SourcedataTokens);\n                                //                              console.log('Value: ', Value,i);\n\n                                let ValueToSet = WhileLoopSourcedataTokens[i].ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                    //\n\n                                    Split = Split + ']'\n\n\n                                    ArrayElement = Split\n                                    // console.log('ValueToSet: ', ValueToSet);\n\n                                    NewValueToSet = CalculateValues(ValueToSet, i, CompleteTokenValueList, )\n\n\n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, false, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n\n\n                                    let index = Split[1]\n\n\n                                    // setting iterator as per user input \n                                    //for iterator like count=count + 1, Array[count]\n\n                                    let newInterator = 0\n                                    let token = CompleteTokenValueList.find(el => el.name == index)\n\n                                    if (token != undefined) {\n\n                                        newInterator = token.value\n\n                                    } else {\n\n                                        newInterator = iterator\n                                    }\n\n\n\n                                    ArrayElement = CreateArrayElement(Value, newInterator)\n                                    console.log('ArrayElement: ', ArrayElement);\n\n\n\n\n                                }\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n                                //console.log('data: ', ArrayElement, data, Split);\n\n\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                    //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, i, CompleteTokenValueList, )\n\n\n\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n\n\n                                    //  console.log('ValueToSet: ', ValueToSet);\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, i, CompleteTokenValueList)\n                                        // console.log('ValueToSet: ', ValueToSet);\n\n                                        // \n\n                                        SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n\n\n\n                                    //SetArrayorStringElement(ArrayElement,CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n                                //might have to add more conditions in the future\n                                else {\n\n                                    let iterator = false\n\n                                    ValueToSet = CalculateValues(ValueToSet, i, CompleteTokenValueList)\n                                    //   console.log('ValueToSet: ', ValueToSet);\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, CompleteTokenValueList, iterator, ValueToSet, tokens)\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n\n                     \n                        }\n\n\n                    }\n\n                   i=i+1+WhileLoopSourcedataTokens.length+1\n                   console.log('j: ', i);\n                }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n\n\n\n\n  }                     \n\n\n//skipping parsing index so that function context is run by single entity and global execution doesn't run this code too\n    j=mutable_tokens[j+1].EndIndex\n\n\n\n\n\n}\n\n              else  if (tokenType == 'condition')\n\n                {\n\n\n\n\n                    let element = mutable_tokens[j].value\n\n                    //this function is the first step to calculate value of operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n                    let ConditionValue = GetConditionValue(element, updated_tokens, j)\n                    // console.log('ConditionValue: ', ConditionValue);\n                    //  console.log('j: ',j);\n\n\n\n\n                    //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                    if (ConditionValue == false) {\n\n                        let InitializeLoop = tokens.indexOf(mutable_tokens[j])\n\n                        //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                        //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                        let Returnvalue = HandleBlocks(mutable_tokens, j)\n\n                        j = Returnvalue.j\n                    }\n\n\n\n\n                }\n\n               else if (token == 'प्रिंट')\n\n\n                {\n\n                    //console.log('normal prints', mutable_tokens[j+1]);\n                    IfTokenPrint(mutable_tokens,updated_tokens, j, this) //for operations like print(array[3])\n\n\n\n\n                }\n\n               else if (tokenType == 'WhileLoopStart') {\n\n\n                    let TokensCurrentIndex = j + 3\n\n                    let ConditionValue = false\n\n                    let element = mutable_tokens[j + 1].value\n\n                    let ExtratcedVariable = []\n\n                    let variable = ''\n                    let WhileLoopSourcedataIndexStart = 0\n                    let WhileLoopSourcedataTokens = []\n\n\n\n                    for (let i = 0; i < element.length; i++) {\n                        let x = element.charAt(i)\n\n\n                        if (isVariable(x))\n\n                        {\n\n                            variable = variable + x\n\n\n\n                        }\n                        if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n\n                            let token = updated_tokens.find(el => el.name == variable)\n\n                            ExtratcedVariable.push({\n                                variable: variable,\n                                value: token.value\n\n                            })\n\n\n                            variable = ''\n\n\n                        }\n\n                    }\n\n\n\n\n                    function getWhileLoopSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n\n\n\n                        StoreResult = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n\n\n\n                        return StoreResult\n\n\n\n\n                    }\n\n\n\n\n                    WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart)\n                    //\n                    WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, '}', WhileLoopSourcedataTokens).StoreResult\n\n\n\n\n                    //constantly accessing the conditionvalue\n\n                    while (GetConditionValue(element, updated_tokens, j + 1)) {\n\n                        for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n                           \n\n\n\n\n                            //SECTION while loop context\n\n                            if (WhileLoopSourcedataTokens[i].value == '=') {\n\n\n\n\n                                AssignorUpdateValues(WhileLoopSourcedataTokens, i, updated_tokens)\n\n                                //\n\n                                // \n\n\n                            }\n\n\n\n                            // Handling CONDITIONAL statements in for loop\n\n                        else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                            {\n\n\n\n\n                               let index= HandleConditions(WhileLoopSourcedataTokens, i, updated_tokens)\n                               console.log('index: ', index);\n                             \n                             if(index!=undefined)\n                             {\ni=index\n\n\n                             }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             else{\n                                 i=i\n                             }\n                               \n                              \n\n                                 \n                                   \n                     \n\n\n                                }\n\n\n                           \n                        \n\n\n\n\n                        else  if (WhileLoopSourcedataTokens[i].value == 'प्रिंट')\n                          \n                          \n\n\n\n                            {\n\n\n                                IfTokenPrint(WhileLoopSourcedataTokens,updated_tokens, i, this) //for operations like print(array[3])\n\n\n\n\n                            }\n\n\n\n                                           else  if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                            {\n\n                                let Value = WhileLoopSourcedataTokens[i].value\n                                \n                                //console.log('SourcedataTokens: ', SourcedataTokens);\n                                //                              console.log('Value: ', Value,i);\n\n                                let ValueToSet = WhileLoopSourcedataTokens[i].ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                    //\n\n                                    Split = Split + ']'\n\n\n                                    ArrayElement = Split\n                                    // console.log('ValueToSet: ', ValueToSet);\n\n                                    NewValueToSet = CalculateValues(ValueToSet, j, updated_tokens, )\n\n\n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, false, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n\n\n                                    let index = Split[1]\n\n\n                                    // setting iterator as per user input \n                                    //for iterator like count=count + 1, Array[count]\n\n                                    let newInterator = 0\n                                    let token = updated_tokens.find(el => el.name == index)\n\n                                    if (token != undefined) {\n\n                                        newInterator = token.value\n\n                                    } else {\n\n                                        newInterator = iterator\n                                    }\n\n\n\n                                    ArrayElement = CreateArrayElement(Value, newInterator)\n                                    console.log('ArrayElement: ', ArrayElement);\n\n\n\n\n                                }\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n                                //console.log('data: ', ArrayElement, data, Split);\n\n\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                    //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, j, updated_tokens, )\n\n\n\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n\n\n                                    //  console.log('ValueToSet: ', ValueToSet);\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                        // console.log('ValueToSet: ', ValueToSet);\n\n                                        // \n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n\n\n\n                                    //SetArrayorStringElement(ArrayElement,updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n                                //might have to add more conditions in the future\n                                else {\n\n                                    let iterator = false\n\n                                    ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                    //   console.log('ValueToSet: ', ValueToSet);\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n\n                     \n                        }\n\n\n                    }\n                }\n\n\n\n\n              else  if (tokenType == 'ForLoopStart')\n\n\n\n                {\n\n  var FlagPrimalLoop = 0\n                   \n                    var SourcedataTokens = []\n\n     \n//console.log('updated_tokens: ', updated_tokens);\n\n     let ForLoopMetaData= ForLoopSetMetadata(mutable_tokens,j,updated_tokens)\n     \n     //console.log('ForLoopMetaData: ', ForLoopMetaData);\n\nvar ForLoopSourcedataIndexStart=ForLoopMetaData.ForLoopSourcedataIndexStart\nvar Cycle=ForLoopMetaData.Cycle\nvar OriginalIterator=ForLoopMetaData.OriginalIterator\nvar IterationStart=ForLoopMetaData.IterationStart\nvar iterator=ForLoopMetaData.iterator\nvar element=ForLoopMetaData.element\nvar elementValue=ForLoopMetaData.elementValue\n\n                    function getSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n                        //console.log('startIndex, mutable_tokens, check, StoreResult: ', startIndex, mutable_tokens, check, StoreResult);\n\n\n\n                        let Returnvalue = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n                        StoreResult = Returnvalue.StoreResult\n\n\n                        return StoreResult\n\n\n                    }\n\n\n\n\n                    ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart)\n                    \n                    //\n\n                    SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, '}', SourcedataTokens)\n                    //console.log('SourcedataTokens: ', SourcedataTokens);\n                    \n                    \n                    \n                    SourcedataTokens.forEach(el=>{\n\nel.isNestedLoop=false\n\n                    })\n\n\n                    let FindNestedLoop= SourcedataTokens.find(el=> el.type=='ForLoopStart')\n                   if(FindNestedLoop!=undefined)\n                   {\n  \n                       let NestedLoopindex=SourcedataTokens.indexOf(FindNestedLoop)+2\n                       let NestedLooplength=(SourcedataTokens[NestedLoopindex].EndIndex-SourcedataTokens[NestedLoopindex].startIndex)+1\n\n                       \n                       for(let x=NestedLoopindex;x<NestedLoopindex+NestedLooplength;x++)\n                       {\n\n\n                            SourcedataTokens[x].isNestedLoop=true\n\n                       }\n\n\n                   }\n\n\n\n                  \n\n\n\n\n                    if (element.includes('(') && element.includes(','))\n                    \n\n                    {\n\n                        FlagPrimalLoop = 1\n\n\n                    }\n\n\n\n                 \n               // console.log('Cycle: ', Cycle,IterationStart);\n\n\n                    //Iterating over forloop sourcedata\n                    //this line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                    for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n                        \n\n\n                        let forloopindex = updated_tokens.find(el => el.name == OriginalIterator)\n                        \n\n\n\n                        forloopindex.value = iterator\n\n                        //console.log('updated_tokens: ', updated_tokens);\n\n                        //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                        if (FlagPrimalLoop = 0) {\n                            ForLoopArrayorStringOutput(elementValue, iterator, updated_tokens, this)\n\n                        }\n\n\n                        for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                        {\n\n\nlet isNested=SourcedataTokens[i].isNestedLoop\n\n\nif (SourcedataTokens[i].type == 'ForLoopStart') {\n\n                           var NestedFlagPrimalLoop = 0\n                   \n                    var NestedSourcedataTokens = []      \n\n                    let NestedForLoopMetaData= ForLoopSetMetadata(SourcedataTokens,i,updated_tokens)\n     \n   //  console.log('NestedForLoopMetaData: ', NestedForLoopMetaData);\n\nvar NestedForLoopSourcedataIndexStart=NestedForLoopMetaData.ForLoopSourcedataIndexStart\nvar NestedCycle=NestedForLoopMetaData.Cycle+1\nvar NestedOriginalIterator=NestedForLoopMetaData.OriginalIterator\nvar NestedIterationStart=NestedForLoopMetaData.IterationStart\nvar Nestediterator=NestedForLoopMetaData.iterator\nvar Nestedelement=NestedForLoopMetaData.element\nvar NestedelementValue=NestedForLoopMetaData.elementValue\n\n                   \n                    function getSourcedata(startIndex, SourcedataTokens, check, StoreResult) {\n                        //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n\n\n                        let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                        StoreResult = Returnvalue.StoreResult\n\n\n                        return StoreResult\n\n\n                    }\n\n\n\n\n                    NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n                    //console.log('ForLoopSourcedataIndexStart: ', ForLoopSourcedataIndexStart);\n                    \n                    \n\n                   NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                   //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n                   \n\n                          \n                   \n                   \n for (Nestediterator = 0; Nestediterator <NestedCycle; Nestediterator++) {\n{\n\nlet y = Nestediterator\n\n\nlet Nestedforloopindex = updated_tokens.find(el => el.name == NestedOriginalIterator)\n                        //console.log('forloopindex: ', forloopindex);\n\n\n\n                        Nestedforloopindex.value = y\n\n\nfor(let index=0;index<NestedSourcedataTokens.length;index++)\n{\n\n\nlet el= NestedSourcedataTokens[index]\n\nif(el.value== 'प्रिंट')\n\n{\n\n\n\nIfTokenPrint(NestedSourcedataTokens,updated_tokens, index, this, y, NestedOriginalIterator)\n\n\n}\n\n else if (el.value == '=' && el.isNestedLoop==true) {\n     \n\n                                //assigning values to variables\n                           \n\n                                AssignorUpdateValues(NestedSourcedataTokens, index, updated_tokens, y, NestedOriginalIterator)\n\n                            }\n\n\n                            else  if (el.type == 'condition' && el.isNestedLoop==true)\n\n\n\n                            {\n\n\n\n\n                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                let ConditionStartIndex = index\n                                let condition = NestedSourcedataTokens[index].value\n                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                //value of i depends on the conditions\n\n                                if (condition.includes('||') || condition.includes('&&'))\n\n                                {\n\n\n                                    let value = GetConditionValue(condition, updated_tokens, index)\n                                    \n\n\n\n                                    if (value == false) {\n\n\n\n                                        let BlockLength = 0\n                                        let BlockStart = 0\n\n                                        while (NestedSourcedataTokens[index].value != '{')\n\n                                        {\n\n                                            if (NestedSourcedataTokens[index + 1].value == '{')\n\n                                            {\n\n\n                                                BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                                index = BlockLength + index + 1\n\n\n\n\n                                                break;\n\n                                            }\n\n\n\n                                            index++\n                                        }\n\n                                    } else {\n\n\n                                        index = index\n\n\n                                    }\n\n\n\n\n                                } else {\nconsole.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n                                console.log('index : ', index );\n\n\n                                    let x= HandleConditions(NestedSourcedataTokens, index, updated_tokens);\n                                    console.log('x: ', x);\n                                    \n\n\n\n                                    if (x != undefined) {\n\n\n                                        index = x\n                                        \n\n\n                                    } else {\n                                        index = ConditionStartIndex\n                                        //console.log('i: ', i);\n                                    }\n\n                                }\n\n                                console.log('index : ', index );\n\n\n\n\n                            }\n\n\n                        \n                    //console.log('j: ', j);\n\n                   // i = i + NestedSourcedataTokens.length\n                    //console.log('i: ', i);\n\n\n else  if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop==true)\n\n\n\n\n                            {\n\n                                let Value = el.value\n                                //console.log('SourcedataTokens: ', SourcedataTokens);\n                                //                              console.log('Value: ', Value,i);\n\n                                let ValueToSet = el.ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n                                \n\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                    \n                                    //\n\n                                    Split = Split + ']'\n\n\n                                    ArrayElement = Split\n                                    // console.log('ValueToSet: ', ValueToSet);\n\n                                    NewValueToSet = CalculateValues(ValueToSet, index, updated_tokens)\n\n\n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, false, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n\n\n                                    let index = Split[1]\n\n\n                                    // setting iterator as per user input \n                                    //for iterator like count=count + 1, Array[count]\n\n                                    let newInterator = 0\n                                    let token = updated_tokens.find(el => el.name == index)\n\n                                    if (token != undefined) {\n\n                                        newInterator = token.value\n\n                                    } else {\n\n                                        newInterator = iterator\n                                    }\n\n\n\n                                    ArrayElement = CreateArrayElement(Value, newInterator)\n\n\n\n\n                                }\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n                                //console.log('data: ', ArrayElement, data, Split);\n\n\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                    //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, j, updated_tokens, )\n\n\n\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n\n\n                                    //  console.log('ValueToSet: ', ValueToSet);\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                        // console.log('ValueToSet: ', ValueToSet);\n\n                                        // \n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n\n\n\n                                    //SetArrayorStringElement(ArrayElement,updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n                                //might have to add more conditions in the future\n                                else {\n\n                                    let iterator = false\n\n                                    ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                    //   console.log('ValueToSet: ', ValueToSet);\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n\n}\n\n\n\n\n\n\n                            }\n\n\n\n\n}\n\n\n\n\n\n\n\n\n                            else if (SourcedataTokens[i].value == '='  && isNested==false) {\n\n                                //assigning values to variables\n\n                                AssignorUpdateValues(SourcedataTokens, i, updated_tokens, iterator, OriginalIterator)\n\n                            }\n\n\n\n\n                            //Handling print statements in for loop\n\n                          else  if (SourcedataTokens[i].value == 'प्रिंट' && isNested==false)\n\n\n\n\n                            {\n\n                                //for operations like print(array[3])\n\n                                // console.log('for looop prints: ', SourcedataTokens[i],i);\n\n\n                                IfTokenPrint(SourcedataTokens,updated_tokens, i, this, iterator, OriginalIterator)\n\n                                //\n\n\n                            }\n\n\n\n                            //Handling set array element statements in for loop\n                          else  if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                            {\n\n                                let Value = SourcedataTokens[i].value\n                                //console.log('SourcedataTokens: ', SourcedataTokens);\n                                //                              console.log('Value: ', Value,i);\n\n                                let ValueToSet = SourcedataTokens[i].ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                    //\n\n                                    Split = Split + ']'\n\n\n                                    ArrayElement = Split\n                                    // console.log('ValueToSet: ', ValueToSet);\n\n                                    NewValueToSet = CalculateValues(ValueToSet, j, updated_tokens, )\n\n\n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, false, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n\n\n                                    let index = Split[1]\n\n\n                                    // setting iterator as per user input \n                                    //for iterator like count=count + 1, Array[count]\n\n                                    let newInterator = 0\n                                    let token = updated_tokens.find(el => el.name == index)\n\n                                    if (token != undefined) {\n\n                                        newInterator = token.value\n\n                                    } else {\n\n                                        newInterator = iterator\n                                    }\n\n\n\n                                    ArrayElement = CreateArrayElement(Value, newInterator)\n\n\n\n\n                                }\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n                                //console.log('data: ', ArrayElement, data, Split);\n\n\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                    //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, j, updated_tokens, )\n\n\n\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n\n\n                                    //  console.log('ValueToSet: ', ValueToSet);\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                        // console.log('ValueToSet: ', ValueToSet);\n\n                                        // \n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n\n\n\n                                    //SetArrayorStringElement(ArrayElement,updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n                                //might have to add more conditions in the future\n                                else {\n\n                                    let iterator = false\n\n                                    ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                    //   console.log('ValueToSet: ', ValueToSet);\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n\n\n                            // Handling CONDITIONAL statements in for loop\n\n                          else  if (SourcedataTokens[i].type == 'condition')\n\n\n\n                            {\n\n\n\n\n                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                let ConditionStartIndex = i\n                                let condition = SourcedataTokens[i].value\n                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                //value of i depends on the conditions\n\n                                if (condition.includes('||') || condition.includes('&&'))\n\n                                {\n\n\n                                    let value = GetConditionValue(condition, updated_tokens, i)\n\n\n\n                                    if (value == false) {\n\n\n\n                                        let BlockLength = 0\n                                        let BlockStart = 0\n\n                                        while (SourcedataTokens[i].value != '{')\n\n                                        {\n\n                                            if (SourcedataTokens[i + 1].value == '{')\n\n                                            {\n\n\n                                                BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                                                i = BlockLength + i + 1\n\n\n\n\n                                                break;\n\n                                            }\n\n\n\n                                            i++\n                                        }\n\n                                    } else {\n\n\n                                        i = i\n\n\n                                    }\n\n\n\n\n                                } else {\n\n\n                                    i = HandleConditions(SourcedataTokens, i, updated_tokens);\n\n\n\n                                    if (i != undefined) {\n\n\n                                        i = i\n\n\n                                    } else {\n                                        i = ConditionStartIndex\n                                        //console.log('i: ', i);\n                                    }\n\n                                }\n\n\n\n\n                            }\n\n\n                        }\n\n\n\n                    }\n                    //console.log('j: ', j);\n\n                    j = j + SourcedataTokens.length\n                    //console.log('j: ', j);\n\n\n                }\n\n                //END FOR LOOP EXECUTION\n\n\n\n\n            }\n\n\n\n\n\n\n\n            var t1 = performance.now()\n            if (this.output != '') {\n                this.TimeTaken = \"Compiled Succesfully in \" + (t1 - t0).toPrecision(4) + \" ms.\"\n\n            }\n\n\n\n            this.linebylineOutput = this.output.split('\\n')\n\n\n            this.linebylineOutput = this.linebylineOutput.filter(function(item) {\n                return item !== \"\"\n            })\n\n\n\n\n\n\n\n            //SECTION - Calculating remaining values\n\n\n            //so that replace x with values\n\n            /*\n                        updated_tokens.forEach((el, i) => {\n                            \n\n\n                            let element = el.value\n\n\n                            //removing the \"(\"\" and \")\"\n\n\n                            var CleanedElement = RemoveBrackets(element)\n\n                            operation = ''\n\n\n\n                            //why pureeval?\n                            // operations like 50+60 were set as [5,0,+,6,0] instead of [50,+,60]. basically direct calculation was not working\n                            //pureeval finds such pure operations and then calculate them to directly set their value\n                            //this shit is only for pureoperations\n                            let pureval = /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedElement)\n\n                            if (pureval == true) {\n\n\n\n                                updated_tokens[i].value = eval(updated_tokens[i].value)\n\n\n                            }\n\n\n\n\n                            if (isCalculation(CleanedElement) == true && !pureval) {\n\n                                terms = CleanedElement.split('')\n\n\n\n                            }\n\n\n\n\n                        })\n\n\n\n\n                        //\n\n                        // performing calculations\n\n\n\n\n                        updated_tokens.forEach((el, i) => {\n\n                            var indextoChange = '' //to know which value to replace like \"anna+dada-bad\" with \"5+6-7\"\n\n\n\n                            let element = el.value // reading the current value, for lon string variable names it's still like \"anna+dada-bad\"\n                            element = element.toString()\n                            var StringVar = []\n                            // \n\n                            let pureval = /^([-+]?[a-z]*\\.?[a-z]+[\\/\\+\\-\\*])+([-+]?[a-z]*\\.?[a-z]+)*$/gm.test(element)\n\n\n\n                            if (element.includes('>') || element.includes('<') || element.includes('==')) {\n\n\n\n                                StringVar = SplitElementsArray(element)\n\n\n\n                                StringVar = SetValues(StringVar, updated_tokens)\n\n\n                                UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n\n\n                            }\n\n\n                            //finding operations like a+b-c\n                            if (pureval == true || element.charAt(0) == \"(\") {\n\n                                // \n\n\n                                StringVar = SplitElementsArray(element)\n                                StringVar = SetValues(StringVar, updated_tokens)\n                                UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n                            }\n\n\n\n\n                        })\n\n\n\n\n                        /*\n                         ReIntializedVariables.forEach(el=>{\n\n                        let flag=0\n                        let SkipIndex=0\n\n                        for(let m=0;m<updated_tokens.length;m++)\n                        {\n                            \n                        if(el.name==updated_tokens[m].name && flag==0)\n                        {\n\n\n                        if(el.value.charAt(0)=='\"')\n                        {\n\n\n                            let BuiltString= BuildString(el.value, )\n\n                            \n                        }\n                        flag=1;\n                        updated_tokens[m].value=el.value;\n\n\n                        \n\n                        SkipIndex=m\n\n\n                        }\n\n                        //\n\n                        if( m!=SkipIndex && flag==1 && el.name==updated_tokens[m].name)\n\n                        {\n\n                        updated_tokens.splice(m,1)\n\n                        }\n\n\n                        }\n\n\n\n\n                        })\n                        */\n\n\n\n\n            //SECTION - Iterating over tokens and then PRINTING FINAL using values stored in updated tokens\n\n            /*        \n\n            for (var j = 0; j < tokens.length; j++) {\n\n\n                var mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n             \n\n                if (token == 'प्रिंट' )\n\n                {\n\n                    var b = RemoveBrackets(mutable_tokens[j+1].value)\n\n\n\n\n                    variables_array.push(b)\n\n                    \n\n                 \n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n                    updated_tokens.forEach((el, i) => {\n\n                        if (el.name == b ) {\n\n\n\n                            this.output = this.output + el.value + \"\\n\";\n\n                            assigned_variables.push(el.name);\n\n                           \n\n\n                        }\n\n\n\n                        // work to be continued\n\n                    })\n\n                    \n\n                    \n\n                }\n\n\n                //Handling Conditions\n\n                if(mutable_tokens[j].type==\"condition\")\n                {\n\n\n\n                   \n\n                    let token= updated_tokens.find(el=> el.originalvalue==mutable_tokens[j].value)\n\n\n\n                    let ConditionValue=token.value\n\n                  \n\n                   if(ConditionValue==false)\n                   {\n\nlet InitializeLoop= tokens.indexOf(mutable_tokens[j])\n\n\n\n\n\nwhile(mutable_tokens[j+1].value!='}' )\n{\n\n\n\n    let x= mutable_tokens[j+1].value.length\n    \n    \ntokens.splice(j+1, 1);\n \n\n    j++;\n\n\n}\n\n\n\n\n                   }\n\n\n                }\n\n\n                if(token == 'प्रिंट' && /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(mutable_tokens[j+1].value) )\n                {\n \n                let a= eval(mutable_tokens[j+1].value)\n\n                this.output = this.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n                \n\n        \n              \n\n\n\n\n      // this is to handle प्रिंट (\"Age is\"+ Age) etc.\n\n                if(isStringandValue(mutable_tokens[j].value))\n{\n\n\n        \n\n                    let x=mutable_tokens[j].value\n                    let string=''\n                    let newel=''\n\n                    x=RemoveBrackets(x)\n\n                    \n                    //x = x.replace(/ /g,'')\n\n                    x=x.split(\"+\")\n\n                    \n\n                    x.forEach(element => {\n                        \n\n                        \n                        if(element.charAt(0)== \" \" || element.charAt(element.length-1)==\" \" && !(element.includes('\"'))){\n\n                          \n                       newel= element.replace(/\\s/g, '');\n\n                        \n\n\n                        }\n                        else{\n\n                            newel=element\n                        }\n\n                       let y= updated_tokens.find(el=> el.name== newel)\n\n                      \n                       \n//\n                       if(y!=undefined)\n                       {\n\n\n\n                       string=string + ' ' + y.value\n                       //\n\n\n                       }\n                       else{\n\n                           \n                           element= element.replace(/\"/g, '');\n                           string=string+ ' ' + element\n                       }\n                       \n\n                       \n\n                    });\n\n\n\n                        this.output = this.output + \"\\n\" + string + \"\\n\"\n}\n\n\n//THIS IS to handle operations like प्रिंट (\"Name is GOAT\"), प्रिंट (\"Goodbye\")\n\nelse{\n\n\n\n                  let value= RemoveBrackets(mutable_tokens[j].value)\n                 // \n\n                  \n\n                   let CleanedValue = value.replace(/ /g,'')\n\n                    \n\n\n                   if(/^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedValue)!=true)\n\n                   {\n\n                 // \n\n                    value = value.replace(/\"/g, \"\");\n                    value = value.replace(/'/g, \"\");\n\n\n\n                        this.output = this.output + \"\\n\" + value + \"\\n\" \n }\n                        \n\n}\n\n\n            }\n\n\n           \n            })\n\n        }\n        */\n\n\n        }\n\n    }\n\n}; \n</script>\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n#bharatP{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace\n}\n#versionNumber{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace;\n    padding-left: 6%\n}\n\n#bharatDIV{\n\n    padding-top: 2%;\n    padding-left: 2%\n\n}\n\n#linebylineOutput\n{\n\n\n\nheight: 10px;\n    text-align: left;\n    \n\n\n}\n#errorstack{\n\ntext-align: left;\npadding-left: 2.5%;\npadding-top: 6%;\nfont-weight: bold;\ncolor:rgb(231, 83, 83);\n\n}\n\n#compiler{\n\n  display: flex;\n}\n\n#textarea{\n\n  width: 50%\n}\n#output{\n\n  height: 400px;\n  width: 50%;\n  background-color: black;\n    color: white;\n    overflow: auto\n  \n}\nh3 {\n  margin: 40px 0 0;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n\n.hello {\n  display: grid;\n}\n\n#codearea {\n  width: 90%;\n  height: 400px;\n  background-color: whitesmoke;\n    font-family: monospace;\n    font-size: medium;\n    border: none\n}\n\n#subm {\n  width: 10%;\n  height: 50px;\n}\n</style>"]}]}