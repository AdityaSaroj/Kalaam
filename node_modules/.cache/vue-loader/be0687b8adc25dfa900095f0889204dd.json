{"remainingRequest":"/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/jonny/Documents/Work/test/src/views/Practise.vue?vue&type=style&index=0&id=543887e5&scoped=true&lang=css&","dependencies":[{"path":"/Users/jonny/Documents/Work/test/src/views/Practise.vue","mtime":1591365562867},{"path":"/Users/jonny/Documents/Work/test/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgojYmhhcmF0UHsKCgp0ZXh0LWFsaWduOiBsZWZ0OwogIGRpc3BsYXk6IHRhYmxlLWNlbGw7CiAgICBmb250LWZhbWlseTogbW9ub3NwYWNlCn0KI3ZlcnNpb25OdW1iZXJ7CgoKdGV4dC1hbGlnbjogbGVmdDsKICBkaXNwbGF5OiB0YWJsZS1jZWxsOwogICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsKICAgIHBhZGRpbmctbGVmdDogNiUKfQoKI3ZlcnNpb257CgogICAgbWFyZ2luOiAwOwogICAgZmxvYXQ6IGxlZnQ7CiAgICBjb2xvcjogIzkyOTI0YzsKICAgIGZvbnQtc2l6ZTogOTAlOwoKfQoKI2JoYXJhdERJVnsKCiAgICBwYWRkaW5nLXRvcDogMiU7CiAgICBwYWRkaW5nLWxlZnQ6IDIlCgp9CgoKI2xpbmVieWxpbmVPdXRwdXQKewoKCgpoZWlnaHQ6IDEwcHg7CiAgICB0ZXh0LWFsaWduOiBsZWZ0OwogICAgCgoKfQojZXJyb3JzdGFja3sKCnRleHQtYWxpZ246IGxlZnQ7CnBhZGRpbmctbGVmdDogMi41JTsKcGFkZGluZy10b3A6IDYlOwpmb250LXdlaWdodDogYm9sZDsKY29sb3I6cmdiKDIzMSwgODMsIDgzKTsKCn0KCiNjb21waWxlcnsKCiAgZGlzcGxheTogZmxleDsKfQoKI3RleHRhcmVhewoKICB3aWR0aDogNTAlCn0KI291dHB1dHsKCiAgaGVpZ2h0OiA0MDBweDsKICB3aWR0aDogNTAlOwogIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOwogICAgY29sb3I6IHdoaXRlOwogICAgb3ZlcmZsb3c6IGF1dG8KICAKfQpoMyB7CiAgbWFyZ2luOiA0MHB4IDAgMDsKfQoKdWwgewogIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTsKICBwYWRkaW5nOiAwOwp9CgpsaSB7CiAgZGlzcGxheTogaW5saW5lLWJsb2NrOwogIG1hcmdpbjogMCAxMHB4Owp9CgphIHsKICBjb2xvcjogIzQyYjk4MzsKfQoKLmhlbGxvIHsKICBkaXNwbGF5OiBncmlkOwp9CgojY29kZWFyZWEgewogIHdpZHRoOiA5MCU7CiAgaGVpZ2h0OiA0MDBweDsKICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZXNtb2tlOwogICAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZTsKICAgIGZvbnQtc2l6ZTogbWVkaXVtOwogICAgYm9yZGVyOiBub25lOwogICAgb3V0bGluZTogbm9uZTsKfQoKI3N1Ym0gewogIHdpZHRoOiAxNyU7CiAgaGVpZ2h0OiA1MHB4Owp9Cg=="},{"version":3,"sources":["Practise.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiuHA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"Practise.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class=\"hello\">\n   \n   \n\n   <div id=\"compiler\">\n   <div id=\"textarea\">\n    <textarea v-model=\"code\" type=\"text\" name=\"code\" id=\"codearea\"></textarea>\n\n    <button style=\"background-color:green\" id=\"subm\" @click=\"RUN()\">RUN</button>\n        <button id=\"subm\" @click=\"Add('प्रिंट()')\">प्रिंट</button>\n<button id=\"subm\" @click=\"Add('कार्य')\">कार्य</button>\n    <button id=\"subm\" @click=\"Add('इनपुट()')\">इनपुट</button>\n\n    <button id=\"subm\" @click=\"Add('अगर()')\">अगर</button>\n\n    <button id=\"subm\" @click=\"Add('दुहराओ x को y मे')\">दुहराओ x को y मे</button>\n    <button id=\"subm\" @click=\"Add('जबतक()')\">जबतक</button>\n    <button id=\"subm\" @click=\"Add('.संख्या()')\">.संख्या()</button>\n    <button id=\"subm\" @click=\"Add('.पुश()')\">.पुश()</button>\n    <button id=\"subm\" @click=\"Add('अन्यथा()')\">अन्यथा</button>\n    \n\n   \n   </div>\n\n    <div id=\"output\">\n\n<div id=\"bharatDIV\">\n\n<p id=\"version\">Kalam v1.0.0</p>\n<p v-if=\"this.isError==false\" style=\"margin-top: 5%;    text-align: left;\n    color: #2fff2f;\n    font-family: monospace;\n\">{{TimeTaken}}</p>\n        \n<p v-if=\"this.isError==true\" style=\"margin-top: 5%;text-align: left;\n    color: red;\n    font-family: monospace;\n\">{{TimeTaken}}</p>\n        \n\n\n<p style=\"white-space: pre; \"  id=\"linebylineOutput\" v-for=\"(output,index) in this.linebylineOutput\" :key=\"index\">\n\n\n {{output}} \n\n\n\n</p>\n\n</div>\n\n\n\n\n    </div>\n</div>\n  \n\n    \n      \n  </div>\n</template>\n\n<script>\n\n\n   import {\n    SourceDataReplaceforEasyParsing\n} from '../FunctionScripts/functions'\nimport * as TypeCheck from '../FunctionScripts/TypeChecking'\nimport * as AdvancedTypeCheck from '../FunctionScripts/AdvancedTypeChecking'\nimport * as BuildOperation from '../FunctionScripts/BuildOperations'\nimport {\n    PushArray,\n    PushCalculation,\n    PushConditionalKeyword,\n    PushCondition,\n    PushForLoop,\n    PushWhileLoop,\n    PushWhileLoopCondition,\n    PushForLoopAruguments,\n    PushExpression,\n    PushKeyword,\n    PushNumber,\n    PushOperator,\n    PushRealTimePrintOperation,\n    PushString,\n    PushStringandValueOperation,\n    PushVariable,\n    PushVariableValue,\n    PushFunctionData,\n    PushInput\n\n} from '../FunctionScripts/PushFunctions'\nimport {\n    RemoveBrackets,\n    Count,\n    ResetValue,\n    isArrayOperation,\n    CreateArrayElement,\n    CalculateValues,\n    GetArrayorStringElement,\n    SetArrayorStringElement,\n    PrintArrayElement,\n    handlemultConditions,\n    HandleBlocks,\n    SplitElementsArray,\n    SetValues,\n    PushSetArrayIndexValue,\n    PushGetArrayIndexValue,\n    UpdateUpdated_tokenswithValues,\n    GetConditionValue,\n    ForLoopArrayorStringOutput,\n    AssignorUpdateValues,\n    HandleConditions,\n    getLoopIndexStart,\n    ForLoopSetMetadata,\n    SetArrayIndexValue\n} from '../FunctionScripts/MiscImportantFunctions'\n\n\n\n\n\nexport default {\n    name: \"HelloWorld\",\n    props: {\n        msg: String\n    },\n\n    data() {\n        return {\n            code:\n\n            'Name=\"Swanand Kadam\"'\n            +\n            \"\\n\"\n+\n            'Fibonacci=[]'\n\n            +\n            \"\\n\"\n+\n'FibReverse=[]'\n\n+\n\n\n\"\\n\"\n+\n'दुहराओ a को (0,25)'\n\n+\n\"\\n\"\n+\n\n'{'\n+\n\"\\n\"\n+\n'अगर (a<3)'\n\n+\n\"\\n\"\n+\n'{'\n\n\n+\n\"\\n\"\n\n+\n'Fibonacci[a]=a'\n\n+\n\"\\n\"\n\n+\n\n'}'\n\n+\n\"\\n\"\n\n+\n'अगर (a>1)'\n\n+\n\"\\n\"\n+\n'{'\n+\n\"\\n\"\n+\n\n'x=Fibonacci[a-2]'\n+\n\"\\n\"\n+\n'y=Fibonacci[a-1]'\n\n+\n\"\\n\"\n+\n\n'Fibonacci[a]=x+y'\n+\n\n\"\\n\"\n+\n'}'\n+\n\n\"\\n\"\n\n+\n\n\n'}'\n+\n\"\\n\"\n\n+\n\n'length=Fibonacci.संख्या()'\n+\n\"\\n\"\n\n+\n\n'प्रिंट(Fibonacci)'\n\n+\n '}',\n \n            output: '',\n            error: [],\n            OperationObjects: [],\n            linebylineOutput: '',\n            TimeTaken: '',\n            inputIndexes: [],\n            input: '',\n            isError:'',\n            LastConditionValue:true\n\n        };\n    },\n\n    methods: {\nAdd:function(add)\n\n{\n\n\nthis.code=this.code + add\n\n}\n,\n        RUN: function() {\n\n\n\n                var t0 = performance.now()\n\n                this.isError=false\n\n                //to stop accumulating output on succesive RUN\n                this.output = ''\n                this.input = '',\n                    this.linebylineOutput = this.output.split(\"\\n\")\n                this.inputIndexes = []\n                this.error = []\n                this.OperationObjects = []\n                var sourcedata = this.code;\n                var cleaned_sourcedata = []\n                var i = 0;\n                var tokens = [];\n                var mixedimpurity = []\n                var updated_tokens = []\n                var functionContextupdated_tokens = []\n                var variables_array = []\n                var assigned_variables = []\n                var terms = []\n                var terms2 = []\n                var operation = ''\n                var CalculationStack = []\n                var foundToken = ''\n                var ReIntializedVariables = []\n                var tempthis=this\n\n                //emptying accumulatedvalue stored for operations like Name= Name+Array[i]\n                //See AssignorUpdateValues fuction for more\n                ResetValue()\n\n\n                function sleep(milliseconds) {\n                    const date = Date.now();\n                    let currentDate = null;\n                    do {\n                        currentDate = Date.now();\n                    } while (currentDate - date < milliseconds);\n                }\n\n\n                function AddOutput(tempthis,value)\n                {\n\n\n\n                tempthis.output = tempthis.output + value + \"\\n\";\n\n\n\n                }\n\n                //preparing sourcedata for easy parsing by handling new lines, enters etc.\n                //cleaning up the data to get my version of sourcedata. it's better to get version suitable for me because users can type what they wish but I need to maintain \n                //integrity of program in every possible conditio. So. I created my own condition below\n\n                function GetCleanSourcedata(sourcedata, cleaned_sourcedata, impurities) {\n\n                    sourcedata = SourceDataReplaceforEasyParsing(sourcedata)\n\n                    sourcedata.forEach((element, i) => {\n\n\n                        //finding the elements which has =\" in it so that to seprate them e.g. anna=\"swanand\" also finding the elements which starts with =. e.g \"=78787890\"\n\n\n\n                        if (!element.includes('==') && (element.indexOf('=\"') > -1 || element.indexOf('=') > 0 || element.charAt(0) == \"=\") && element != '==')\n\n\n                        {\n\n\n\n                            impurities.push(element) //push such element as impurity in impurities\n\n\n\n                            let elements = element.split(\"=\")\n                            let index = cleaned_sourcedata.length\n\n\n                            cleaned_sourcedata[index] = (elements[0])\n                            cleaned_sourcedata[index + 1] = (\"=\")\n                            cleaned_sourcedata[index + 2] = (elements[1])\n\n\n\n                        }\n\n                       \n\n                        //as long as element is pure, push it to new and clean version of sourcedata\n                        if (!impurities.includes(element)) {\n\n\n\n                            cleaned_sourcedata.push(element)\n\n                        }\n\n                        //\n\n                    })\n\n\n                    //removing empty \"\" values for final version of sourcedata\n                    //SECTION FInal sourcedata cleaning\n\n                    cleaned_sourcedata = cleaned_sourcedata.filter(function(item) {\n\n                        return item !== \"\"\n                    })\n\n\n\n                    return cleaned_sourcedata;\n\n                }\n\n\n                let Result = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity)\n\n                cleaned_sourcedata = Result\n                console.log('cleaned_sourcedata: ', cleaned_sourcedata);\n\n\n\n\n                //SECTION - Checking for type of characters\n\n\n                const isVariable = TypeCheck.isVariable()\n                const isNumber = TypeCheck.isNumber()\n\n                const isOperator = TypeCheck.isOperator()\n\n                const isKeyword = TypeCheck.isKeyword()\n                const isConditionalKeyword = TypeCheck.isConditionalKeyword()\n                const isForLoop = TypeCheck.isForLoop()\n                const isWhileLoop = TypeCheck.isWhileLoop()\n                const isFunction = TypeCheck.isFunction()\n                //needs work\n                const isExpression = TypeCheck.isExpression()\n\n                const isArray = TypeCheck.isArray()\n                const isInput = TypeCheck.isInput()\n\n                const isSetArrayIndexValue = TypeCheck.isSetArrayIndexValue()\n\n                // const isEmptyArrayInit = TypeCheck.isEmptyArrayInit()\n\n                const isString = TypeCheck.isString()\n                const isEmptyStringorChar = TypeCheck.isEmptyStringorChar()\n\n                const isPureEval = AdvancedTypeCheck.isPureEval()\n\n                //if parser encounters anything like (\" or (, then that's a realtime print. \n                //buildstring will be applied now to create a string and push it into tokens\n\n                const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString()\n\n\n\n                const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n                const isCalculation = AdvancedTypeCheck.isCalculation()\n\n                const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n\n\n\n\n                //SECTION Build Operations \n\n\n                const BuildString = BuildOperation.BuildString()\n\n                const BuildArray = BuildOperation.BuildArray()\n\n                //this function is the first step to handlle operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n\n                const BuildCondition = BuildOperation.BuildCondition()\n\n\n\n                //This will run for every print statement encountered in the program, not just for loops\n\n                function IfTokenPrint(Tokens, updated_tokens, j, global, iterator, OriginalIterator)\n\n\n\n\n                {\n\n\n                    var token = Tokens[j].value\n\n\n\n                    var NextTokenValue = Tokens[j + 1].value\n                    //NextTokenValue = NextTokenValue.replace(\"+\", ' + ')\n                    \n\n\n\n\n                    var StringVar = []\n\n                    var b = RemoveBrackets(NextTokenValue)\n                    \n                    \n\n                    if (isVariable(b) && !variables_array.includes(b)) {\n\n                        variables_array.push(b)\n                        // \n\n                    }\n\n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n\n                    //This loop is only for printing direct values like print(name), print(array)\n\n                    updated_tokens.forEach((el, i) => {\n                        \n                        \n                        \n\n\n\n                        if (el.name == b) {\n\n                            //for calculations like x=ageone+agetwo\n\n                            //If we have already caluculated value, use that or else move forward\n\n\n\n\n                            if (assigned_variables.includes(el)) {\n\n\n                                \n\n                                AddOutput(global, el.value)\n\n\n\n                            } else {\n\n\n                                if (isNumber(el.value)) {\n                                    \n\n\n\n                                     AddOutput(global, el.value)\n\n\n                                    assigned_variables.push(el.name);\n\n\n\n                                }\n\n                                //operations like age=2020-1996\n                                else if (isPureEval(el.value)) {\n\n\n\n\n                                    let outputpure = eval(el.value)\n\n\n\n                                    el.value = outputpure\n\n\n                                     AddOutput(global, el.value)\n\n                                    assigned_variables.push(el.name);\n\n                                }\n\n\n\n                                //operations like name=\"swanand kadam\", variable assignments as strings\n                                else if (!isPureEval(el.value) && !isNumber(el.value))\n                                \n\n\n                                {\n\n\n\n                                    if (!(el.name.includes(']') && el.name.includes('['))) {\n\n\n                                        if(el.type=='Array')\n                                        {\n\n\nif (el.value.includes('[')==false)\n\n{\n\nel.value='['+el.value.toString()+']'\nconsole.log('el.value: ', el.value);\n\n\n\n}\n\n                                        }\n\n                                        AddOutput(global, el.value)\n                                        \n                                        \n\n\n\n                                        assigned_variables.push(el.name);\n                                    }\n\n\n\n\n                                }\n\n\n\n\n                            }\n\n                        }\n\n\n\n\n                        // work to be continued\n                    })\n\n\n                    //ANCHOR - CONDITION 2\n                    if (Tokens[j + 1].type == 'Array')\n\n\n\n\n                    {\n\n                        //To run only if iterator is present\n\n                        //This runs on for loop - Print(Array[a]) etc\n\n                        //this runs only if for(i) and in the loop, array[i], not on array[x]. Iterator and index should be same\n\n                        if (iterator != undefined && Tokens[j + 1].IndexInput == OriginalIterator)\n\n                        {\n\n\n\n                            let Value = NextTokenValue\n                            // console.log('Value: ', Value);\n\n                            let ArrayElement = CreateArrayElement(Value, iterator)\n\n\n                            let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                            AddOutput(global, output)\n                        console.log('output: ', output);\n\n\n                            assigned_variables.push(Tokens[j + 1]);\n\n\n                        }\n\n\n                        //This runs to Print(Array[2]) like specific array values\n                        else if (Tokens[j+1].IndexInput != OriginalIterator)\n                        \n\n\n                        {\n\n                            //\n\n                            let Value = NextTokenValue\n\n                            let IndexToChange = Tokens[j + 1].IndexInput\n\n\n                            let ArrayElement = CreateArrayElement(Value, IndexToChange)\n\n\n                            let element = ArrayElement.replace(']', '')\n\n\n                            let Split = element.split('[')\n\n\n\n\n                            if (Split[1].includes('-') || Split[1].includes('+')) {\n\n\n                                let output = CalculateValues(Split[1], j, updated_tokens)\n\n                                Split[1] = output\n\n                                Split = Split.join('[') + ']'\n                                ArrayElement = Split\n                                //console.log('ArrayElement: ', ArrayElement);\n\n\n                            }\n\n\n                            let token = updated_tokens.find(el => el.name == Split[1])\n\n                            if (token != undefined && OriginalIterator != Split[1]) {\n\n                                Split[1] = token.value\n\n                                Split = Split.join('[') + ']'\n                                ArrayElement = Split\n\n\n                            } else {\n\n                                ArrayElement = ArrayElement\n                                //console.log('ArrayElement: ', ArrayElement);\n\n                            }\n\n\n                            let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                                        AddOutput(global, output)\n                             console.log('output: ', output);\n\n\n\n\n                        }\n\n\n                    }\n\n\n\n\n                    //printing direct numbers and direct calcultions like print(10), print(10*10)\n                    else if (token == 'प्रिंट' && (isPureEval(NextTokenValue) || isNumber(RemoveBrackets(NextTokenValue)))) {\n\n\n                        let a = eval(NextTokenValue)\n\n                                        AddOutput(global, a)\n\n                    }\n\n\n\n\n                    //foroperations like print('you live, you learn')\n                    else if (Tokens[j + 1].mode == \"RealTimePrint\" && !NextTokenValue.includes('+') && !NextTokenValue.includes('='))\n\n                    {\n\n\n                        let output = RemoveBrackets(NextTokenValue)\n\n                        output = output.replace(/\"/g, '');\n                        output = output.replace(/'/g, '');\n\n\n                                        AddOutput(global, output+\"\\n\")\n                        //console.log('global.output: ', global.output);\n\n\n\n                    }\n\n                    //operations like print(Age + 'is young age')\n                    else if (Tokens[j + 1].mode == \"RealTimePrint\" && NextTokenValue.includes('+')) {\n\n\n\n                        let x = SplitElementsArray(NextTokenValue)\n\n\n\n\n                        StringVar = SetValues(x, updated_tokens)\n\n\n\n\n                        StringVar = StringVar.join('')\n                        StringVar = StringVar.split(\"+\")\n\n                        let output = StringVar.join(' ')\n                        output = RemoveBrackets(output)\n\n                        AddOutput(global, output+\"\\n\")\n\n\n\n                    } else if (isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != \"RealTimePrint\")\n\n\n                    {\n\n\n                        let output = CalculateValues(NextTokenValue, j, updated_tokens)\n\n                        AddOutput(global, output+\"\\n\")\n\n\n                    }\n                    \n\n\n\n\n                }\n\n\n                //END OF Functions and Imported Functions\n\n\n\n                //SECTION - Parsing STARTS here\n\n                //SECTION - Checking each token and adding to tokens array\n\n\n\n            \n                let variableArray = [] //TO REMOVE DUPLICATE VARIABLES, SEE 482\n\n                function Parse(cleaned_sourcedata, i) {\n\n                    var element = cleaned_sourcedata[i];\n\n\n                    var string = []\n\n\n\n\n                    if (isVariable(element) == true) {\n\n\n                        if (cleaned_sourcedata[i + 1] == '=') {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            if (variableArray.includes(element)) {\n\n                                // let UpdateElementValue = element\n\n                                let x = tokens.find(el => el.value == element)\n\n                                let index = tokens.indexOf(x)\n\n\n                                ReIntializedVariables.push({\n                                    name: element\n                                })\n\n                                //\n\n                                //tokens[index+2].value= cleaned_sourcedata[i+2]\n\n\n\n                            }\n\n                            variableArray.push(element)\n\n\n\n\n                        } else if (cleaned_sourcedata[i - 1] == '=') {\n\n\n                            PushVariableValue(element, tokens)\n\n                        }\n\n                    } \n                    \n                    else if (isNumber(element) == true) {\n\n                        PushNumber(element, tokens)\n\n                    } \n\n                    else if(isEmptyStringorChar(element)==true){\n\n\n\n                         if(element.length>1 && (element.charAt(0)==\"'\"||element.charAt(0)=='\"')){\n                             \n\nconsole.log('element: ', element);\nelement=element.replace(/['\"]+/g, '')\n\n        \n\n    }\n\n    else{\n\n        element=\" \"\n    }\n                        \nPushVariableValue(element,tokens)\n\n\n\n\n                    }\n                    \n                    else if (isInput(element) == true)\n\n                    {\n\n\n                        PushInput(element, tokens, cleaned_sourcedata, i)\n\n\n\n\n                    } \n                    \n                    else if (isOperator(element) == true) {\n                        \n                        PushOperator(element, tokens)\n\n                    } \n                    \n                    else if (isKeyword(element) == true) {\n\n                        PushKeyword(element, tokens)\n\n                    } \n                    \n                    else if (isFunction(element) == true) {\n\n                        PushFunctionData(element, tokens, cleaned_sourcedata, i)\n\n                    }\n\n                    //check if it accpets Arry[2a] as index : \n                    else if (isArray(element) == true) {\n\n\n\n\n                        if (element.charAt(element.length - 1) == ']') {\n\n\n\n                            PushArray(element, tokens)\n\n                        } else {\n\n\n                            let BuiltArray = BuildArray(element, i, cleaned_sourcedata)\n\n                            PushArray(BuiltArray, tokens)\n\n\n\n                        }\n                    }\n\n                    //for Numbers[a]=x\n                    else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == true) {\n\n\n\n\n                        PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i);\n\n\n\n                    }\n\n\n\n                    //for x=Numbers[a]\n                    else if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == false) {\n\n\n\n                        PushGetArrayIndexValue(element, tokens, cleaned_sourcedata, i)\n\n\n\n\n                    }\n\n                \n                    else if (isConditionalKeyword(element) == true) {\n\n\n\n                        if (isWhileLoop(element) == true) {\n\n                            PushWhileLoop(element, tokens, cleaned_sourcedata, i)\n                            // PushWhileLoopCondition(element, cleaned_sourcedata, i, tokens)\n\n\n                        } else {\n\n                            PushConditionalKeyword(element, tokens)\n                        }\n\n\n                        let foundcondition = BuildCondition(element, i, cleaned_sourcedata)\n                        // console.log('foundcondition: ', foundcondition);\n\n\n\n                        PushCondition(foundcondition, tokens)\n\n\n\n\n                    } \n                    \n                    \n                    else if (isForLoop(element) == true) {\n\n                        PushForLoop(element, tokens)\n                        PushForLoopAruguments(element, cleaned_sourcedata, i, tokens)\n\n                        updated_tokens.push({\n\n                            name: cleaned_sourcedata[i + 1],\n                            value: 0,\n                            type: 'ForLoopIterator'\n\n                        })\n\n\n                    } \n                    \n                    \n                    else if (isCalculation(element) == true) {\n\n\n                        let element = ''\n\n                        if (cleaned_sourcedata[i + 1] != undefined) {\n\n\n\n                            // this is to perform long operations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n\n                            while (isCalculation(cleaned_sourcedata[i]))\n\n\n\n                            {\n\n\n                                element = element + cleaned_sourcedata[i];\n\n\n                                i++;\n\n                            }\n\n\n\n\n                        }\n\n\n                        //PushCalculation(element,tokens)\n\n\n\n\n                        //  \n                        terms = element.split('')\n\n                        //removing the \"(\"\" and \")\"\n\n                        var CleanedElement = RemoveBrackets(element)\n\n\n                        // to stop prevention of expressions like is\"+ getting added as a calculation\n                        if (!(CleanedElement.includes('\"')) && element.charAt(0) != '/' && element.charAt(0) != '*' && element.charAt(0) != \"'\") {\n\n                            PushCalculation(element, tokens, cleaned_sourcedata, i)\n\n\n\n                        }\n\n                    }\n\n                    //finding operations like print(\"swanand\"). The realtimeprint operations\n                    else if (isRealTimePrintMultipleString(element) == true) {\n\n\n\n                        //\n                        let foundString = ''\n\n                        let k = i\n                        //  console.log('element: ', element);\n                        let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n                        //console.log('conditionEnd: ', conditionEnd);\n\n\n                        var flag = 0;\n\n\n\n\n                        for (k; k < cleaned_sourcedata.length; k++) {\n\n                            let element = cleaned_sourcedata[k]\n                            let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n\n                            if (element.includes('दुहराओ') || element.includes('कार्य') || element.includes('अन्यथा') || element.includes('इनपुट') || element.includes('पुश') || element.includes('प्रिंट') || element.includes('अगर') || cleaned_sourcedata[k + 1] == '=' || element == '}') {\n\n\n                                //foundString=foundString+  ' '+ cleaned_sourcedata[k]\n\n                                //\n                                break;\n\n\n                            }\n\n                            if (conditionEnd == ')\"')\n\n                            {\n\n                                foundString = foundString + ' ' + cleaned_sourcedata[k];\n                                break;\n\n                            } else if (flag == 1) {\n\n                                foundString = foundString + ' ' + cleaned_sourcedata[k]\n\n                            } else if (flag == 0) {\n\n                                foundString = cleaned_sourcedata[k];\n\n                                flag = 1;\n\n                            }\n\n\n\n\n                        }\n\n\n\n                        if ((!foundString.includes(\">\")) && (!foundString.includes('/')) && (!foundString.includes('*')) && (!foundString.includes('<')) && (!foundString.includes('==')))\n\n\n                        {\n\n                            //console.log('foundString: ', foundString);\n                            PushRealTimePrintOperation(foundString, tokens)\n\n                        }\n\n\n\n\n                    }\n\n\n\n\n                    //storing only the string values to tokens ( not the strings in print statements)\n                    else if (isString(element))\n\n\n                    {\n\n\n\n                        let calculatedString = BuildString(element, i, cleaned_sourcedata)\n\n\n\n                        calculatedString = calculatedString.replace(/['\"]+/g, '')\n\n                        if (!(calculatedString.includes(\"प्रिंट\")))\n\n                            PushString(calculatedString, tokens)\n\n                        \n\n\n\n                    }\n\n\n\n\n                    //Found Solution using regexp- print(a) without space is getting accepted as expression\n                    else if (/^(?=.*?प्रिंट)(?=.*[a-z])/.test(element)) {\n\n                        PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n\n\n                        PushExpression(element.slice(6), tokens) //Pushing remaining expression like (a), (gagaks) etc\n                    }\n\n\n                    //error prone change made here- Pushing expression in here\n                    else if (isExpression(element) == true && !isCalculation(element) && !element.includes('[') && !element.includes(']') && (!isConditionalKeyword(cleaned_sourcedata[i - 1])) && (cleaned_sourcedata[i - 1] != 'मे' && cleaned_sourcedata[i - 1] != 'कार्य')) {\n\n\n\n                        if (element.charAt(0) != '(') {\n\n                            let CheckFunctionExpression = element.split('(')\n\n\n                            let passedValues = RemoveBrackets(CheckFunctionExpression[1])\n                            passedValues = passedValues.split(',')\n                            let token = tokens.find(el => el.value == CheckFunctionExpression[0])\n\n\n                            if (token != undefined) {\n\n\n\n                                token.FunctionInvocationExists = true\n                                token.ExecutionIndex = i - 1\n                                token.passedValues = passedValues\n\n\n\n                            }\n\n                        }\n\n                        PushExpression(element, tokens)\n\n\n\n\n                    } \n                    \n                    else if (isExpression(element) == true && element.includes('[') && element.includes(']')) {\n\n                        PushArray(element, tokens)\n\n                    } \n                    \n                    else if (!isKeyword(element) && !isNumber(element) && !isVariable(element) && !isExpression(element) && !isOperator(element))\n                {\n\n\n                        //ANCHOR \n                        /*Hnadling Impurity error-The main problem is figuring out how to solve \"=7000\" like things\n                    instead asking developers to add space manually\n                    Handling Alphanumeric strings to solve issues like ' anna=2362934'\n\n                    let impurity = element.split('=')\n\n                    let findString = impurity[1]\n\n\n                    //to accept long numbers i.e a=749374593745937\n\n                    if (isVariable(impurity[0]) && isNumber(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n                    //to accept a=STRING\n                    if (isVariable(impurity[0]) && isVariable(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n\n\n                    impurity.forEach((element, i) => {\n\n                        if (isVariable(element) == true) {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            //continue;\n                        }\n\n                        // ANCHOR \n\n                        //Issue: Right now, only isNumber is resolved, a=, =23828qw aren't resolved.\n                        //Solution: Work on all the modules\n\n\n                        if (isNumber(element) == true) {\n\n\n                            PushNumber(element, tokens)\n\n                        }\n\n                        //ANCHOR \n                        //You might have to remove this extra filters since you are only working on numbers (Future Issue)\n                        if (isOperator(element) == true) {\n                            PushOperator(element, token)\n\n                        }\n\n\n\n                        if (isKeyword(element) == true) {\n\n                            PushKeyword(element)\n\n                        }\n\n                        if (isExpression(element) == true) {\n\n\n                            PushExpression(element, tokens)\n\n                        }\n\n\n\n\n                    })\n */\n\n                    }\n\n\n\n\n                }\n\n\n\n\n\n\n\n\n\n\n\n\n\n                //SECTION - Checking each token and adding to tokens array\n                // PARSING INITIATION\n\n\n                for (i; i < cleaned_sourcedata.length; i++) {\n\n\n                    Parse(cleaned_sourcedata, i)\n                }\n\n                //ANCHOR \n                //CLEANING UP THE TOKENS ARRAY\n                //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n                tokens = tokens.filter(el => el.value != '')\n                console.log('tokens: ', tokens);\n\n\n\n\n               \n\n\n                //SECTION - Printing Outputs, considering conditions, finding values in updated_tokens\n\n\n\n\n                for (var j = 0; j < tokens.length; j++) {\n\n                    // Checking for assignment operators\n\n\n                    let mutable_tokens = tokens\n                    var token = mutable_tokens[j].value\n                    let tokenType = mutable_tokens[j].type\n\n\n\n                    var StringVar = []\n\n                    let VarWithoutbrackets = RemoveBrackets(mutable_tokens[j].value)\n\n                    VarWithoutbrackets = VarWithoutbrackets.replace(/ /g, '')\n\n\n                    if (mutable_tokens[j].type == \"SetArrayIndexValue\")\n\n\n\n                    {\n\n                       \n                       SetArrayIndexValue(mutable_tokens,j,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                       } else if (mutable_tokens[j].value == '=') {\n\n                      \n                      \n                      \n     AssignorUpdateValues(mutable_tokens, j, updated_tokens, iterator, OriginalIterator,this)\n\n                      \n                  \n\n\n                    } \n                  /*  else if(tokenType=='PushToArray' )\n                    {\n\ntoken=token.replace('पुश','')\nlet Split=token.split('.')\nlet Array=Split[0]\nlet ElementtoPush=RemoveBrackets(Split[1])\nElementtoPush=updated_tokens.find(el=>el.name==ElementtoPush).value\n\nlet ArrayValue=updated_tokens.find(el=>el.name==Array).value\nArrayValue= ArrayValue.split(',')\nArrayValue.push(ElementtoPush)\nconsole.log('ArrayValue: ', ArrayValue);\n \n\n                    }*/\n                    \n                    else if(token=='अन्यथा')\n                    {\n\n                let result = HandleBlocks(mutable_tokens, j, result)\nlet StartofBlock= mutable_tokens[j+1].startIndex\nconsole.log('StartofBlock: ', StartofBlock);\nlet EndofBlock= mutable_tokens[j+1].EndIndex\n\n\nif(this.LastConditionValue==true)\n{\n\n\nj=EndofBlock\n\n\n}\n\n\n\n\n\n                    }\n                    \n                    else if (tokenType == 'AcceptInput') {\n\n                        let SetInputValueAs = mutable_tokens[j].AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for ' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    } else if (tokenType == 'function') {\n\n                        //checking if function is invoked somewhere later in the program\n                        let functionInvocation = mutable_tokens[j].FunctionInvocationExists\n\n\n\n                        if (functionInvocation) {\n                            let functionSourceData = []\n\n                            let result = HandleBlocks(mutable_tokens, j, functionSourceData)\n\n                            functionSourceData = result.StoreResult\n                            console.log('functionSourceData: ', functionSourceData);\n\n                            let functionArguments = mutable_tokens[j].arguments\n                            let functionName = mutable_tokens[j].value\n\n                            let passedValues = mutable_tokens[j].passedValues\n\n\n\n\n                            //Creating a seperate execution context and setting fucntion context name:value pair in 'functionContextupdated_tokens'\n                            functionArguments.forEach((el, index) => {\n\n\n\n\n                                let val = passedValues[index]\n\n\n\n                                val = val.replace(/\"/g, \"\");\n                                val = val.replace(/'/g, \"\");\n                                \n                               \n\n                                passedValues[index] = val\n                                console.log('val: ', val);\n\n                                \n                               \n                                //in this code we are filtering out arguments passed based on whether they already exist in updated tokens or not\n\n                                let FindInUpdatedTokens= updated_tokens.find(el=>el.name==val)\n                                \n\n//For passing same argument and same value to function  e.g function foo (fibonacci) and fibonacci=[] is already declared\n                                if(FindInUpdatedTokens==undefined)\n                                {\n\nfunctionContextupdated_tokens.push({\n\n\n\n\n                                    name: val,\n\n                                    value: '',\n\n                                    identifier: j + index,\n                                    type: 'value',\n                                    context: 'FunctionExecutionContext'\n\n\n\n\n                                })\n\n\n                                }\n\n                                //For passing different argument and value to function  e.g function foo (arr) and arr doesn't exist anywhere in tokens.\n\n\n                                else if(el!=FindInUpdatedTokens.name && FindInUpdatedTokens!=undefined) {\n\n\n                                    functionContextupdated_tokens.push({\n\n\n\n\n                                    name: el,\n\n                                    value: FindInUpdatedTokens.value,\n\n                                    identifier: j + index,\n                                    type: FindInUpdatedTokens.type,\n                                    context: 'FunctionExecutionContext',\n                                    IntheEndSetValueto:val\n\n\n\n\n                                })\n\n\n\n                                }\n\n\n                                \n                                \n\n                             \n\n\n\n\n                            });\n\n\n                            var CompleteTokenValueList = [...updated_tokens, ...functionContextupdated_tokens]\n                            console.log('CompleteTokenValueList: ', CompleteTokenValueList);\n                            \n                            \n\n\n                            for (let i = 1; i < functionSourceData.length; i++)\n\n                            {\n\n\n                                let el = functionSourceData[i]\n\n\n\n\n                                if (el.value == 'प्रिंट')\n\n                                {\n\n                                   let ValueToPrint= RemoveBrackets(functionSourceData[i+1].value)\n\n                                   let a= updated_tokens.find(el=>el.name==ValueToPrint)\n                                   \n\n\n                                \n\n                                 IfTokenPrint(mutable_tokens, CompleteTokenValueList, j + i, this)\n                                    \n\n                                  \n\n                                    \n\n\n                                \n                                } \n                                else if (el.value == '=') {\n                                    \n\n                      \n                      \n                      \n     AssignorUpdateValues(functionSourceData, i, CompleteTokenValueList, iterator, OriginalIterator,this)\n\n                      \n                  \n\n\n                    }\n                                 else if (el.type == 'AcceptInput') {\n\n                        let SetInputValueAs =functionSourceData[i].AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    } else if (el.type == 'condition')\n\n                                {\n\n\n\n\n                                    let element = functionSourceData[i].value\n\n                                    //this function is the first step to calculate value of operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n                                    let ConditionValue = GetConditionValue(element, CompleteTokenValueList, i)\n                                    this.LastConditionValue=ConditionValue\n                                    //  console.log('j: ',j);\n\n\n\n\n                                    //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                                    if (ConditionValue == false) {\n\n                                        let InitializeLoop = tokens.indexOf(functionSourceData[i])\n\n                                        //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                                        //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                                        let Returnvalue = HandleBlocks(functionSourceData, i)\n\n                                        i = Returnvalue.i\n                                    }\n\n\n\n\n                                }\n\n\n\n\n                                //Handling set array element statements in for loop\n                                else if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n                                    SetArrayIndexValue(functionSourceData,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n\n                                } else if (functionSourceData[i].type == 'ForLoopStart')\n\n\n\n                                {\n\n                                    var FlagPrimalLoop = 0\n\n                                    var SourcedataTokens = []\n\n\n                                    //console.log('updated_tokens: ', updated_tokens);\n\n                                    let ForLoopMetaData = ForLoopSetMetadata(functionSourceData, i, CompleteTokenValueList)\n\n\n                                    var ForLoopSourcedataIndexStart = ForLoopMetaData.ForLoopSourcedataIndexStart\n                                    var Cycle = ForLoopMetaData.Cycle\n                                    var OriginalIterator = ForLoopMetaData.OriginalIterator\n                                    var IterationStart = ForLoopMetaData.IterationStart\n                                    var iterator = ForLoopMetaData.iterator\n                                    var element = ForLoopMetaData.element\n                                    var elementValue = ForLoopMetaData.elementValue\n\n                                    function getSourcedata(startIndex, functionSourceData, check, StoreResult) {\n                                        //console.log('startIndex, functionSourceData, check, StoreResult: ', startIndex, functionSourceData, check, StoreResult);\n\n\n\n                                        let Returnvalue = HandleBlocks(functionSourceData, startIndex, StoreResult)\n                                        StoreResult = Returnvalue.StoreResult\n\n\n                                        return StoreResult\n\n\n                                    }\n\n\n\n\n                                    ForLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', ForLoopSourcedataIndexStart)\n\n                                    //\n\n                                    SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, functionSourceData, '}', SourcedataTokens)\n                                    \n\n\n\n                                    SourcedataTokens.forEach(el => {\n\n                                        el.isNestedLoop = false\n\n                                    })\n\n\n                                    let FindNestedLoop = SourcedataTokens.find(el => el.type == 'ForLoopStart')\n                                    if (FindNestedLoop != undefined) {\n\n                                        let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 2\n                                        let NestedLooplength = (SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex) + 1\n\n\n                                        for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n\n\n                                            SourcedataTokens[x].isNestedLoop = true\n\n                                        }\n\n\n                                    }\n\n\n\n\n                                    if (element.includes('(') && element.includes(','))\n\n\n                                    {\n\n                                        FlagPrimalLoop = 1\n\n\n                                    }\n\n\n\n\n                                    // console.log('Cycle: ', Cycle,IterationStart);\n\n\n                                    //Iterating over forloop sourcedata\n                                    //this line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                                    for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n\n\n\n                                        let forloopindex = CompleteTokenValueList.find(el => el.name == OriginalIterator)\n\n\n\n\n                                        forloopindex.value = iterator\n\n                                        //console.log('CompleteTokenValueList: ', CompleteTokenValueList);\n\n                                        //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                                        if (FlagPrimalLoop = 0) {\n                                            ForLoopArrayorStringOutput(elementValue, iterator, CompleteTokenValueList, this)\n\n                                        }\n\n\n                                        for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                                        {\n\n\n                                            let isNested = SourcedataTokens[i].isNestedLoop\n\n\n\n\n                                            if (SourcedataTokens[i].type == 'ForLoopStart') {\n\n                                                var NestedFlagPrimalLoop = 0\n\n                                                var NestedSourcedataTokens = []\n\n                                                let NestedForLoopMetaData = ForLoopSetMetadata(SourcedataTokens, i, CompleteTokenValueList)\n\n                                                //  console.log('NestedForLoopMetaData: ', NestedForLoopMetaData);\n\n                                                var NestedForLoopSourcedataIndexStart = NestedForLoopMetaData.ForLoopSourcedataIndexStart\n                                                var NestedCycle = NestedForLoopMetaData.Cycle + 1\n                                                var NestedOriginalIterator = NestedForLoopMetaData.OriginalIterator\n                                                var NestedIterationStart = NestedForLoopMetaData.IterationStart\n                                                var Nestediterator = NestedForLoopMetaData.IterationStart\n                                                \n                                                var Nestedelement = NestedForLoopMetaData.element\n                                                var NestedelementValue = NestedForLoopMetaData.elementValue\n\n\n                                                function getSourcedata(startIndex, SourcedataTokens, check, StoreResult) {\n                                                    //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n\n\n                                                    let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                                                    StoreResult = Returnvalue.StoreResult\n\n\n                                                    return StoreResult\n\n\n                                                }\n\n\n\n\n                                                NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n\n\n\n                                                NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                                                //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n\n\n\n\n                                                for (Nestediterator; Nestediterator < NestedCycle; Nestediterator++) {\n                                                    {\n\n                                                        let y = Nestediterator\n\n\n                                                        let Nestedforloopindex = CompleteTokenValueList.find(el => el.name == NestedOriginalIterator)\n                                                        //console.log('forloopindex: ', forloopindex);\n\n\n\n                                                        Nestedforloopindex.value = y\n\n\n                                                        for (let index = 0; index < NestedSourcedataTokens.length; index++) {\n\n\n                                                            let el = NestedSourcedataTokens[index]\n\n                                                            if (el.value == 'प्रिंट')\n\n                                                            {\n\n\n\n                                                                IfTokenPrint(NestedSourcedataTokens, CompleteTokenValueList, index, this, y, NestedOriginalIterator)\n\n\n                                                            } else if (el.value == '=' && el.isNestedLoop == true) {\n\n\n                                                                //assigning values to variables\n\n\n                                                                AssignorUpdateValues(NestedSourcedataTokens, index, CompleteTokenValueList, y, NestedOriginalIterator,this)\n\n                                                            } else if (el.type == 'condition' && el.isNestedLoop == true)\n\n\n\n                                                            {\n\n\n\n\n                                                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                                let ConditionStartIndex = index\n                                                                let condition = NestedSourcedataTokens[index].value\n                                                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                                //value of i depends on the conditions\n\n                                                                if (condition.includes('||') || condition.includes('&&'))\n\n                                                                {\n\n\n                                                                    let value = GetConditionValue(condition, CompleteTokenValueList, index)\n                                                                this.LastConditionValue=value\n\n\n\n\n                                                                    if (value == false) {\n\n\n\n                                                                        let BlockLength = 0\n                                                                        let BlockStart = 0\n\n                                                                        while (NestedSourcedataTokens[index].value != '{')\n\n                                                                        {\n\n                                                                            if (NestedSourcedataTokens[index + 1].value == '{')\n\n                                                                            {\n\n\n                                                                                BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                                                                index = BlockLength + index + 1\n\n\n\n\n                                                                                break;\n\n                                                                            }\n\n\n\n                                                                            index++\n                                                                        }\n\n                                                                    } else {\n\n\n                                                                        index = index\n\n\n                                                                    }\n\n\n\n\n                                                                } else {\n\n\n                                                                    let x = HandleConditions(NestedSourcedataTokens, index, CompleteTokenValueList);\n\n\n\n\n                                                                    if (x != undefined) {\n\n\n                                                                        index = x\n\n\n\n                                                                    } else {\n                                                                        index = ConditionStartIndex\n                                                                        //console.log('i: ', i);\n                                                                    }\n\n                                                                }\n\n\n\n\n\n                                                            }\n\n\n\n                                                            //console.log('i: ', i);\n\n                                                            // i = i + NestedSourcedataTokens.length\n                                                            //console.log('i: ', i);\n                                                            else if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop == true)\n\n\n\n\n                                                            {\n                                                                        SetArrayIndexValue(NestedSourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n                                                            }\n\n\n\n\n                                                        }\n\n\n\n\n                                                    }\n\n\n\n\n                                                }\n\n\n\n\n                                            } \n\n                                             else if (SourcedataTokens[i].type== 'AcceptInput' && isNested == false) {\n\n                                       let SetInputValueAs =SourcedataTokens[i].type.AcceptAs\n\n\n\n\n                                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n                                            \n                                            else if (SourcedataTokens[i].value == '=' && isNested == false) {\n\n\n                                                //assigning values to variables\n\n\n                                                AssignorUpdateValues(SourcedataTokens, i, CompleteTokenValueList, iterator, OriginalIterator,this)\n\n\n\n\n                                            }\n\n\n\n\n                                            //Handling print statements in for loop\n                                            else if (SourcedataTokens[i].value == 'प्रिंट' && isNested == false)\n\n\n\n\n                                            {\n\n\n                                                //for operations like print(array[3])\n\n                                                // console.log('for looop prints: ', functionSourceData[i],i);\n\n\n                                                IfTokenPrint(SourcedataTokens, CompleteTokenValueList, i, this, iterator, OriginalIterator)\n\n                                                //\n\n\n                                            }\n\n\n\n                                            //Handling set array element statements in for loop\n                                            else if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                            {\n\n\n\n                                                    SetArrayIndexValue(SourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n                                            }\n\n\n\n                                            // Handling CONDITIONAL statements in for loop\n                                            else if (SourcedataTokens[i].type == 'condition')\n\n\n\n                                            {\n\n\n\n\n                                                //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                let ConditionStartIndex = i\n                                                let condition = SourcedataTokens[i].value\n                                                //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                //value of i depends on the conditions\n\n                                                if (condition.includes('||') || condition.includes('&&'))\n\n                                                {\n\n\n                                                    let value = GetConditionValue(condition, updated_tokens, i)\n                                                                this.LastConditionValue=value\n\n\n\n\n                                                    if (value == false) {\n\n\n\n                                                        let BlockLength = 0\n                                                        let BlockStart = 0\n\n                                                        while (SourcedataTokens[i].value != '{')\n\n                                                        {\n\n                                                            if (SourcedataTokens[i + 1].value == '{')\n\n                                                            {\n\n\n                                                                BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                                                                i = BlockLength + i + 1\n\n\n\n\n                                                                break;\n\n                                                            }\n\n\n\n                                                            i++\n                                                        }\n\n                                                    } else {\n\n\n                                                        i = i\n\n\n                                                    }\n\n\n\n\n                                                } else {\n\n\n                                                    i = HandleConditions(SourcedataTokens, i, CompleteTokenValueList);\n\n\n\n                                                    if (i != undefined) {\n\n\n                                                        i = i\n\n\n                                                    } else {\n                                                        i = ConditionStartIndex\n                                                        //console.log('i: ', i);\n                                                    }\n\n                                                }\n\n\n\n\n                                            }\n\n\n                                        }\n\n\n\n                                    }\n                                    //console.log('j: ', j);\n\n                                    i = i + SourcedataTokens.length\n                                    //console.log('j: ', j);\n\n\n                                } else if (functionSourceData[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n\n\nSetArrayIndexValue(SourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n                                } else if (functionSourceData[i].type == 'WhileLoopStart') {\n\n\n                                    let TokensCurrentIndex = i + 3\n\n\n\n                                    let ConditionValue = false\n\n                                    let element = functionSourceData[i + 1].value\n\n                                    let ExtratcedVariable = []\n\n                                    let variable = ''\n                                    let WhileLoopSourcedataIndexStart = 0\n                                    let WhileLoopSourcedataTokens = []\n\n\n\n                                    for (let i = 0; i < element.length; i++) {\n                                        let x = element.charAt(i)\n\n\n                                        if (isVariable(x))\n\n                                        {\n\n                                            variable = variable + x\n\n\n\n                                        }\n                                        if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n\n                                            let token = CompleteTokenValueList.find(el => el.name == variable)\n\n                                            ExtratcedVariable.push({\n                                                variable: variable,\n                                                value: token.value\n\n                                            })\n\n\n                                            variable = ''\n\n\n                                        }\n\n                                    }\n\n\n\n\n                                    function getWhileLoopSourcedata(startIndex, functionSourceData, check, StoreResult) {\n\n\n\n                                        StoreResult = HandleBlocks(functionSourceData, startIndex, StoreResult)\n\n\n\n                                        return StoreResult\n\n\n\n\n                                    }\n\n\n\n\n                                    WhileLoopSourcedataIndexStart = getLoopIndexStart(functionSourceData, i, '{', WhileLoopSourcedataIndexStart)\n                                    //\n                                    WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, functionSourceData, '}', WhileLoopSourcedataTokens).StoreResult\n\n\n\n\n                                    //constantly accessing the conditionvalue\n\n                                    while (GetConditionValue(element, CompleteTokenValueList, j + 1)) {\n\n                                        for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n\n\n\n\n                                            //SECTION while loop context\n\n                                            if (WhileLoopSourcedataTokens[i].value == '=') {\n\n\n\n\n                                                AssignorUpdateValues(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                                                //\n\n                                                // \n\n\n                                            }\n\n                                               else if (WhileLoopSourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =WhileLoopSourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                            // Handling CONDITIONAL statements in for loop\n                                            else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                                            {\n\n\n\n\n                                                let index = HandleConditions(WhileLoopSourcedataTokens, i, CompleteTokenValueList)\n\n                                                if (index != undefined) {\n                                                    i = index\n\n\n                                                } else {\n                                                    i = i\n                                                }\n\n\n\n\n                                            } else if (WhileLoopSourcedataTokens[i].value == 'प्रिंट')\n\n\n\n\n                                            {\n\n\n                                                IfTokenPrint(WhileLoopSourcedataTokens, CompleteTokenValueList, i, this) //for operations like print(array[3])\n\n\n\n\n                                            } else if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                            {\n\n SetArrayIndexValue(WhileLoopSourcedataTokens,i,j,CompleteTokenValueList,tokens,OriginalIterator,iterator)\n\n\n\n\n                                            }\n\n\n\n                                        }\n\n\n                                    }\n\n                                    i = i + 1 + WhileLoopSourcedataTokens.length + 1\n                                  \n\n                                }\n\n\n\n\n                            }\n\n\n\n\n                        }\n\n\n                        //skipping parsing index so that function context is run by single entity and global execution doesn't run this code too\n                        j = mutable_tokens[j + 1].EndIndex\n\n\n//If we pass function foo(arr) where arr is (suppose) fibonacci=[] declared in the global exe context(updated_tokens). But operation will be performed on\n//arr in functionContextupdated_tokens. so at the end of fucntion execution we set the value to it's right owner.\n                        let token=functionContextupdated_tokens.find(el=>el.IntheEndSetValueto!='')\n                        let GivePowersTo= updated_tokens.find(el=>el.name==token.IntheEndSetValueto)\n                        \n                        GivePowersTo.value=token.value\n\nconsole.log('updated_tokens: ', updated_tokens);\n\n\n                    } else if (tokenType == 'condition')\n\n                    {\n\n\n\n\n                        let element = mutable_tokens[j].value\n                        console.log('element: ', element);\n\n                        //this function is the first step to calculate value of operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n\n                        let ConditionValue = GetConditionValue(element, updated_tokens, j)\n                        console.log('ConditionValue: ', ConditionValue);\n                         this.LastConditionValue=ConditionValue\n\n                        // console.log('ConditionValue: ', ConditionValue);\n                        //  console.log('j: ',j);\n\n\n\n\n                        //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                        if (ConditionValue == false) {\n\n                            let InitializeLoop = tokens.indexOf(mutable_tokens[j])\n\n                            //Handle Blocks is a function which takes care of nested block by taking care of nested { and } brackets\n                            //it uses the stack to push and pop brackets to accurately identify start and the end of the block\n                            let Returnvalue = HandleBlocks(mutable_tokens, j)\n\n                            j = Returnvalue.j\n                        }\n\n\n\n\n                    } else if (token == 'प्रिंट')\n\n\n                    {\n\n                        IfTokenPrint(mutable_tokens, updated_tokens, j, this) //for operations like print(array[3])\n\n\n\n\n                    } else if (tokenType == 'WhileLoopStart') {\n\n\n                        let TokensCurrentIndex = j + 3\n\n                        let ConditionValue = false\n\n                        let element = mutable_tokens[j + 1].value\n\n                        let ExtratcedVariable = []\n\n                        let variable = ''\n                        let WhileLoopSourcedataIndexStart = 0\n                        let WhileLoopSourcedataTokens = []\n\n\n\n                        for (let i = 0; i < element.length; i++) {\n                            let x = element.charAt(i)\n\n\n                            if (isVariable(x))\n\n                            {\n\n                                variable = variable + x\n\n\n\n                            }\n                            if (!isVariable(element.charAt(i + 1)) && isVariable(x)) {\n\n                                let token = updated_tokens.find(el => el.name == variable)\n\n                                ExtratcedVariable.push({\n                                    variable: variable,\n                                    value: token.value\n\n                                })\n\n\n                                variable = ''\n\n\n                            }\n\n                        }\n\n\n\n\n                        function getWhileLoopSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n\n\n\n                            StoreResult = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n\n\n\n                            return StoreResult\n\n\n\n\n                        }\n\n\n\n\n                        WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart)\n                        //\n                        WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, '}', WhileLoopSourcedataTokens).StoreResult\n                        console.log('WhileLoopSourcedataTokens: ', WhileLoopSourcedataTokens);\n\n\n\n\n                        //constantly accessing the conditionvalue\n\n                        while (GetConditionValue(element, updated_tokens, j + 1)) {\n\n                            for (let i = 0; i < WhileLoopSourcedataTokens.length; i++) {\n\n\n\n\n                                //SECTION while loop context\n\n                                if (WhileLoopSourcedataTokens[i].value == '=') {\n\n\n\n\n                                    AssignorUpdateValues(WhileLoopSourcedataTokens, i, updated_tokens)\n\n                                    //\n\n                                    // \n\n\n                                }\n\n                                  else if (WhileLoopSourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =WhileLoopSourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n                                    console.log('value: ', value);\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                // Handling CONDITIONAL statements in for loop\n                                else if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                                {\n\n\n\n\n                                    let index = HandleConditions(WhileLoopSourcedataTokens, i, updated_tokens)\n                                 \n\n\n                                    if (index != undefined) {\n                                        i = index\n\n\n                                    } else {\n                                        i = i\n                                    }\n\n\n\n\n                                } else if (WhileLoopSourcedataTokens[i].value == 'प्रिंट')\n\n\n\n\n                                {\n\n\n                                    IfTokenPrint(WhileLoopSourcedataTokens, updated_tokens, i, this) //for operations like print(array[3])\n\n\n\n\n                                } else if (WhileLoopSourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n SetArrayIndexValue(WhileLoopSourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n\n                                }\n\n\n\n                            }\n\n\n                        }\n                    } else if (tokenType == 'ForLoopStart')\n\n\n\n                    {\n\n                        var FlagPrimalLoop = 0\n\n                        var SourcedataTokens = []\n\n\n                        //console.log('updated_tokens: ', updated_tokens);\n\n                        let ForLoopMetaData = ForLoopSetMetadata(mutable_tokens, j, updated_tokens)\n\n                        //console.log('ForLoopMetaData: ', ForLoopMetaData);\n\n                        var ForLoopSourcedataIndexStart = ForLoopMetaData.ForLoopSourcedataIndexStart\n                        var Cycle = ForLoopMetaData.Cycle\n                        var OriginalIterator = ForLoopMetaData.OriginalIterator\n                        var IterationStart = ForLoopMetaData.IterationStart\n                        var iterator = ForLoopMetaData.iterator\n                        var element = ForLoopMetaData.element\n                        var elementValue = ForLoopMetaData.elementValue\n\n                        function getSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n                            //console.log('startIndex, mutable_tokens, check, StoreResult: ', startIndex, mutable_tokens, check, StoreResult);\n\n\n\n                            let Returnvalue = HandleBlocks(mutable_tokens, startIndex, StoreResult)\n                            StoreResult = Returnvalue.StoreResult\n\n\n                            return StoreResult\n\n\n                        }\n\n\n\n\n                        ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart)\n\n                        //\n\n                        SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, '}', SourcedataTokens)\n                        //console.log('SourcedataTokens: ', SourcedataTokens);\n\n\n\n                        SourcedataTokens.forEach(el => {\n\n                            el.isNestedLoop = false\n\n                        })\n\n\n                        let FindNestedLoop = SourcedataTokens.find(el => el.type == 'ForLoopStart')\n                        \n                        \n                        if (FindNestedLoop != undefined) {\n\n                            let NestedLoopindex = SourcedataTokens.indexOf(FindNestedLoop) + 3\n                            let NestedLooplength = (SourcedataTokens[NestedLoopindex].EndIndex - SourcedataTokens[NestedLoopindex].startIndex) + 2\n                            \n                            \n\n\n                            for (let x = NestedLoopindex; x < NestedLoopindex + NestedLooplength; x++) {\n\n\n                                SourcedataTokens[x].isNestedLoop = true\n                                \n                                \n\n                            }\n\n\n                        }\n\n\n\n\n                        if (element.includes('(') && element.includes(','))\n\n\n                        {\n\n                            FlagPrimalLoop = 1\n\n\n                        }\n\n\n\n                        // console.log('Cycle: ', Cycle,IterationStart);\n\n\n                        //Iterating over forloop sourcedata\n                        //this line 'iterator <= Cycle' determines start of the loop and the duration of the loop\n\n                        for (iterator = IterationStart; iterator <= Cycle; iterator++) {\n\n\n\n                            let forloopindex = updated_tokens.find(el => el.name == OriginalIterator)\n\n\n\n\n                            forloopindex.value = iterator\n\n                            //console.log('updated_tokens: ', updated_tokens);\n\n                            //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                            if (FlagPrimalLoop = 0) {\n                                ForLoopArrayorStringOutput(elementValue, iterator, updated_tokens, this)\n\n                            }\n\n\n                            for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                            {\n\n\n                                let isNested = SourcedataTokens[i].isNestedLoop\n\n\n                                if (SourcedataTokens[i].type == 'ForLoopStart') {\n\n                                    var NestedFlagPrimalLoop = 0\n\n                                    var NestedSourcedataTokens = []\n\n                                    let NestedForLoopMetaData = ForLoopSetMetadata(SourcedataTokens, i, updated_tokens)\n\n                                    //  console.log('NestedForLoopMetaData: ', NestedForLoopMetaData);\n\n                                    var NestedForLoopSourcedataIndexStart = NestedForLoopMetaData.ForLoopSourcedataIndexStart\n                                    var NestedCycle = NestedForLoopMetaData.Cycle + 1\n                                    var NestedOriginalIterator = NestedForLoopMetaData.OriginalIterator\n                                    var NestedIterationStart = NestedForLoopMetaData.IterationStart\n                                    var Nestediterator = NestedForLoopMetaData.IterationStart\n                                    var Nestedelement = NestedForLoopMetaData.element\n                                    var NestedelementValue = NestedForLoopMetaData.elementValue\n\n\n                                    function getSourcedata(startIndex, SourcedataTokens, check, StoreResult) {\n                                        //console.log('startIndex, SourcedataTokens, check, StoreResult: ', startIndex, SourcedataTokens, check, StoreResult);\n\n\n\n                                        let Returnvalue = HandleBlocks(SourcedataTokens, startIndex, StoreResult)\n                                        StoreResult = Returnvalue.StoreResult\n\n\n                                        return StoreResult\n\n\n                                    }\n\n\n\n\n                                    NestedForLoopSourcedataIndexStart = getLoopIndexStart(SourcedataTokens, i, '{', NestedForLoopSourcedataIndexStart)\n                                    //console.log('ForLoopSourcedataIndexStart: ', ForLoopSourcedataIndexStart);\n\n\n\n                                    NestedSourcedataTokens = getSourcedata(NestedForLoopSourcedataIndexStart, SourcedataTokens, '}', NestedSourcedataTokens)\n                                    //console.log('NestedSourcedataTokens: ', NestedSourcedataTokens);\n\n\n\n\n                                    for (Nestediterator; Nestediterator < NestedCycle; Nestediterator++) {\n                                        {\n\n                                            let y = Nestediterator\n\n\n                                            let Nestedforloopindex = updated_tokens.find(el => el.name == NestedOriginalIterator)\n                                            //console.log('forloopindex: ', forloopindex);\n\n\n\n                                            Nestedforloopindex.value = y\n\n\n                                            for (let index = 0; index < NestedSourcedataTokens.length; index++) {\n\n\n                                                let el = NestedSourcedataTokens[index]\n\n                                                if (el.value == 'प्रिंट')\n\n                                                {\n\n\n\n                                                    IfTokenPrint(NestedSourcedataTokens, updated_tokens, index, this, y, NestedOriginalIterator)\n\n\n                                                } else if (el.value == '=' && el.isNestedLoop == true) {\n\n\n                                                    //assigning values to variables\n\n\n                                                    AssignorUpdateValues(NestedSourcedataTokens, index, updated_tokens, y, NestedOriginalIterator)\n\n                                                } else if (el.type == 'condition' && el.isNestedLoop == true)\n\n\n\n                                                {\n\n\n\n\n                                                    //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                                    let ConditionStartIndex = index\n                                                    let condition = NestedSourcedataTokens[index].value\n                                                    //HandleConditions evaluates condition and return the index of from where printing should resume\n                                                    //value of i depends on the conditions\n\n                                                   \n\n                                                        let value = GetConditionValue(condition, updated_tokens, index)\n                                                        \n                                                                this.LastConditionValue=value\n\n\n\nif(value==false)\n{\n\n    break\n\n\n\n\n}\n\n\n\n\n\n                                                      /*  if (value == false) {\n\n\n\n                                                            let BlockLength = 0\n                                                            let BlockStart = 0\n\n                                                            while (NestedSourcedataTokens[index].value != '{')\n\n                                                            {\n\n                                                                if (NestedSourcedataTokens[index + 1].value == '{')\n\n                                                                {\n\n\n                                                                    BlockLength = NestedSourcedataTokens[index + 1].EndIndex - NestedSourcedataTokens[index + 1].startIndex\n\n                                                                    index = BlockLength + index + 1\n\n\n\n\n                                                                    break;\n\n                                                                }\n\n\n\n                                                                index++\n                                                            }\n\n                                                        } else if(value==true) {\n\n\nconsole.log(el,NestedSourcedataTokens,index);\n\n                                                        }\n\n\n\n\n*/\n                                                  \n\n\n\n                                                }\n\n\n\n                                               \n\n                                                // i = i + NestedSourcedataTokens.length\n                                                //console.log('i: ', i);\n                                                else if (el.type == \"SetArrayIndexValue\" && el.isNestedLoop == true)\n\n\n\n\n                                                {\n\n                                                    \n\n                                                        SetArrayIndexValue(NestedSourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                                                }\n\n\n\n\n                                            }\n\n\n\n\n                                        }\n\n\n\n\n                                    }\n\n\n\n\n                                } else if (SourcedataTokens[i].value == '=' && isNested == false) {\n\n                                    //assigning values to variables\n\n                                    AssignorUpdateValues(SourcedataTokens, i, updated_tokens, iterator, OriginalIterator)\n\n                                }\n\n else if(SourcedataTokens[i].type=='PushToArray')\n \n                    {\n\nconsole.log('SourcedataTokens[i]: ', SourcedataTokens);\nlet token=SourcedataTokens[i].value\n\ntoken=token.replace('पुश','')\nlet Split=token.split('.')\nlet Array=Split[0]\nlet ElementtoPush=RemoveBrackets(Split[1])\nElementtoPush=updated_tokens.find(el=>el.name==ElementtoPush).value\n\nlet ArrayEl=updated_tokens.find(el=>el.name==Array)\n\n\nlet ArrayValue=ArrayEl.value\nif(ArrayValue=='[]')\n{\nArrayValue= ArrayValue.split(',')\n}\nArrayValue.push(ElementtoPush)\n\n\nlet index=updated_tokens.indexOf(ArrayEl)\n\nArrayValue=ArrayValue.filter(el=> el!='[]')\n\n\n\n\n\n\n\nupdated_tokens[index].value=ArrayValue\n \n\n\n                    }\n\n\n  else if (SourcedataTokens[i].type== 'AcceptInput' ) {\n\n                        let SetInputValueAs =SourcedataTokens[i].type.AcceptAs\n\n\n\n\n                        var value=prompt('Enter Value for' + SetInputValueAs)\n\n\n                                       updated_tokens.push({\n                                    name: SetInputValueAs,\n\n                                    value: value,\n\n                                    \n                                })\n\n\n\n                       \n\n\n\n\n                    }\n\n\n\n                                //Handling print statements in for loop\n                                else if (SourcedataTokens[i].value == 'प्रिंट' && isNested == false)\n\n\n\n\n                                {\n\n                                    //for operations like print(array[3])\n\n                                    // console.log('for looop prints: ', SourcedataTokens[i],i);\n\n\n                                    IfTokenPrint(SourcedataTokens, updated_tokens, i, this, iterator, OriginalIterator)\n\n                                    //\n\n\n                                }\n\n\n\n                                //Handling set array element statements in for loop\n                                else if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                                {\n\n                                   SetArrayIndexValue(SourcedataTokens,i,j,updated_tokens,tokens,OriginalIterator,iterator)\n\n\n\n                                }\n\n\n\n                                // Handling CONDITIONAL statements in for loop\n                                else if (SourcedataTokens[i].type == 'condition')\n\n\n\n                                {\n\n\n\n\n                                    //console.log('SourcedataTokens[i]: ', SourcedataTokens[i],i);\n\n                                    let ConditionStartIndex = i\n                                    let condition = SourcedataTokens[i].value\n                                    //HandleConditions evaluates condition and return the index of from where printing should resume\n                                    //value of i depends on the conditions\n\n                                    if (condition.includes('||') || condition.includes('&&'))\n\n                                    {\n\n\n                                        let value = GetConditionValue(condition, updated_tokens, i)\n\n                                                                this.LastConditionValue=value\n\n\n                                        if (value == false) {\n\n\n\n                                            let BlockLength = 0\n                                            let BlockStart = 0\n\n                                            while (SourcedataTokens[i].value != '{')\n\n                                            {\n\n                                                if (SourcedataTokens[i + 1].value == '{')\n\n                                                {\n\n\n                                                    BlockLength = SourcedataTokens[i + 1].EndIndex - SourcedataTokens[i + 1].startIndex\n\n                                                    i = BlockLength + i + 1\n\n\n\n\n                                                    break;\n\n                                                }\n\n\n\n                                                i++\n                                            }\n\n                                        } else {\n\n\n                                            i = i\n\n\n                                        }\n\n\n\n\n                                    } else {\n\n\n                                        i = HandleConditions(SourcedataTokens, i, updated_tokens);\n\n\n\n                                        if (i != undefined) {\n\n\n                                            i = i\n\n\n                                        } else {\n                                            i = ConditionStartIndex\n                                            //console.log('i: ', i);\n                                        }\n\n                                    }\n\n\n\n\n                                }\n\n\n                            }\n\n\n\n                        }\n                        //console.log('j: ', j);\n\n                        j = j + SourcedataTokens.length\n                        //console.log('j: ', j);\n\n\n                    }\n\n                    //END FOR LOOP EXECUTION\n\n\n\n\n                }\n\n\n\n\n                \n\n\n //To find undefined variables\n               \n                //\n\n\nconsole.log(updated_tokens);\n\nfunction onlyUnique(value, index, self) { \n    return self.indexOf(value) === index;\n}\n\nvar assigned_variables=assigned_variables.filter(onlyUnique)\n\nlet difference= variables_array.filter(x=> !assigned_variables.includes(x))\n\n                if (difference.length > 0)\n\n                {\n\n                    difference.forEach(el=>{\n\n\n                    this.error.push('Variable ' + el + ' is undefined ')\n\n\n                    })\n                    \n\n                }\n\n              if(this.error.length>0)\n              {\n\nthis.linebylineOutput=this.error\n\n\n              }\n\nelse{\n\n                this.linebylineOutput = this.output.split('\\n')\n                \n}\n\n\n\n\nvar t1 = performance.now()\n                if (this.linebylineOutput!= '' && this.error.length==0) {\n                    this.TimeTaken = \"Compiled Succesfully in \" + (t1 - t0).toPrecision(4) + \" ms.\"\n\n                }\n\n                else{\n\n                    this.isError = true\n\n                    this.TimeTaken = \"Compilation Error:\" + this.error.length + ' Errors to be fixed'\n\n\n                }\n\n\n               \n               this.linebylineOutput = this.linebylineOutput.filter(function(item) {\n                   \n                    return item !== \"\"\n                })\n\n\n\n                //SECTION - Calculating remaining values\n\n\n                //so that replace x with values\n\n                /*\n                            updated_tokens.forEach((el, i) => {\n                                \n\n\n                                let element = el.value\n\n\n                                //removing the \"(\"\" and \")\"\n\n\n                                var CleanedElement = RemoveBrackets(element)\n\n                                operation = ''\n\n\n\n                                //why pureeval?\n                                // operations like 50+60 were set as [5,0,+,6,0] instead of [50,+,60]. basically direct calculation was not working\n                                //pureeval finds such pure operations and then calculate them to directly set their value\n                                //this shit is only for pureoperations\n                                let pureval = /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedElement)\n\n                                if (pureval == true) {\n\n\n\n                                    updated_tokens[i].value = eval(updated_tokens[i].value)\n\n\n                                }\n\n\n\n\n                                if (isCalculation(CleanedElement) == true && !pureval) {\n\n                                    terms = CleanedElement.split('')\n\n\n\n                                }\n\n\n\n\n                            })\n\n\n\n\n                            //\n\n                            // performing calculations\n\n\n\n\n                            updated_tokens.forEach((el, i) => {\n\n                                var indextoChange = '' //to know which value to replace like \"anna+dada-bad\" with \"5+6-7\"\n\n\n\n                                let element = el.value // reading the current value, for lon string variable names it's still like \"anna+dada-bad\"\n                                element = element.toString()\n                                var StringVar = []\n                                // \n\n                                let pureval = /^([-+]?[a-z]*\\.?[a-z]+[\\/\\+\\-\\*])+([-+]?[a-z]*\\.?[a-z]+)*$/gm.test(element)\n\n\n\n                                if (element.includes('>') || element.includes('<') || element.includes('==')) {\n\n\n\n                                    StringVar = SplitElementsArray(element)\n\n\n\n                                    StringVar = SetValues(StringVar, updated_tokens)\n\n\n                                    UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n\n\n                                }\n\n\n                                //finding operations like a+b-c\n                                if (pureval == true || element.charAt(0) == \"(\") {\n\n                                    // \n\n\n                                    StringVar = SplitElementsArray(element)\n                                    StringVar = SetValues(StringVar, updated_tokens)\n                                    UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n                                }\n\n\n\n\n                            })\n\n\n\n\n                            /*\n                             ReIntializedVariables.forEach(el=>{\n\n                            let flag=0\n                            let SkipIndex=0\n\n                            for(let m=0;m<updated_tokens.length;m++)\n                            {\n                                \n                            if(el.name==updated_tokens[m].name && flag==0)\n                            {\n\n\n                            if(el.value.charAt(0)=='\"')\n                            {\n\n\n                                let BuiltString= BuildString(el.value, )\n\n                                \n                            }\n                            flag=1;\n                            updated_tokens[m].value=el.value;\n\n\n                            \n\n                            SkipIndex=m\n\n\n                            }\n\n                            //\n\n                            if( m!=SkipIndex && flag==1 && el.name==updated_tokens[m].name)\n\n                            {\n\n                            updated_tokens.splice(m,1)\n\n                            }\n\n\n                            }\n\n\n\n\n                            })\n                            */\n\n\n\n\n                //SECTION - Iterating over tokens and then PRINTING FINAL using values stored in updated tokens\n\n                /*        \n\n            for (var j = 0; j < tokens.length; j++) {\n\n\n                var mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n             \n\n                if (token == 'प्रिंट' )\n\n                {\n\n                    var b = RemoveBrackets(mutable_tokens[j+1].value)\n\n\n\n\n                    variables_array.push(b)\n\n                    \n\n                 \n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n                    updated_tokens.forEach((el, i) => {\n\n                        if (el.name == b ) {\n\n\n\n                            this.output = this.output + el.value + \"\\n\";\n\n                            assigned_variables.push(el.name);\n\n                           \n\n\n                        }\n\n\n\n                        // work to be continued\n\n                    })\n\n                    \n\n                    \n\n                }\n\n\n                //Handling Conditions\n\n                if(mutable_tokens[j].type==\"condition\")\n                {\n\n\n\n                   \n\n                    let token= updated_tokens.find(el=> el.originalvalue==mutable_tokens[j].value)\n\n\n\n                    let ConditionValue=token.value\n\n                  \n\n                   if(ConditionValue==false)\n                   {\n\nlet InitializeLoop= tokens.indexOf(mutable_tokens[j])\n\n\n\n\n\nwhile(mutable_tokens[j+1].value!='}' )\n{\n\n\n\n    let x= mutable_tokens[j+1].value.length\n    \n    \ntokens.splice(j+1, 1);\n \n\n    j++;\n\n\n}\n\n\n\n\n                   }\n\n\n                }\n\n\n                if(token == 'प्रिंट' && /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(mutable_tokens[j+1].value) )\n                {\n \n                let a= eval(mutable_tokens[j+1].value)\n\n                this.output = this.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n                \n\n        \n              \n\n\n\n\n      // this is to handle प्रिंट (\"Age is\"+ Age) etc.\n\n                if(isStringandValue(mutable_tokens[j].value))\n{\n\n\n        \n\n                    let x=mutable_tokens[j].value\n                    let string=''\n                    let newel=''\n\n                    x=RemoveBrackets(x)\n\n                    \n                    //x = x.replace(/ /g,'')\n\n                    x=x.split(\"+\")\n\n                    \n\n                    x.forEach(element => {\n                        \n\n                        \n                        if(element.charAt(0)== \" \" || element.charAt(element.length-1)==\" \" && !(element.includes('\"'))){\n\n                          \n                       newel= element.replace(/\\s/g, '');\n\n                        \n\n\n                        }\n                        else{\n\n                            newel=element\n                        }\n\n                       let y= updated_tokens.find(el=> el.name== newel)\n\n                      \n                       \n//\n                       if(y!=undefined)\n                       {\n\n\n\n                       string=string + ' ' + y.value\n                       //\n\n\n                       }\n                       else{\n\n                           \n                           element= element.replace(/\"/g, '');\n                           string=string+ ' ' + element\n                       }\n                       \n\n                       \n\n                    });\n\n\n\n                        this.output = this.output + \"\\n\" + string + \"\\n\"\n}\n\n\n//THIS IS to handle operations like प्रिंट (\"Name is GOAT\"), प्रिंट (\"Goodbye\")\n\nelse{\n\n\n\n                  let value= RemoveBrackets(mutable_tokens[j].value)\n                 // \n\n                  \n\n                   let CleanedValue = value.replace(/ /g,'')\n\n                    \n\n\n                   if(/^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedValue)!=true)\n\n                   {\n\n                 // \n\n                    value = value.replace(/\"/g, \"\");\n                    value = value.replace(/'/g, \"\");\n\n\n\n                        this.output = this.output + \"\\n\" + value + \"\\n\" \n }\n                        \n\n}\n\n\n            }\n\n\n           \n            })\n\n        }\n        */\n\n\n        }\n\n    }\n\n}; \n</script>\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n\n\n#bharatP{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace\n}\n#versionNumber{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace;\n    padding-left: 6%\n}\n\n#version{\n\n    margin: 0;\n    float: left;\n    color: #92924c;\n    font-size: 90%;\n\n}\n\n#bharatDIV{\n\n    padding-top: 2%;\n    padding-left: 2%\n\n}\n\n\n#linebylineOutput\n{\n\n\n\nheight: 10px;\n    text-align: left;\n    \n\n\n}\n#errorstack{\n\ntext-align: left;\npadding-left: 2.5%;\npadding-top: 6%;\nfont-weight: bold;\ncolor:rgb(231, 83, 83);\n\n}\n\n#compiler{\n\n  display: flex;\n}\n\n#textarea{\n\n  width: 50%\n}\n#output{\n\n  height: 400px;\n  width: 50%;\n  background-color: black;\n    color: white;\n    overflow: auto\n  \n}\nh3 {\n  margin: 40px 0 0;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n\n.hello {\n  display: grid;\n}\n\n#codearea {\n  width: 90%;\n  height: 400px;\n  background-color: whitesmoke;\n    font-family: monospace;\n    font-size: medium;\n    border: none;\n    outline: none;\n}\n\n#subm {\n  width: 17%;\n  height: 50px;\n}\n</style>"]}]}