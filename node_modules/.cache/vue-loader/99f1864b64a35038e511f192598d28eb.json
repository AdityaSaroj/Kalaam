{"remainingRequest":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/jonny/Documents/Work/test/BharatBackup/src/components/HelloWorld.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/jonny/Documents/Work/test/BharatBackup/src/components/HelloWorld.vue","mtime":1588269515460},{"path":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jonny/Documents/Work/test/BharatBackup/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7CiAgICBTb3VyY2VEYXRhUmVwbGFjZWZvckVhc3lQYXJzaW5nCn0gZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL2Z1bmN0aW9ucycKaW1wb3J0ICogYXMgVHlwZUNoZWNrIGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9UeXBlQ2hlY2tpbmcnCmltcG9ydCAqIGFzIEFkdmFuY2VkVHlwZUNoZWNrIGZyb20gJy4uL0Z1bmN0aW9uU2NyaXB0cy9BZHZhbmNlZFR5cGVDaGVja2luZycKaW1wb3J0ICogYXMgQnVpbGRPcGVyYXRpb24gZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL0J1aWxkT3BlcmF0aW9ucycKaW1wb3J0IHsKICAgIFB1c2hBcnJheSwKICAgIFB1c2hDYWxjdWxhdGlvbiwKICAgIFB1c2hDb25kaXRpb25hbEtleXdvcmQsCiAgICBQdXNoQ29uZGl0aW9uLAogICAgUHVzaEZvckxvb3AsCiAgICBQdXNoV2hpbGVMb29wLAogICAgUHVzaFdoaWxlTG9vcENvbmRpdGlvbiwKICAgIFB1c2hGb3JMb29wQXJ1Z3VtZW50cywKICAgIFB1c2hFeHByZXNzaW9uLAogICAgUHVzaEtleXdvcmQsCiAgICBQdXNoTnVtYmVyLAogICAgUHVzaE9wZXJhdG9yLAogICAgUHVzaFJlYWxUaW1lUHJpbnRPcGVyYXRpb24sCiAgICBQdXNoU3RyaW5nLAogICAgUHVzaFN0cmluZ2FuZFZhbHVlT3BlcmF0aW9uLAogICAgUHVzaFZhcmlhYmxlLAogICAgUHVzaEVtcHR5QXJyYXlJbml0Cn0gZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL1B1c2hGdW5jdGlvbnMnCmltcG9ydCB7CiAgICBSZW1vdmVCcmFja2V0cywKICAgIGlzQXJyYXlPcGVyYXRpb24sCiAgICBDcmVhdGVBcnJheUVsZW1lbnQsCiAgICBDYWxjdWxhdGVWYWx1ZXMsCiAgICBHZXRBcnJheW9yU3RyaW5nRWxlbWVudCwKICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50LAogICAgUHJpbnRBcnJheUVsZW1lbnQsCiAgICBoYW5kbGVtdWx0Q29uZGl0aW9ucywKICAgIFNwbGl0RWxlbWVudHNBcnJheSwKICAgIFNldFZhbHVlcywKICAgIFB1c2hTZXRBcnJheUluZGV4VmFsdWUsCiAgICBVcGRhdGVVcGRhdGVkX3Rva2Vuc3dpdGhWYWx1ZXMsCiAgICBHZXRDb25kaXRpb25WYWx1ZSwKICAgIEZvckxvb3BBcnJheW9yU3RyaW5nT3V0cHV0LAogICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMsCiAgICBIYW5kbGVDb25kaXRpb25zCn0gZnJvbSAnLi4vRnVuY3Rpb25TY3JpcHRzL01pc2NJbXBvcnRhbnRGdW5jdGlvbnMnCgoKZXhwb3J0IGRlZmF1bHQgewogICAgbmFtZTogIkhlbGxvV29ybGQiLAogICAgcHJvcHM6IHsKICAgICAgICBtc2c6IFN0cmluZwogICAgfSwKCiAgICBkYXRhKCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGNvZGU6ICdOYW1lPSJTd2FuYW5kIEthZGFtIiBOYW1lPSJTd2FuYW5kIEthZGFtIGlzIGdvYXQiIEFycmF5PVsgMjAsMzAsInN3YW5hbmQiXSBBZ2U9MjAyMC0xOTk2IGFnZW9uZT0yMCBhZ2V0d289MzAgeD1hZ2VvbmUrYWdldHdvIENpdHk9IlB1bmUiIOCkquCljeCksOCkv+CkguCknyAoeCkgIOCkquCljeCksOCkv+CkguCknyAoTmFtZSkgIOCkquCljeCksOCkv+CkguCknyAoIllvdSBsaXZlLCB5b3UgbGVhcm4iKSAg4KSq4KWN4KSw4KS/4KSC4KSfIChBZ2UpICDgpIXgpJfgpLAgKGFnZW9uZT5hZ2V0d28pIHvgpKrgpY3gpLDgpL/gpILgpJ8gKCJjb25kaXRpb24gd29ya2VkIil9IOCkquCljeCksOCkv+CkguCknyAoQXJyYXlbMl0gKyBBZ2UgKyAiaXMgeW91bmcgYWdlIiArIEFnZSkg4KSF4KSX4KSwIChhZ2VvbmU9PTIwKSB74KSq4KWN4KSw4KS/4KSC4KSfICgiY29uZGl0aW9uIDIgd29ya2VkIikgeT14K2FnZW9uZSDgpKrgpY3gpLDgpL/gpILgpJ8gKHkpIH0nLAogICAgICAgICAgICBvdXRwdXQ6ICcnLAogICAgICAgICAgICBlcnJvcjogW10sCiAgICAgICAgICAgIE9wZXJhdGlvbk9iamVjdHM6IFtdLAogICAgICAgICAgICBsaW5lYnlsaW5lT3V0cHV0OiAnJywKICAgICAgICAgICAgVGltZVRha2VuOicnCgogICAgICAgIH07CiAgICB9LAoKICAgIG1ldGhvZHM6IHsKICAgICAgICBSVU46IGZ1bmN0aW9uKCkgewoKICAgICAgICAgICAgdmFyIHQwID0gcGVyZm9ybWFuY2Uubm93KCkKCiAgICAgICAgICAgIC8vdG8gc3RvcCBhY2N1bXVsYXRpbmcgb3V0cHV0IG9uIHN1Y2Nlc2l2ZSBSVU4KICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSAnJwogICAgICAgICAgICB0aGlzLmxpbmVieWxpbmVPdXRwdXQgPSB0aGlzLm91dHB1dC5zcGxpdCgiXG4iKQogICAgICAgICAgICB0aGlzLmVycm9yID0gW10KICAgICAgICAgICAgdGhpcy5PcGVyYXRpb25PYmplY3RzID0gW10KICAgICAgICAgICAgdmFyIHNvdXJjZWRhdGEgPSB0aGlzLmNvZGU7CiAgICAgICAgICAgIHZhciBjbGVhbmVkX3NvdXJjZWRhdGEgPSBbXQogICAgICAgICAgICB2YXIgaSA9IDA7CiAgICAgICAgICAgIHZhciB0b2tlbnMgPSBbXTsKICAgICAgICAgICAgdmFyIG1peGVkaW1wdXJpdHkgPSBbXQogICAgICAgICAgICB2YXIgdXBkYXRlZF90b2tlbnMgPSBbXQogICAgICAgICAgICB2YXIgdmFyaWFibGVzX2FycmF5ID0gW10KICAgICAgICAgICAgdmFyIGFzc2lnbmVkX3ZhcmlhYmxlcyA9IFtdCiAgICAgICAgICAgIHZhciB0ZXJtcyA9IFtdCiAgICAgICAgICAgIHZhciB0ZXJtczIgPSBbXQogICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gJycKICAgICAgICAgICAgdmFyIENhbGN1bGF0aW9uU3RhY2sgPSBbXQogICAgICAgICAgICB2YXIgZm91bmRUb2tlbiA9ICcnCiAgICAgICAgICAgIHZhciBSZUludGlhbGl6ZWRWYXJpYWJsZXMgPSBbXQoKCgoKICAgICAgICAgICAgLy9wcmVwYXJpbmcgc291cmNlZGF0YSBmb3IgZWFzeSBwYXJzaW5nIGJ5IGhhbmRsaW5nIG5ldyBsaW5lcywgZW50ZXJzIGV0Yy4KICAgICAgICAgICAgLy9jbGVhbmluZyB1cCB0aGUgZGF0YSB0byBnZXQgbXkgdmVyc2lvbiBvZiBzb3VyY2VkYXRhLiBpdCdzIGJldHRlciB0byBnZXQgdmVyc2lvbiBzdWl0YWJsZSBmb3IgbWUgYmVjYXVzZSB1c2VycyBjYW4gdHlwZSB3aGF0IHRoZXkgd2lzaCBidXQgSSBuZWVkIHRvIG1haW50YWluIAogICAgICAgICAgICAvL2ludGVncml0eSBvZiBwcm9ncmFtIGluIGV2ZXJ5IHBvc3NpYmxlIGNvbmRpdGlvLiBTby4gSSBjcmVhdGVkIG15IG93biBjb25kaXRpb24gYmVsb3cKCiAgICAgICAgICAgIGZ1bmN0aW9uIEdldENsZWFuU291cmNlZGF0YShzb3VyY2VkYXRhLCBjbGVhbmVkX3NvdXJjZWRhdGEsIGltcHVyaXRpZXMpIHsKCiAgICAgICAgICAgICAgICBzb3VyY2VkYXRhID0gU291cmNlRGF0YVJlcGxhY2Vmb3JFYXN5UGFyc2luZyhzb3VyY2VkYXRhKQoKICAgICAgICAgICAgICAgIHNvdXJjZWRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4gewoKCiAgICAgICAgICAgICAgICAgICAgLy9maW5kaW5nIHRoZSBlbGVtZW50cyB3aGljaCBoYXMgPSIgaW4gaXQgc28gdGhhdCB0byBzZXByYXRlIHRoZW0gZS5nLiBhbm5hPSJzd2FuYW5kIiBhbHNvIGZpbmRpbmcgdGhlIGVsZW1lbnRzIHdoaWNoIHN0YXJ0cyB3aXRoID0uIGUuZyAiPTc4Nzg3ODkwIgoKCiAgICAgICAgICAgICAgICAgICAgaWYgKChlbGVtZW50LmluZGV4T2YoJz0iJykgPiAtMSB8fCBlbGVtZW50LmluZGV4T2YoJz0nKSA+IDAgfHwgZWxlbWVudC5jaGFyQXQoMCkgPT0gIj0iKSAmJiBlbGVtZW50ICE9ICc9PScpCgoKICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXRpZXMucHVzaChlbGVtZW50KSAvL3B1c2ggc3VjaCBlbGVtZW50IGFzIGltcHVyaXR5IGluIGltcHVyaXRpZXMKCgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gZWxlbWVudC5zcGxpdCgiPSIpCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGNsZWFuZWRfc291cmNlZGF0YS5sZW5ndGgKCgogICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGFbaW5kZXhdID0gKGVsZW1lbnRzWzBdKQogICAgICAgICAgICAgICAgICAgICAgICBjbGVhbmVkX3NvdXJjZWRhdGFbaW5kZXggKyAxXSA9ICgiPSIpCiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YVtpbmRleCArIDJdID0gKGVsZW1lbnRzWzFdKQoKCiAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgLy9hcyBsb25nIGFzIGVsZW1lbnQgaXMgcHVyZSwgcHVzaCBpdCB0byBuZXcgYW5kIGNsZWFuIHZlcnNpb24gb2Ygc291cmNlZGF0YQogICAgICAgICAgICAgICAgICAgIGlmICghaW1wdXJpdGllcy5pbmNsdWRlcyhlbGVtZW50KSkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YS5wdXNoKGVsZW1lbnQpCgogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAvL3JlbW92aW5nIGVtcHR5ICIiIHZhbHVlcyBmb3IgZmluYWwgdmVyc2lvbiBvZiBzb3VyY2VkYXRhCiAgICAgICAgICAgICAgICAvL1NFQ1RJT04gRkluYWwgc291cmNlZGF0YSBjbGVhbmluZwogICAgICAgICAgICAgICAgY2xlYW5lZF9zb3VyY2VkYXRhID0gY2xlYW5lZF9zb3VyY2VkYXRhLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0gIT09ICIiCiAgICAgICAgICAgICAgICB9KQoKCgogICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuZWRfc291cmNlZGF0YTsKCiAgICAgICAgICAgIH0KCgogICAgICAgICAgICBsZXQgUmVzdWx0ID0gR2V0Q2xlYW5Tb3VyY2VkYXRhKHNvdXJjZWRhdGEsIGNsZWFuZWRfc291cmNlZGF0YSwgbWl4ZWRpbXB1cml0eSkKCiAgICAgICAgICAgIGNsZWFuZWRfc291cmNlZGF0YSA9IFJlc3VsdAogICAgICAgICAgICBjb25zb2xlLmxvZygnY2xlYW5lZF9zb3VyY2VkYXRhOiAnLCBjbGVhbmVkX3NvdXJjZWRhdGEpOwogICAgICAgICAgICAKCgoKICAgICAgICAgICAgLy9TRUNUSU9OIC0gU3RhcnQgb2YgQmhhcmF0IFBhcnNlcgoKCiAgICAgICAgICAgIC8vQ2hlY2tpbmcgZm9yIHR5cGUgb2YgY2hhcmFjdGVycwoKICAgICAgICAgICAgY29uc3QgaXNWYXJpYWJsZSA9IFR5cGVDaGVjay5pc1ZhcmlhYmxlKCkKICAgICAgICAgICAgY29uc3QgaXNOdW1iZXIgPSBUeXBlQ2hlY2suaXNOdW1iZXIoKQoKICAgICAgICAgICAgY29uc3QgaXNPcGVyYXRvciA9IFR5cGVDaGVjay5pc09wZXJhdG9yKCkKCiAgICAgICAgICAgIGNvbnN0IGlzS2V5d29yZCA9IFR5cGVDaGVjay5pc0tleXdvcmQoKQogICAgICAgICAgICBjb25zdCBpc0NvbmRpdGlvbmFsS2V5d29yZCA9IFR5cGVDaGVjay5pc0NvbmRpdGlvbmFsS2V5d29yZCgpCiAgICAgICAgICAgIGNvbnN0IGlzRm9yTG9vcCA9IFR5cGVDaGVjay5pc0Zvckxvb3AoKQogICAgICAgICAgICBjb25zdCBpc1doaWxlTG9vcCA9IFR5cGVDaGVjay5pc1doaWxlTG9vcCgpCgogICAgICAgICAgICAvL25lZWRzIHdvcmsKICAgICAgICAgICAgY29uc3QgaXNFeHByZXNzaW9uID0gVHlwZUNoZWNrLmlzRXhwcmVzc2lvbigpCgogICAgICAgICAgICBjb25zdCBpc0FycmF5ID0gVHlwZUNoZWNrLmlzQXJyYXkoKQoKCiAgICAgICAgICAgIGNvbnN0IGlzU2V0QXJyYXlJbmRleFZhbHVlID0gVHlwZUNoZWNrLmlzU2V0QXJyYXlJbmRleFZhbHVlKCkKCiAgICAgICAgICAgIGNvbnN0IGlzRW1wdHlBcnJheUluaXQgPSBUeXBlQ2hlY2suaXNFbXB0eUFycmF5SW5pdCgpCgogICAgICAgICAgICBjb25zdCBpc1N0cmluZyA9IFR5cGVDaGVjay5pc1N0cmluZygpCgogICAgICAgICAgICBjb25zdCBpc1B1cmVFdmFsID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNQdXJlRXZhbCgpCgogICAgICAgICAgICAvL2lmIHBhcnNlciBlbmNvdW50ZXJzIGFueXRoaW5nIGxpa2UgKCIgb3IgKCwgdGhlbiB0aGF0J3MgYSByZWFsdGltZSBwcmludC4gCiAgICAgICAgICAgIC8vYnVpbGRzdHJpbmcgd2lsbCBiZSBhcHBsaWVkIG5vdyB0byBjcmVhdGUgYSBzdHJpbmcgYW5kIHB1c2ggaXQgaW50byB0b2tlbnMKCiAgICAgICAgICAgIGNvbnN0IGlzUmVhbFRpbWVQcmludE11bHRpcGxlU3RyaW5nID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoKQoKCgogICAgICAgICAgICBjb25zdCBpc1N0cmluZ2FuZFZhbHVlID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNTdHJpbmdhbmRWYWx1ZSgpCgogICAgICAgICAgICBjb25zdCBpc0NhbGN1bGF0aW9uID0gQWR2YW5jZWRUeXBlQ2hlY2suaXNDYWxjdWxhdGlvbigpCgogICAgICAgICAgICBjb25zdCBpc0RpcmVjdFByaW50QXJpdGhtZXRpYyA9IEFkdmFuY2VkVHlwZUNoZWNrLmlzRGlyZWN0UHJpbnRBcml0aG1ldGljKCkKCgoKCiAgICAgICAgICAgIC8vIHRvIHNvbHZlIFthLG4sbixhXSBpbnRvIFthbm5hXQoKICAgICAgICAgICAgLy9TRUNUSU9OIEJ1aWxkIE9wZXJhdGlvbnMgCgogICAgICAgICAgICBjb25zdCBCdWlsZFN0cmluZyA9IEJ1aWxkT3BlcmF0aW9uLkJ1aWxkU3RyaW5nKCkKCiAgICAgICAgICAgIGNvbnN0IEJ1aWxkQXJyYXkgPSBCdWlsZE9wZXJhdGlvbi5CdWlsZEFycmF5KCkKCiAgICAgICAgICAgIGNvbnN0IEJ1aWxkQ29uZGl0aW9uID0gQnVpbGRPcGVyYXRpb24uQnVpbGRDb25kaXRpb24oKQoKCiAgICAgICAgICAgICAvL2NvdW50aW5nIGhvdyBtYW55IHRpbWVzIGRvIHdlIGhhdmUgJiYsIHx8IGNvbmRpdGlvbiBwcmVzZW50CiAgICAgICAgICAgIGZ1bmN0aW9uIENvdW50KGl0ZW0sIGVsZW1lbnQpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5sZW5ndGg7IGkrKykgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jaGFyQXQoaSkgPT0gaXRlbSAmJiBlbGVtZW50LmNoYXJBdChpICsgMSkgPT0gaXRlbSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gMQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY291bnQ7CgoKICAgICAgICAgICAgfQoKCiAgICAgICAgICAgCiAgICAgICAgICAgLy9UaGlzIHdpbGwgcnVuIGZvciBldmVyeSBwcmludCBzdGF0ZW1lbnQgZW5jb3VudGVyZWQgaW4gdGhlIHByb2dyYW0sIG5vdCBqdXN0IGZvciBsb29wcwoKICAgICAgICAgICAgZnVuY3Rpb24gSWZUb2tlblByaW50KFRva2VucywgaiwgZ2xvYmFsLCBpdGVyYXRvciwgT3JpZ2luYWxJdGVyYXRvcikKCgogICAgICAgICAgICB7CgoKCgogICAgICAgICAgICAgICAgdmFyIHRva2VuID0gVG9rZW5zW2pdLnZhbHVlCiAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB2YXIgTmV4dFRva2VuVmFsdWUgPSBUb2tlbnNbaiArIDFdLnZhbHVlCgoKICAgICAgICAgICAgICAgIHZhciBTdHJpbmdWYXIgPSBbXQoKICAgICAgICAgICAgICAgIHZhciBiID0gUmVtb3ZlQnJhY2tldHMoTmV4dFRva2VuVmFsdWUpCgoKICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhYmxlKGIpKSB7CgogICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlc19hcnJheS5wdXNoKGIpCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL1NFQ1RJT04gLSBPdXRwdXR0aW5nIHRoZSBjb2RlCiAgICAgICAgICAgICAgICAvLyBmaW5kaW5nIHRoZSByZWx2YW50IHZhbHVlIGFuZCB0aGVuIG91dHB1dCBpdCBhcyBIVE1MCgogICAgICAgICAgICAgICAgLy9UaGlzIGxvb3AgaXMgb25seSBmb3IgcHJpbnRpbmcgZGlyZWN0IHZhbHVlcyBsaWtlIHByaW50KG5hbWUpLCBwcmludChhcnJheSkKCiAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewoKCgoKCgogICAgICAgICAgICAgICAgICAgIC8vVEhJUyBJUyBUSEUgUkVBTCBHQU1FCgoKCiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gYikgewoKICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgY2FsY3VsYXRpb25zIGxpa2UgeD1hZ2VvbmUrYWdldHdvCgogICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHdlIGhhdmUgYWxyZWFkeSBjYWx1Y3VsYXRlZCB2YWx1ZSwgdXNlIHRoYXQgb3IgZWxzZSBtb3ZlIGZvcndhcmQKCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2lnbmVkX3ZhcmlhYmxlcy5pbmNsdWRlcyhlbCkpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyBlbC52YWx1ZSArICJcbiI7CgoKICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGVsLnZhbHVlKSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgZWwudmFsdWUgKyAiXG4iOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbCk7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29wZXJhdGlvbnMgbGlrZSBhZ2U9MjAyMC0xOTk2CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHVyZUV2YWwoZWwudmFsdWUpKSB7CgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0cHVyZSA9IGV2YWwoZWwudmFsdWUpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwudmFsdWUgPSBvdXRwdXRwdXJlCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArIG91dHB1dHB1cmUgKyAiXG4iOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbCk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vcGVyYXRpb25zIGxpa2UgbmFtZT0ic3dhbmFuZCBrYWRhbSIsIHZhcmlhYmxlIGFzc2lnbm1lbnRzIGFzIHN0cmluZ3MKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHVyZUV2YWwoZWwudmFsdWUpICYmICFpc051bWJlcihlbC52YWx1ZSkpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZWwubmFtZS5pbmNsdWRlcygnXScpICYmIGVsLm5hbWUuaW5jbHVkZXMoJ1snKSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyBlbC52YWx1ZSArICJcbiI7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25lZF92YXJpYWJsZXMucHVzaChlbCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgfQoKCgoKCiAgICAgICAgICAgICAgICAgICAgLy8gd29yayB0byBiZSBjb250aW51ZWQKICAgICAgICAgICAgICAgIH0pCgoKICAgICAgICAgICAgICAgIC8vQU5DSE9SIC0gQ09ORElUSU9OIDIKICAgICAgICAgICAgICAgIGlmIChUb2tlbnNbaiArIDFdLnR5cGUgPT0gJ0FycmF5JykKCgoKCiAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgIC8vVG8gcnVuIG9ubHkgaWYgaXRlcmF0b3IgaXMgcHJlc2VudAoKICAgICAgICAgICAgICAgICAgICAvL1RoaXMgcnVucyBvbiBmb3IgbG9vcCAtIFByaW50KEFycmF5W2FdKSBldGMKCiAgICAgICAgICAgICAgICAgICAgLy90aGlzIHJ1bnMgb25seSBpZiBmb3IoaSkgYW5kIGluIHRoZSBsb29wLCBhcnJheVtpXSwgbm90IG9uIGFycmF5W3hdLiBJdGVyYXRvciBhbmQgaW5kZXggc2hvdWxkIGJlIHNhbWUKCiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yICE9IHVuZGVmaW5lZCAmJiBUb2tlbnNbaiArIDFdLkluZGV4SW5wdXQgPT0gT3JpZ2luYWxJdGVyYXRvcikKCiAgICAgICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZQoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEFycmF5RWxlbWVudCA9IENyZWF0ZUFycmF5RWxlbWVudChWYWx1ZSwgaXRlcmF0b3IpCgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IEdldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArIG91dHB1dCArICJcbiI7CgoKICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goVG9rZW5zW2ogKyAxXSk7CgoKICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAvL1RoaXMgcnVucyB0byBQcmludChBcnJheVsyXSkgbGlrZSBzcGVjaWZpYyBhcnJheSB2YWx1ZXMKICAgICAgICAgICAgICAgICAgICBpZiAoVG9rZW5zW2pdLkluZGV4SW5wdXQgIT0gT3JpZ2luYWxJdGVyYXRvcikKCiAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWUgPSBOZXh0VG9rZW5WYWx1ZQogICAgICAgICAgICAgICAgICAgICAgICBsZXQgSW5kZXhUb0NoYW5nZSA9IFRva2Vuc1tqICsgMV0uSW5kZXhJbnB1dAoKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBBcnJheUVsZW1lbnQgPSBDcmVhdGVBcnJheUVsZW1lbnQoVmFsdWUsIEluZGV4VG9DaGFuZ2UpCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBQcmludEFycmF5RWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0ICE9IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsLm91dHB1dCA9IGdsb2JhbC5vdXRwdXQgKyBvdXRwdXQgKyAiXG4iOwoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCgogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNvbGxlY3RzIHByaW50KEFycmF5W2FdKSBmcm9tIGZvciBsb29wIGFuZCBub3JtYWwgUHJpbnQoQXJyYXlbMl0pCgogICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgIC8vcHJpbnRpbmcgZGlyZWN0IG51bWJlcnMgYW5kIGRpcmVjdCBjYWxjdWx0aW9ucyBsaWtlIHByaW50KDEwKSwgcHJpbnQoMTAqMTApCgogICAgICAgICAgICAgICAgaWYgKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIChpc1B1cmVFdmFsKE5leHRUb2tlblZhbHVlKSB8fCBpc051bWJlcihSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSkpKSkgewoKCiAgICAgICAgICAgICAgICAgICAgbGV0IGEgPSBldmFsKE5leHRUb2tlblZhbHVlKQoKICAgICAgICAgICAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArICJcbiIgKyBhICsgIlxuIgoKICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAvL2Zvcm9wZXJhdGlvbnMgbGlrZSBwcmludCgneW91IGxpdmUsIHlvdSBsZWFybicpCiAgICAgICAgICAgICAgICBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09ICJSZWFsVGltZVByaW50IiAmJiAhTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJysnKSAmJiAhTmV4dFRva2VuVmFsdWUuaW5jbHVkZXMoJz0nKSkKCiAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSBSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSkKCiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoLyIvZywgJycpOwogICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8nL2csICcnKTsKCgogICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgIlxuIiArIG91dHB1dCArICJcbiIKCgoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAvL29wZXJhdGlvbnMgbGlrZSBwcmludChBZ2UgKyAnaXMgeW91bmcgYWdlJykKCiAgICAgICAgICAgICAgICBpZiAoVG9rZW5zW2ogKyAxXS5tb2RlID09ICJSZWFsVGltZVByaW50IiAmJiBOZXh0VG9rZW5WYWx1ZS5pbmNsdWRlcygnKycpKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgbGV0IHggPSBTcGxpdEVsZW1lbnRzQXJyYXkoTmV4dFRva2VuVmFsdWUpCgoKICAgICAgICAgICAgICAgICAgICBTdHJpbmdWYXIgPSBTZXRWYWx1ZXMoeCwgdXBkYXRlZF90b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3RyaW5nVmFyLmpvaW4oJycpCiAgICAgICAgICAgICAgICAgICAgU3RyaW5nVmFyID0gU3RyaW5nVmFyLnNwbGl0KCIrIikKCiAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IFN0cmluZ1Zhci5qb2luKCcgJykKICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBSZW1vdmVCcmFja2V0cyhvdXRwdXQpCgogICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgIlxuIiArIG91dHB1dCArICJcbiIKCgoKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIC8vVEhJUyBDT0RFIGlzIHRvIHJ1biBwcmludCBpbmRleCB2YWx1ZSBpbiBsb29wLCBlLmcgcHJpbnQoaSkgaWYgaXRlcmF0b3IgaXMgaS4gCiAgICAgICAgICAgICAgICAvL1J1bnMgb25seSBpbiBmb3IgbG9vcAoKICAgICAgICAgICAgICAgIGlmIChPcmlnaW5hbEl0ZXJhdG9yID09IFJlbW92ZUJyYWNrZXRzKE5leHRUb2tlblZhbHVlKSkgewoKICAgICAgICAgICAgICAgICAgICBnbG9iYWwub3V0cHV0ID0gZ2xvYmFsLm91dHB1dCArICJcbiIgKyBpdGVyYXRvciArICJcbiIKCgogICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICBpZiAoaXNDYWxjdWxhdGlvbihSZW1vdmVCcmFja2V0cyhOZXh0VG9rZW5WYWx1ZSkpICYmIFRva2Vuc1tqICsgMV0ubW9kZSAhPSAiUmVhbFRpbWVQcmludCIpCgogICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IENhbGN1bGF0ZVZhbHVlcyhOZXh0VG9rZW5WYWx1ZSwgaiwgdXBkYXRlZF90b2tlbnMpCgogICAgICAgICAgICAgICAgICAgIGdsb2JhbC5vdXRwdXQgPSBnbG9iYWwub3V0cHV0ICsgIlxuIiArIG91dHB1dCArICJcbiIKCgoKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIC8vIAoKCgoKCiAgICAgICAgICAgIH0KCgogICAgICAgICAgICAvL0VORCBPRiBGdW5jdGlvbnMgYW5kIEltcG9ydGVkIEZ1bmN0aW9ucwoKCgogICAgICAgICAgICAvL1NFQ1RJT04gLSBQYXJzaW5nIFNUQVJUUyBoZXJlCgogICAgICAgICAgICAvL1NFQ1RJT04gLSBDaGVja2luZyBlYWNoIHRva2VuIGFuZCBhZGRpbmcgdG8gdG9rZW5zIGFycmF5CgoKCiAgICAgICAgICAgIGxldCB0ZW1wdGhpcyA9IHRoaXM7CiAgICAgICAgICAgIGxldCB2YXJpYWJsZUFycmF5ID0gW10gLy9UTyBSRU1PVkUgRFVQTElDQVRFIFZBUklBQkxFUywgU0VFIDQ4MgoKICAgICAgICAgICAgZnVuY3Rpb24gUGFyc2UoY2xlYW5lZF9zb3VyY2VkYXRhLCBpKSB7CgogICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjbGVhbmVkX3NvdXJjZWRhdGFbaV07CgogICAgICAgICAgICAgICAgdmFyIHN0cmluZyA9IFtdCgoKCgogICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoZWxlbWVudCkgPT0gdHJ1ZSkgewoKICAgICAgICAgICAgICAgICAgICBpZiAoY2xlYW5lZF9zb3VyY2VkYXRhW2kgKyAxXSA9PSAnPScpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoVmFyaWFibGUoZWxlbWVudCwgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlQXJyYXkuaW5jbHVkZXMoZWxlbWVudCkpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgVXBkYXRlRWxlbWVudFZhbHVlID0gZWxlbWVudAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB4ID0gdG9rZW5zLmZpbmQoZWwgPT4gZWwudmFsdWUgPT0gZWxlbWVudCkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSB0b2tlbnMuaW5kZXhPZih4KQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVJbnRpYWxpemVkVmFyaWFibGVzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVsZW1lbnQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rva2Vuc1tpbmRleCsyXS52YWx1ZT0gY2xlYW5lZF9zb3VyY2VkYXRhW2krMl0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVBcnJheS5wdXNoKGVsZW1lbnQpCgoKCgoKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihlbGVtZW50KSA9PSB0cnVlKSB7CgogICAgICAgICAgICAgICAgICAgIFB1c2hOdW1iZXIoZWxlbWVudCwgdG9rZW5zKQoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAoaXNPcGVyYXRvcihlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgUHVzaE9wZXJhdG9yKGVsZW1lbnQsIHRva2VucykKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKGlzS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CgogICAgICAgICAgICAgICAgICAgIFB1c2hLZXl3b3JkKGVsZW1lbnQsIHRva2VucykKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgLy9jaGVjayBpZiBpdCBhY2NwZXRzIEFycnlbMmFdIGFzIGluZGV4IDogCiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShlbGVtZW50KSA9PSB0cnVlKSB7CgogICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDEpID09ICddJykgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hBcnJheShlbGVtZW50LCB0b2tlbnMpCgogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJ1aWx0QXJyYXkgPSBCdWlsZEFycmF5KGVsZW1lbnQsIGksIGNsZWFuZWRfc291cmNlZGF0YSkKCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hBcnJheShCdWlsdEFycmF5LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChpc1NldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGkpID09IHRydWUpIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgUHVzaFNldEFycmF5SW5kZXhWYWx1ZShlbGVtZW50LCB0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkKCgogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5QXJyYXlJbml0KGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkgPT0gdHJ1ZSkgewoKCgogICAgICAgICAgICAgICAgICAgIFB1c2hFbXB0eUFycmF5SW5pdCh0b2tlbnMsIGNsZWFuZWRfc291cmNlZGF0YSwgaSkKCgogICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgIGlmIChpc0NvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50KSA9PSB0cnVlKSB7CiAgICAgICAgICAgICAgICAgICAgCgoKaWYgKGlzV2hpbGVMb29wKGVsZW1lbnQpID09IHRydWUpIHsKCiAgICAgICAgICAgICAgICAgICAgUHVzaFdoaWxlTG9vcChlbGVtZW50LCB0b2tlbnMsY2xlYW5lZF9zb3VyY2VkYXRhLGkpCiAgICAgICAgICAgICAgICAgICAvLyBQdXNoV2hpbGVMb29wQ29uZGl0aW9uKGVsZW1lbnQsIGNsZWFuZWRfc291cmNlZGF0YSwgaSwgdG9rZW5zKQoKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgZWxzZXsKCiAgICAgICAgICAgICAgICAgICAgUHVzaENvbmRpdGlvbmFsS2V5d29yZChlbGVtZW50LCB0b2tlbnMpCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kY29uZGl0aW9uID0gQnVpbGRDb25kaXRpb24oZWxlbWVudCwgaSwgY2xlYW5lZF9zb3VyY2VkYXRhKQogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmb3VuZGNvbmRpdGlvbjogJywgZm91bmRjb25kaXRpb24pOwoKCgogICAgICAgICAgICAgICAgICAgIFB1c2hDb25kaXRpb24oZm91bmRjb25kaXRpb24sIHRva2VucykKCiAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICBpZiAoaXNGb3JMb29wKGVsZW1lbnQpID09IHRydWUpIHsKCiAgICAgICAgICAgICAgICAgICAgUHVzaEZvckxvb3AoZWxlbWVudCwgdG9rZW5zKQogICAgICAgICAgICAgICAgICAgIFB1c2hGb3JMb29wQXJ1Z3VtZW50cyhlbGVtZW50LCBjbGVhbmVkX3NvdXJjZWRhdGEsIGksIHRva2VucykKCgogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIAoKCiAgICAgICAgICAgICAgICBpZiAoaXNDYWxjdWxhdGlvbihlbGVtZW50KSA9PSB0cnVlKSB7CgoKICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9ICcnCgogICAgICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkX3NvdXJjZWRhdGFbaSArIDFdICE9IHVuZGVmaW5lZCkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIHBlcmZvcm0gbG9uZyBvcGVyYXRpb25zIGxpa2UgQXZlcmFnZUFnZT0oYWdlb25lK2FnZXR3bykvMiArIChhZ2VvbmUrYWdldHdvKSoyCgogICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaXNDYWxjdWxhdGlvbihjbGVhbmVkX3NvdXJjZWRhdGFbaV0pKQoKCgogICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50ICsgY2xlYW5lZF9zb3VyY2VkYXRhW2ldOwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7CgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgoKICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAvL1B1c2hDYWxjdWxhdGlvbihlbGVtZW50LHRva2VucykKCgoKCiAgICAgICAgICAgICAgICAgICAgLy8gIAogICAgICAgICAgICAgICAgICAgIHRlcm1zID0gZWxlbWVudC5zcGxpdCgnJykKCiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmluZyB0aGUgIigiIiBhbmQgIikiCgogICAgICAgICAgICAgICAgICAgIHZhciBDbGVhbmVkRWxlbWVudCA9IFJlbW92ZUJyYWNrZXRzKGVsZW1lbnQpCgoKICAgICAgICAgICAgICAgICAgICAvLyB0byBzdG9wIHByZXZlbnRpb24gb2YgZXhwcmVzc2lvbnMgbGlrZSBpcyIrIGdldHRpbmcgYWRkZWQgYXMgYSBjYWxjdWxhdGlvbgogICAgICAgICAgICAgICAgICAgIGlmICghKENsZWFuZWRFbGVtZW50LmluY2x1ZGVzKCciJykpICYmIGVsZW1lbnQuY2hhckF0KDApICE9ICcvJyAmJiBlbGVtZW50LmNoYXJBdCgwKSAhPSAnKicpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBQdXNoQ2FsY3VsYXRpb24oZWxlbWVudCwgdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgLy8gdGVybXMyID0gQ2xlYW5lZEVsZW1lbnQuc3BsaXQob3BlcmF0aW9uKQoKICAgICAgICAgICAgICAgICAgICAvL2NoZWNrcG9pbnQ6IHRvIHBlcmZvcm0gY2FsY3VsYXRpb25zIAogICAgICAgICAgICAgICAgICAgIC8vSSBoYXZlIGlkZW50aWZpZWQgdGhlIG9wZXJhdGlvbihzZXBlcmF0ZWQpIGFuZCB0ZXJtcyAoc2VwZXJhdGVkKQoKCgogICAgICAgICAgICAgICAgICAgIC8qICAgICAgdGVtcHRoaXMuT3BlcmF0aW9uT2JqZWN0cy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1zOiB0ZXJtczIsCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgICAqLwoKCgoKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgLy9maW5kaW5nIG9wZXJhdGlvbnMgbGlrZSBwcmludCgic3dhbmFuZCIpLiBUaGUgcmVhbHRpbWVwcmludCBvcGVyYXRpb25zCgoKCiAgICAgICAgICAgICAgICBpZiAoaXNSZWFsVGltZVByaW50TXVsdGlwbGVTdHJpbmcoZWxlbWVudCkgPT0gdHJ1ZSkgewoKCgogICAgICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kU3RyaW5nID0gJycKCiAgICAgICAgICAgICAgICAgICAgbGV0IGsgPSBpCiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbkVuZCA9IGVsZW1lbnQuY2hhckF0KGVsZW1lbnQubGVuZ3RoIC0gMSkgKyBlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDIpCgoKICAgICAgICAgICAgICAgICAgICB2YXIgZmxhZyA9IDA7CgoKCgogICAgICAgICAgICAgICAgICAgIGZvciAoazsgayA8IGNsZWFuZWRfc291cmNlZGF0YS5sZW5ndGg7IGsrKykgewoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBjbGVhbmVkX3NvdXJjZWRhdGFba10KICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvbkVuZCA9IGVsZW1lbnQuY2hhckF0KGVsZW1lbnQubGVuZ3RoIC0gMSkgKyBlbGVtZW50LmNoYXJBdChlbGVtZW50Lmxlbmd0aCAtIDIpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkX3NvdXJjZWRhdGFba10uaW5jbHVkZXMoJ+CkquCljeCksOCkv+CkguCknycpIHx8IGNsZWFuZWRfc291cmNlZGF0YVtrXS5pbmNsdWRlcygn4KSF4KSX4KSwJykpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3VuZFN0cmluZz1mb3VuZFN0cmluZysgICcgJysgY2xlYW5lZF9zb3VyY2VkYXRhW2tdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25FbmQgPT0gJykiJykKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFN0cmluZyA9IGZvdW5kU3RyaW5nICsgJyAnICsgY2xlYW5lZF9zb3VyY2VkYXRhW2tdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZyA9PSAxKSB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdHJpbmcgPSBmb3VuZFN0cmluZyArICcgJyArIGNsZWFuZWRfc291cmNlZGF0YVtrXQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWcgPT0gMCkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RyaW5nID0gY2xlYW5lZF9zb3VyY2VkYXRhW2tdOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSAxOwoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgaWYgKCghZm91bmRTdHJpbmcuaW5jbHVkZXMoIj4iKSkgJiYgKCFmb3VuZFN0cmluZy5pbmNsdWRlcygnLycpKSAmJiAoIWZvdW5kU3RyaW5nLmluY2x1ZGVzKCcqJykpICYmICghZm91bmRTdHJpbmcuaW5jbHVkZXMoJzwnKSkgJiYgKCFmb3VuZFN0cmluZy5pbmNsdWRlcygnPT0nKSkpCgoKICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAvLyAKICAgICAgICAgICAgICAgICAgICAgICAgUHVzaFJlYWxUaW1lUHJpbnRPcGVyYXRpb24oZm91bmRTdHJpbmcsIHRva2VucykKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmdhbmRWYWx1ZShlbGVtZW50KSA9PSB0cnVlKSB7CgoKICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAvL3N0b3Jpbmcgb25seSB0aGUgc3RyaW5nIHZhbHVlcyB0byB0b2tlbnMgKCBub3QgdGhlIHN0cmluZ3MgaW4gcHJpbnQgc3RhdGVtZW50cykKCiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZWxlbWVudCkpCiAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGN1bGF0ZWRTdHJpbmcgPSBCdWlsZFN0cmluZyhlbGVtZW50LCBpLCBjbGVhbmVkX3NvdXJjZWRhdGEpCgoKCiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZFN0cmluZyA9IGNhbGN1bGF0ZWRTdHJpbmcucmVwbGFjZSgvWyciXSsvZywgJycpCgogICAgICAgICAgICAgICAgICAgIGlmICghKGNhbGN1bGF0ZWRTdHJpbmcuaW5jbHVkZXMoIuCkquCljeCksOCkv+CkguCknyIpKSkKCiAgICAgICAgICAgICAgICAgICAgICAgIFB1c2hTdHJpbmcoY2FsY3VsYXRlZFN0cmluZywgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAvLwoKCgogICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgIC8vRm91bmQgU29sdXRpb24gdXNpbmcgcmVnZXhwLSBwcmludChhKSB3aXRob3V0IHNwYWNlIGlzIGdldHRpbmcgYWNjZXB0ZWQgYXMgZXhwcmVzc2lvbgoKCiAgICAgICAgICAgICAgICBpZiAoL14oPz0uKj/gpKrgpY3gpLDgpL/gpILgpJ8pKD89LipbYS16XSkvLnRlc3QoZWxlbWVudCkpIHsKCiAgICAgICAgICAgICAgICAgICAgUHVzaEtleXdvcmQoZWxlbWVudC5zbGljZSgwLCA2KSwgdG9rZW5zKTsgLy9QdXNoaW5nIHByaW50IGtleXdvcmQgb25seQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKGVsZW1lbnQuc2xpY2UoNiksIHRva2VucykgLy9QdXNoaW5nIHJlbWFpbmluZyBleHByZXNzaW9uIGxpa2UgKGEpLCAoZ2FnYWtzKSBldGMKICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgLy9lcnJvciBwcm9uZSBjaGFuZ2UgbWFkZSBoZXJlCgogICAgICAgICAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihlbGVtZW50KSA9PSB0cnVlICYmICFpc0NhbGN1bGF0aW9uKGVsZW1lbnQpICYmICFlbGVtZW50LmluY2x1ZGVzKCdbJykgJiYgIWVsZW1lbnQuaW5jbHVkZXMoJ10nKSAmJiAoIWlzQ29uZGl0aW9uYWxLZXl3b3JkKGNsZWFuZWRfc291cmNlZGF0YVtpIC0gMV0pKSYmIChjbGVhbmVkX3NvdXJjZWRhdGFbaSAtIDFdICE9ICfgpK7gpYcnICkpICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgIFB1c2hFeHByZXNzaW9uKGVsZW1lbnQsIHRva2VucykKCgoKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChpc0V4cHJlc3Npb24oZWxlbWVudCkgPT0gdHJ1ZSAmJiBlbGVtZW50LmluY2x1ZGVzKCdbJykgJiYgZWxlbWVudC5pbmNsdWRlcygnXScpKSB7CgogICAgICAgICAgICAgICAgICAgIFB1c2hBcnJheShlbGVtZW50LCB0b2tlbnMpCgogICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICBpZiAoIWlzS2V5d29yZChlbGVtZW50KSAmJiAhaXNOdW1iZXIoZWxlbWVudCkgJiYgIWlzVmFyaWFibGUoZWxlbWVudCkgJiYgIWlzRXhwcmVzc2lvbihlbGVtZW50KSAmJiAhaXNPcGVyYXRvcihlbGVtZW50KSkgewoKCiAgICAgICAgICAgICAgICAgICAgLy9BTkNIT1IgCiAgICAgICAgICAgICAgICAgICAgLypIbmFkbGluZyBJbXB1cml0eSBlcnJvci1UaGUgbWFpbiBwcm9ibGVtIGlzIGZpZ3VyaW5nIG91dCBob3cgdG8gc29sdmUgIj03MDAwIiBsaWtlIHRoaW5ncwogICAgICAgICAgICAgICAgICAgIGluc3RlYWQgYXNraW5nIGRldmVsb3BlcnMgdG8gYWRkIHNwYWNlIG1hbnVhbGx5CiAgICAgICAgICAgICAgICAgICAgSGFuZGxpbmcgQWxwaGFudW1lcmljIHN0cmluZ3MgdG8gc29sdmUgaXNzdWVzIGxpa2UgJyBhbm5hPTIzNjI5MzQnKi8KCiAgICAgICAgICAgICAgICAgICAgbGV0IGltcHVyaXR5ID0gZWxlbWVudC5zcGxpdCgnPScpCgogICAgICAgICAgICAgICAgICAgIGxldCBmaW5kU3RyaW5nID0gaW1wdXJpdHlbMV0KCgogICAgICAgICAgICAgICAgICAgIC8vdG8gYWNjZXB0IGxvbmcgbnVtYmVycyBpLmUgYT03NDkzNzQ1OTM3NDU5MzcKCiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoaW1wdXJpdHlbMF0pICYmIGlzTnVtYmVyKGltcHVyaXR5WzFdKSkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXR5WzJdID0gaW1wdXJpdHlbMV07CiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVyaXR5WzFdID0gJz0nOwoKICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgIC8vdG8gYWNjZXB0IGE9U1RSSU5HCiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFyaWFibGUoaW1wdXJpdHlbMF0pICYmIGlzVmFyaWFibGUoaW1wdXJpdHlbMV0pKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHlbMl0gPSBpbXB1cml0eVsxXTsKICAgICAgICAgICAgICAgICAgICAgICAgaW1wdXJpdHlbMV0gPSAnPSc7CgogICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICBpbXB1cml0eS5mb3JFYWNoKChlbGVtZW50LCBpKSA9PiB7CgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYXJpYWJsZShlbGVtZW50KSA9PSB0cnVlKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoVmFyaWFibGUoZWxlbWVudCwgdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnRpbnVlOwogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAvLyBBTkNIT1IgCgogICAgICAgICAgICAgICAgICAgICAgICAvL0lzc3VlOiBSaWdodCBub3csIG9ubHkgaXNOdW1iZXIgaXMgcmVzb2x2ZWQsIGE9LCA9MjM4MjhxdyBhcmVuJ3QgcmVzb2x2ZWQuCiAgICAgICAgICAgICAgICAgICAgICAgIC8vU29sdXRpb246IFdvcmsgb24gYWxsIHRoZSBtb2R1bGVzCgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGVsZW1lbnQpID09IHRydWUpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaE51bWJlcihlbGVtZW50LCB0b2tlbnMpCgogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAvL0FOQ0hPUiAKICAgICAgICAgICAgICAgICAgICAgICAgLy9Zb3UgbWlnaHQgaGF2ZSB0byByZW1vdmUgdGhpcyBleHRyYSBmaWx0ZXJzIHNpbmNlIHlvdSBhcmUgb25seSB3b3JraW5nIG9uIG51bWJlcnMgKEZ1dHVyZSBJc3N1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT3BlcmF0b3IoZWxlbWVudCkgPT0gdHJ1ZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaE9wZXJhdG9yKGVsZW1lbnQsIHRva2VuKQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNLZXl3b3JkKGVsZW1lbnQpID09IHRydWUpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQdXNoS2V5d29yZChlbGVtZW50KQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihlbGVtZW50KSA9PSB0cnVlICkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgUHVzaEV4cHJlc3Npb24oZWxlbWVudCwgdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIC8vU0VDVElPTiAtIENoZWNraW5nIGVhY2ggdG9rZW4gYW5kIGFkZGluZyB0byB0b2tlbnMgYXJyYXkKICAgICAgICAgICAgLy8gUEFSU0lORyBJTklUSUFUSU9OCgoKICAgICAgICAgICAgZm9yIChpOyBpIDwgY2xlYW5lZF9zb3VyY2VkYXRhLmxlbmd0aDsgaSsrKSB7CgoKICAgICAgICAgICAgICAgIFBhcnNlKGNsZWFuZWRfc291cmNlZGF0YSwgaSkKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy9BTkNIT1IgCiAgICAgICAgICAgIC8vQ0xFQU5JTkcgVVAgVEhFIFRPS0VOUyBBUlJBWQogICAgICAgICAgICAvL1JlbW92aW5nIHRva2VucyB3aXRoIHZhbHVlID0gJycsIEl0IHdhcyBnZW5lcmF0ZWQgZHVlIHRvICIgY2xlYW5lZF9zb3VyY2VkYXRhID0gY2xlYW5lZF9zb3VyY2VkYXRhLnJlcGxhY2UoLyg7fFxufFxyKS9nbSwgIiAiKS5zcGxpdCgnICcpIgogICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuZmlsdGVyKGVsID0+IGVsLnZhbHVlICE9ICcnKQogICAgICAgICAgICBjb25zb2xlLmxvZygndG9rZW5zOiAnLCB0b2tlbnMpOwogICAgICAgICAgICAKCgoKCiAgICAgICAgICAgIC8vVG8gZmluZCB1bmRlZmluZWQgdmFyaWFibGVzCiAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gdmFyaWFibGVzX2FycmF5LmZpbHRlcih4ID0+ICFhc3NpZ25lZF92YXJpYWJsZXMuaW5jbHVkZXMoeCkpCgogICAgICAgICAgICAvLwoKICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UubGVuZ3RoID4gMCkKCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IucHVzaCgnIFZhcmlhYmxlICcgKyBkaWZmZXJlbmNlLnRvU3RyaW5nKCkuc3BsaXQoJywnKSArICcgaXMgdW5kZWZpbmVkICcpCgogICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAvL1NFQ1RJT04gLSBQcmludGluZyBPdXRwdXRzLCBjb25zaWRlcmluZyBjb25kaXRpb25zLCBmaW5kaW5nIHZhbHVlcyBpbiB1cGRhdGVkX3Rva2VucwoKCgoKICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHsKCiAgICAgICAgICAgICAgICAvLyBDaGVja2luZyBmb3IgYXNzaWdubWVudCBvcGVyYXRvcnMKCgogICAgICAgICAgICAgICAgbGV0IG11dGFibGVfdG9rZW5zID0gdG9rZW5zCiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZQogICAgICAgICAgICAgICAgbGV0IHRva2VuVHlwZSA9IG11dGFibGVfdG9rZW5zW2pdLnR5cGUKCgoKICAgICAgICAgICAgICAgIHZhciBTdHJpbmdWYXIgPSBbXQoKICAgICAgICAgICAgICAgIGxldCBWYXJXaXRob3V0YnJhY2tldHMgPSBSZW1vdmVCcmFja2V0cyhtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSkKCiAgICAgICAgICAgICAgICBWYXJXaXRob3V0YnJhY2tldHMgPSBWYXJXaXRob3V0YnJhY2tldHMucmVwbGFjZSgvIC9nLCAnJykKCgogICAgICAgICAgICAgICAgaWYgKG11dGFibGVfdG9rZW5zW2pdLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIpCgoKCiAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgIGxldCBWYWx1ZVRvU2V0ID0gbXV0YWJsZV90b2tlbnNbal0uVmFsdWVUb1NldAoKCgoKCgogICAgICAgICAgICAgICAgICAgIGxldCB4ID0gR2V0QXJyYXlvclN0cmluZ0VsZW1lbnQobXV0YWJsZV90b2tlbnNbal0udmFsdWUsIHVwZGF0ZWRfdG9rZW5zLCBWYWx1ZVRvU2V0KQoKCgogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSA9PSAnPScpIHsKCiAgICAgICAgICAgICAgICAgICAgLy9hc3NpZ25pbmcgdmFsdWVzIHRvIHZhcmlhYmxlcwoKICAgICAgICAgICAgICAgICAgICBsZXQgdmFyaWFibGUgPSBtdXRhYmxlX3Rva2Vuc1tqIC0gMV0udmFsdWUKCgoKCgogICAgICAgICAgICAgICAgICAgIC8vCiAgICAgICAgICAgICAgICAgICAgbGV0IHZhcnZhbHVlID0gbXV0YWJsZV90b2tlbnNbaiArIDFdLnZhbHVlCgoKCiAgICAgICAgICAgICAgICAgICAgLy8KCiAgICAgICAgICAgICAgICAgICAgLy9maW5kaW5nIGlmIGVsZW1lbnRzIGlzIGFscmVhZHkgYXNzZ2luZWQgaW4gdXBkYXRlZCB0b2tlbnMKICAgICAgICAgICAgICAgICAgICAvL3RvIHNvbHZlIG5hbWU9J3N3YW5hbmQnIGFuZCBuYW1lPSAnb3RoZXIgc3dhbmFuZCcKICAgICAgICAgICAgICAgICAgICAvL2JvdGggc2hwdWxkIGJlIHByaW50ZWQgYWNjb3JkaW5nZ2x5CgoKICAgICAgICAgICAgICAgICAgICBsZXQgbiA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoKGVsLCBpKSA9PiBlbC5uYW1lID09IHZhcmlhYmxlKQoKCgogICAgICAgICAgICAgICAgICAgIC8vIAoKCgogICAgICAgICAgICAgICAgICAgIGlmIChuID09IHVuZGVmaW5lZCkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAvL3RvIGNoZWNrIGlmIHRoZSBhc3NpZ25lZCB2YWx1ZSBuZWVkcyB0byBiZSBjYWxjdWxhdGVkLiB0aGlzIGlzIGZ1dGhlciBkaXZlZGVkIGluIHR3byB0eXBlcwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxjdWxhdGlvbih2YXJ2YWx1ZSkpCgoKICAgICAgICAgICAgICAgICAgICAgICAgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3R5cGUgMS0gQWdlPSAyMDIwLTIwMDAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNQdXJlRXZhbCh2YXJ2YWx1ZSkpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBldmFsKHZhcnZhbHVlKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dyaXRlIGZ1bmN0aW9uIGZvciB0aGlzLCBzbyByZXBlYXRhYmxlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHZhcmlhYmxlLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbXV0YWJsZV90b2tlbnNbaiArIDFdLnR5cGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90eXBlIDItIFg9IGFnZW9uZSthZ2V0d28KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wZXJmb3JtaW5nIHRoZSBjYWxjdWxhdGlvbgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IENhbGN1bGF0ZVZhbHVlcyh2YXJ2YWx1ZSwgaiwgdXBkYXRlZF90b2tlbnMpCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFyaWFibGUsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtdXRhYmxlX3Rva2Vuc1tqICsgMV0udHlwZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlLCBwdXNoIHZhbHVlcyBhcyBpdCBpcwogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5wdXNoKHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YXJpYWJsZSwKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhcnZhbHVlLAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBqLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG11dGFibGVfdG9rZW5zW2ogKyAxXS50eXBlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCdzIGFscmVhZHkgYXNzZ2luZWQsIHJlYXNzaWduIGl0IHdpdGggdXBkYXRlZCB2YWx1ZQogICAgICAgICAgICAgICAgICAgIGVsc2UgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NhbGN1bGF0aW9uKHZhcnZhbHVlKSkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBOZXdWYWx1ZSA9IENhbGN1bGF0ZVZhbHVlcyh2YXJ2YWx1ZSwgaiwgdXBkYXRlZF90b2tlbnMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLnZhbHVlID0gTmV3VmFsdWUKCgogICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4udmFsdWUgPSB2YXJ2YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgoKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAvLyAKCgogICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgaWYgKHRva2VuVHlwZSA9PSAnY29uZGl0aW9uJykKCiAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlCgogLy90aGlzIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdCBzdGVwIHRvIGhhbmRsbGUgb3BlcmF0aW9ucyBsaWtlIOCkheCkl+CksCAoYWdlb25lPT0xMCAmJiBBdmVyYWdlQWdlPDEwMDAgJiYgYWdldHdvPjEwMCB8fCBhZ2VvbmU9PTEwKSBPUiAoYWdlb25lPT0xMCApCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGxldCBDb25kaXRpb25WYWx1ZT0gR2V0Q29uZGl0aW9uVmFsdWUoZWxlbWVudCx1cGRhdGVkX3Rva2VucyxqICkKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgCi8vY29uc29sZS5sb2coJ0NvbmRpdGlvblZhbHVlOiAnLCBDb25kaXRpb25WYWx1ZSk7CgogICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAvL2lmIHZhbHVlIGlzIGZhbHNlLCBqdXN0IHNraXAgdGhlIGlmIGxvb3AgY29udGV4dCwgaWYgbm90IGl0IHdpbGwgYmUgcmFuIGluIGZpbmFsIHByaW50IG1vZHVsZQoKICAgICAgICAgICAgICAgICAgICBpZiAoQ29uZGl0aW9uVmFsdWUgPT0gZmFsc2UpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbml0aWFsaXplTG9vcCA9IHRva2Vucy5pbmRleE9mKG11dGFibGVfdG9rZW5zW2pdKQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG11dGFibGVfdG9rZW5zW2ogKyAxXS52YWx1ZSAhPSAnfScpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Rva2Vucy5zcGxpY2UoaisxLCAxKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL05vIG5lZWQgdG8gZGVsZXRlIHRva2Vucywgd2UgYXJlIGp1c3Qgc2tpcHBpbmcgb3ZlciB0aGUgdmFsdWVzIHNvIHRoYXQgdGhleSB3b24ndCBiZSBwcmludGVkIG9yIHJ1bgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKzsKCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKQoKCiAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgSWZUb2tlblByaW50KG11dGFibGVfdG9rZW5zLCBqLCB0aGlzKSAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCgoKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAodG9rZW5UeXBlID09ICdXaGlsZUxvb3BTdGFydCcpCiAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgbGV0IFRva2Vuc0N1cnJlbnRJbmRleD1qKzMKCiAgICAgICAgICAgICAgICAgICBsZXQgQ29uZGl0aW9uVmFsdWUgPSBmYWxzZQoKICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IG11dGFibGVfdG9rZW5zW2orMV0udmFsdWUKCiAgICAgICAgICAgICAgICAgICAgbGV0IEV4dHJhdGNlZFZhcmlhYmxlPVtdCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgbGV0IHZhcmlhYmxlPScnCiAgICAgICAgICAgICAgICAgICBsZXQgV2hpbGVMb29wU291cmNlZGF0YUluZGV4U3RhcnQgPTAKICAgICAgICAgICAgICAgICAgIGxldCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zPVtdCgogICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8ZWxlbWVudC5sZW5ndGg7aSsrKQogIHsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHg9IGVsZW1lbnQuY2hhckF0KGkpCiAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXNWYXJpYWJsZSh4KSkKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZT12YXJpYWJsZSt4CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZighaXNWYXJpYWJsZShlbGVtZW50LmNoYXJBdChpKzEpKSAmJiBpc1ZhcmlhYmxlKHgpKQogICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgIGxldCB0b2tlbj11cGRhdGVkX3Rva2Vucy5maW5kKGVsPT4gZWwubmFtZT09dmFyaWFibGUpCiAgICAgICAgICAgIAogICAgICAgICAgICBFeHRyYXRjZWRWYXJpYWJsZS5wdXNoKAogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlOnZhcmlhYmxlLAogICAgICAgICAgICAgICAgICAgIHZhbHVlOnRva2VuLnZhbHVlCgogICAgICAgICAgICAgICAgfQogICAgICAgICAgICApCgoKICAgICAgICAgICAgdmFyaWFibGU9JycKCgogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIAogIH0KCgogICAgICAgICAgICAgICAgICAgIC8vdGhpcyBmdW5jdGlvbiBpcyB0aGUgZmlyc3Qgc3RlcCB0byBoYW5kbGxlIG9wZXJhdGlvbnMgbGlrZSDgpIXgpJfgpLAgKGFnZW9uZT09MTAgJiYgQXZlcmFnZUFnZTwxMDAwICYmIGFnZXR3bz4xMDAgfHwgYWdlb25lPT0xMCkgT1IgKGFnZW9uZT09MTAgKQogICAgICAgICAgICAgICAgICAgCiAgICBmdW5jdGlvbiBnZXRMb29wSW5kZXhTdGFydChtdXRhYmxlX3Rva2VucywgaiwgY2hlY2ssIHNldEluZGV4KQoKICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG11dGFibGVfdG9rZW5zW2pdLnZhbHVlICE9IGNoZWNrKQoKCgogICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXRhYmxlX3Rva2Vuc1tqICsgMV0udmFsdWUgPT0gY2hlY2spIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJbmRleCA9IGogKyAxCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKzsKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNldEluZGV4CiAgfQoKICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKHN0YXJ0SW5kZXgsIG11dGFibGVfdG9rZW5zLCBjaGVjaywgU3RvcmVSZXN1bHQpIHsKCgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZyA9IHRydWUKCiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChmbGFnKSB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbc3RhcnRJbmRleF0udmFsdWUgPT0gJ3snKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3N0YXJ0SW5kZXg6ICcsIHN0YXJ0SW5kZXgpOwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG11dGFibGVfdG9rZW5zW3N0YXJ0SW5kZXhdLnZhbHVlICE9ICd9JyApIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQucHVzaChtdXRhYmxlX3Rva2Vuc1tzdGFydEluZGV4KzFdKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgrKzsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGFibGVfdG9rZW5zW3N0YXJ0SW5kZXhdLnZhbHVlID09ICd9JykgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCsrOwoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIGxpbmUgaXMgaW1wb3J0YW50LiBXZSBhcmUgc2tpcHBpbmcgdGhlIGluZGV4IG9mIG11dGFibGUgdG9rZW5zIHVudGlsIGZvcmxvb3AgaXMgY29tcGxldGVkLiBUaGlzIGlzIGRvbmUgdG8gaGF2ZSBzZXByYXRlIGZvciBsb29wIGNvbnRleHQgYW5kIG90aGUKICAgICAgICAgICAgICAgICAgICAgICAgLy9vdGhlciBmdWN0aW9ucyBzaG91bGQgbm90IGludGVydmVuZSBpbiBmb3IgbG9vcCBleGVjdXRpb24KCiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBzdGFydEluZGV4ICsgMQoKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0b3JlUmVzdWx0CiAgICAgICAgICAgICAgICAgICAgICAgIAoKCgoKICAgICAgICAgICAgICAgICAgICB9CgoKCgoKICAgICAgICAgICAgICAgICAgICBXaGlsZUxvb3BTb3VyY2VkYXRhSW5kZXhTdGFydCA9IGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCAneycsIFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KQogICAgICAgICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICAgIFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMgPSBnZXRXaGlsZUxvb3BTb3VyY2VkYXRhKFdoaWxlTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0LCBtdXRhYmxlX3Rva2VucywgJ30nLCBXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zKQogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIAoKLy9jb25zdGFudGx5IGFjY2Vzc2luZyB0aGUgY29uZGl0aW9udmFsdWUKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgd2hpbGUoR2V0Q29uZGl0aW9uVmFsdWUoZWxlbWVudCx1cGRhdGVkX3Rva2VucyxqKzEgKSkKICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDtpPFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMubGVuZ3RoO2krKyl7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU0VDVElPTiB3aGlsZSBsb29wIGNvbnRleHQKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udmFsdWU9PSc9JykgewogICAgICAKICAgICAgCiAgICAgIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBc3NpZ25vclVwZGF0ZVZhbHVlcyhXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zLGksdXBkYXRlZF90b2tlbnMpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGluZyBDT05ESVRJT05BTCBzdGF0ZW1lbnRzIGluIGZvciBsb29wCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnNbaV0udHlwZSA9PSAnY29uZGl0aW9uJykKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgoKCgpIYW5kbGVDb25kaXRpb25zKFdoaWxlTG9vcFNvdXJjZWRhdGFUb2tlbnMsaSx1cGRhdGVkX3Rva2VucykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAKIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChXaGlsZUxvb3BTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZlRva2VuUHJpbnQobXV0YWJsZV90b2tlbnMsIFRva2Vuc0N1cnJlbnRJbmRleCtpLCB0aGlzKSAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAKCiAgICAgICAgCgogICAgICAgICAgICAgICAgCgoKCgogICAgICAgICAgICAgICAgaWYgKHRva2VuVHlwZSA9PSAnRm9yTG9vcFN0YXJ0JykKCgoKICAgICAgICAgICAgICAgIHsKCgoKCiAgICAgICAgICAgICAgICAgICAgLy9HZXR0aW5nIGV2cnkgaW5mb3JtYXRpb24gYWJvdXQgZm9yIGxvb3AgCgoKICAgICAgICAgICAgICAgICAgICBsZXQgRm9yTG9vcE1ldGFEYXRhID0gbXV0YWJsZV90b2tlbnNbaiArIDFdCgoKICAgICAgICAgICAgICAgICAgICAvL1NwbGl0dGluZyB0aGUgZm9ybG9vcG1ldGFkYXQgdmFsdWVzIGluZGl2aWR1YWxseQogICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IEZvckxvb3BNZXRhRGF0YS5pdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IEZvckxvb3BNZXRhRGF0YS52YWx1ZQogICAgICAgICAgICAgICAgICAgIHZhciBJdGVyYXRpb25TdGFydCA9IHBhcnNlSW50KEZvckxvb3BNZXRhRGF0YS5pdGVyYXRpb25TdGFydCkKICAgICAgICAgICAgICAgICAgICB2YXIgSXRlcmF0aW9uRW5kID0gcGFyc2VJbnQoRm9yTG9vcE1ldGFEYXRhLml0ZXJhdGlvbkVuZCkKICAgICAgICAgICAgICAgICAgIC8vIGxldCBGb3JMb29wU291cmNlZGF0YSA9IEZvckxvb3BNZXRhRGF0YS5Gb3JMb29wU291cmNlZGF0YQogICAgICAgICAgICAgICAgICAgICAgICAvLwoKCiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRWYWx1ZSA9IHVwZGF0ZWRfdG9rZW5zLmZpbmQoZWwgPT4gZWwubmFtZSA9PSBlbGVtZW50KQogICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50TGVuZ3RoID0gMAogICAgICAgICAgICAgICAgICAgIHZhciBGbGFnUHJpbWFsTG9vcCA9IDAKICAgICAgICAgICAgICAgICAgICB2YXIgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gMAogICAgICAgICAgICAgICAgICAgIHZhciBTb3VyY2VkYXRhVG9rZW5zID0gW10KICAgICAgICAgICAgICAgICAgICB2YXIgT3JpZ2luYWxJdGVyYXRvciA9IEZvckxvb3BNZXRhRGF0YS5pdGVyYXRvcgoKICAgICAgICAgICAgICAgICAgICAvLwogICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldExvb3BJbmRleFN0YXJ0KG11dGFibGVfdG9rZW5zLCBqLCBjaGVjaywgc2V0SW5kZXgpCgogICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobXV0YWJsZV90b2tlbnNbal0udmFsdWUgIT0gY2hlY2spCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGFibGVfdG9rZW5zW2ogKyAxXS52YWx1ZSA9PSBjaGVjaykgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEluZGV4ID0gaiArIDEKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrOwoKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW5kZXgKCgogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U291cmNlZGF0YShzdGFydEluZGV4LCBtdXRhYmxlX3Rva2VucywgY2hlY2ssIFN0b3JlUmVzdWx0KSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZsYWcgPSB0cnVlCgogICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZmxhZykgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGFibGVfdG9rZW5zW3N0YXJ0SW5kZXhdLnZhbHVlID09ICd7JykgewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG11dGFibGVfdG9rZW5zW3N0YXJ0SW5kZXhdLnZhbHVlICE9ICd9JykgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmVSZXN1bHQucHVzaChtdXRhYmxlX3Rva2Vuc1tzdGFydEluZGV4ICsgMV0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgrKzsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXV0YWJsZV90b2tlbnNbc3RhcnRJbmRleCArIDFdLnZhbHVlID09ICd9JykgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCsrOwoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICAgICAgLy90aGlzIGxpbmUgaXMgaW1wb3J0YW50LiBXZSBhcmUgc2tpcHBpbmcgdGhlIGluZGV4IG9mIG11dGFibGUgdG9rZW5zIHVudGlsIGZvcmxvb3AgaXMgY29tcGxldGVkLiBUaGlzIGlzIGRvbmUgdG8gaGF2ZSBzZXByYXRlIGZvciBsb29wIGNvbnRleHQgYW5kIG90aGUKICAgICAgICAgICAgICAgICAgICAgICAgLy9vdGhlciBmdWN0aW9ucyBzaG91bGQgbm90IGludGVydmVuZSBpbiBmb3IgbG9vcCBleGVjdXRpb24KCiAgICAgICAgICAgICAgICAgICAgICAgIGogPSBzdGFydEluZGV4ICsgMQoKCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdG9yZVJlc3VsdAogICAgICAgICAgICAgICAgICAgICAgICAKCgoKCiAgICAgICAgICAgICAgICAgICAgfQoKCgoKCiAgICAgICAgICAgICAgICAgICAgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0ID0gZ2V0TG9vcEluZGV4U3RhcnQobXV0YWJsZV90b2tlbnMsIGosICd7JywgRm9yTG9vcFNvdXJjZWRhdGFJbmRleFN0YXJ0KQogICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICBTb3VyY2VkYXRhVG9rZW5zID0gZ2V0U291cmNlZGF0YShGb3JMb29wU291cmNlZGF0YUluZGV4U3RhcnQsIG11dGFibGVfdG9rZW5zLCAnfScsIFNvdXJjZWRhdGFUb2tlbnMpCiAgICAgICAgICAgICAgICAgICAgCgoKCgoKICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pbmNsdWRlcygnKCcpICYmIGVsZW1lbnQuaW5jbHVkZXMoJywnKSkKCiAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgRmxhZ1ByaW1hbExvb3AgPSAxCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2hhbGwgd2UgY2VlYXRlIGEgZm9ybG9vcCBjb250ZXh0IGhlcmU/CgoKCgogICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAvLyBSdW4gaWYgc3RhcnQgYW5kIGVuZCBwYXJhbWV0ZXJzIGFyZSBub3QgZ2l2ZW4gZS5nIOCkpuClgeCkueCksOCkvuCkkyBhIOCkleCliyAgTmFtZSDgpK7gpYcgCiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyByYW4ganVzdCB0byBnZXQgU3RhcnQgYW5kIEVuZCBwYXJhbWV0ZXJzIGFzIHRoZXkgYXJlIG5vdCBwcm92aWRlZAogICAgICAgICAgICAgICAgICAgIGlmIChGb3JMb29wTWV0YURhdGEuaXRlcmF0aW9uRW5kID09IHVuZGVmaW5lZCkgewoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIGlmIGVsZW1lbnQgaXMgYXJyYXkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRWYWx1ZS50eXBlID09ICdBcnJheScpCgoKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudExlbmd0aCA9IGVsZW1lbnRWYWx1ZS52YWx1ZS5zcGxpdCgnLCcpLmxlbmd0aAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdGlvblN0YXJ0ID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgSXRlcmF0aW9uRW5kID0gZWxlbWVudExlbmd0aAoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIGlmIGVsZW1lbnQgaXMgU3RyaW5nCiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudExlbmd0aCA9IGVsZW1lbnRWYWx1ZS52YWx1ZS5sZW5ndGgKICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0ZXJhdGlvblN0YXJ0ID0gMAogICAgICAgICAgICAgICAgICAgICAgICAgICAgSXRlcmF0aW9uRW5kID0gZWxlbWVudExlbmd0aAoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgbGV0IEN5Y2xlID0gSXRlcmF0aW9uRW5kCgoKICAgICAgICAgICAgICAgICAgICAvL0l0ZXJhdGluZyBvdmVyIGZvcmxvb3Agc291cmNlZGF0YQoKCiAgICAgICAgICAgICAgICAgICAgZm9yIChpdGVyYXRvciA9IEl0ZXJhdGlvblN0YXJ0OyBpdGVyYXRvciA8IEN5Y2xlOyBpdGVyYXRvcisrKSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgLy9mbGFnIHRvIGF2b2lkIHJ1bm5pbmcgdGhpcyBjb2RlIGlmIGxvb3AgaXMgcHJpbWFsIGJlY2F1c2UgdGhlIHBheWxvYWQgbmVlZHMgdG8gYmUgY29tcGVsdGVseSBkaWZmZXJlbnQKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZsYWdQcmltYWxMb29wID0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yTG9vcEFycmF5b3JTdHJpbmdPdXRwdXQoZWxlbWVudFZhbHVlLCBpdGVyYXRvciwgdXBkYXRlZF90b2tlbnMsIHRoaXMpCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBTb3VyY2VkYXRhVG9rZW5zLmxlbmd0aDsgaSsrKQoKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCgoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlID09ICc9JykgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fzc2lnbmluZyB2YWx1ZXMgdG8gdmFyaWFibGVzCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNzaWdub3JVcGRhdGVWYWx1ZXMoU291cmNlZGF0YVRva2VucyxpLHVwZGF0ZWRfdG9rZW5zKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0hhbmRsaW5nIHByaW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU291cmNlZGF0YVRva2Vuc1tpXS52YWx1ZSA9PSAn4KSq4KWN4KSw4KS/4KSC4KSfJykKCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvciBvcGVyYXRpb25zIGxpa2UgcHJpbnQoYXJyYXlbM10pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWZUb2tlblByaW50KFNvdXJjZWRhdGFUb2tlbnMsIGksIHRoaXMsIGl0ZXJhdG9yLCBPcmlnaW5hbEl0ZXJhdG9yKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0hhbmRsaW5nIHNldCBhcnJheSBlbGVtZW50IHN0YXRlbWVudHMgaW4gZm9yIGxvb3AKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gIlNldEFycmF5SW5kZXhWYWx1ZSIpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgVmFsdWUgPSBTb3VyY2VkYXRhVG9rZW5zW2ldLnZhbHVlCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBWYWx1ZVRvU2V0ID0gU291cmNlZGF0YVRva2Vuc1tpXS5WYWx1ZVRvU2V0CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gUmVtb3ZlQnJhY2tldHMoVmFsdWUpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQXJyYXlFbGVtZW50ID0gJycKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2VwcmF0aW5nIG91dCBpbmRleCBpZGVudGlmaWVyLiB4eXogZnJvbSBBcnJheVt4eXpdCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnJlcGxhY2UoJ10nLCAnJykKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBTcGxpdCA9IGVsZW1lbnQuc3BsaXQoJ1snKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGlmIHdlIG5lZWQgdG8gc2V0IGRpcmVjdCBBcnJheSBlbGVtZW50IHZhbHVlLiBsaWtlIEFycmF5WzJdPSB4eXggICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihTcGxpdFsxXSkpIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNwbGl0ID0gU3BsaXQuam9pbignWycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3BsaXQgPSBTcGxpdCArICddJwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gU3BsaXQKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGlmIHdlIG5lZWQgdG8gZHluYW1pY2FsbHkgc2V0IEFycmF5IGVsZW1lbnQgdmFsdWUuIGxpa2UgQXJyYXlbaV09IHh5eAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQ3JlYXRlQXJyYXlFbGVtZW50IGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGR5bmFtaWMgQXJyYXkgdmFsdWVzLiBsaWtlIEFycmF5WzBdLCBBcnJheVsxXSBldGMuICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlFbGVtZW50ID0gQ3JlYXRlQXJyYXlFbGVtZW50KFZhbHVlLCBpdGVyYXRvcikKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgaXMgd3JpdHRlbiB0byBmaW5kIG9wZXJhdGlvbnMgbGlrZSBBcnJheVthXT0gYSoxMDArYWdlKmEuIG5vdGljZSBhCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maW5kIGEgd2F5IHRvIHNpbXBsaWZ5IHRoaXMgaW4gbG9uZyB0ZXJtCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gVmFsdWVUb1NldAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnKicpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJysnKS50b1N0cmluZygpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNwbGl0KCctJykudG9TdHJpbmcoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zcGxpdCgnLycpLnRvU3RyaW5nKCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3BsaXQoJywnKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9idWlsZGluZyBhIG5ldyB2YWx1ZSB0byBjb252ZXJ0IGEqMTAwK2FnZSphIGludG8gNSoxMDArYWdlKmEgYW5kIHRoZW4gc2VuZGluZyBpdCB0byBDYWxjdWxhdGVWYWx1ZXMoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBOZXdWYWx1ZVRvU2V0ID0gJycKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5pbmNsdWRlcyhTcGxpdFsxXSkgJiYgZGF0YS5sZW5ndGggPiAxKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3dlIGhhdmUgb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPSBhKjEwMCthZ2UqYS4gbm90aWNlIGEKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBtID0gMDsgbSA8IFZhbHVlVG9TZXQubGVuZ3RoOyBtKyspCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFZhbHVlVG9TZXRbbV0gPT0gU3BsaXRbMV0gJiYgISgvXlthLXpdKyQvaS50ZXN0KFZhbHVlVG9TZXRbbSArIDFdKSkpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIGlzIGJlZW4gc2V0IC4gcmVwbGFjaW5nIGluZGV4IHZhbHVlIGEgd2l0aCBpdGVhcnRvciB2YWx1ZSAwLDEsMiwgZXRjLiAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBOZXdWYWx1ZVRvU2V0ICsgaXRlcmF0b3IKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOZXdWYWx1ZVRvU2V0ID0gTmV3VmFsdWVUb1NldCArIFZhbHVlVG9TZXRbbV0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcmF0ID0gZmFsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2F2ZSBpdCBhIGRpZmZlcmVudCBuYW1lIHNvIGl0IHdvdWxkIG5vdCBmdWNrIHVwIHdpdGggZm9yIGxvb3AgaXRlcmF0b3IKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5ld1ZhbHVlVG9TZXQgPSBDYWxjdWxhdGVWYWx1ZXMoTmV3VmFsdWVUb1NldCwgaiwgdXBkYXRlZF90b2tlbnMsICkKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LCB1cGRhdGVkX3Rva2VucywgaXRlcmF0LCBOZXdWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29uZGl0aW9uIGVuYWJsZXMgcHJvZ3JhbSB0byBvbmx5IHJ1biAgQXJyYXlbYV09IHh5eiB3aGVuIGl0ZXJhdG9yIGlzIGEuIEl0IGRpc2FsbG93cyBydW5uaW5nIEFycmF5W2JsYWJsYWJsYV09eHl6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9yaWdpbmFsSXRlcmF0b3IgPT0gU3BsaXRbMV0pIHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTcGxpdFsxXSA9PSBWYWx1ZVRvU2V0KSB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IHRydWUKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXRBcnJheW9yU3RyaW5nRWxlbWVudChBcnJheUVsZW1lbnQsIHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Igb3BlcmF0aW9ucyBsaWtlIEFycmF5W2FdPWFnZW9uZSoxMDAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuaW5jbHVkZXMoU3BsaXRbMV0pICYmIE9yaWdpbmFsSXRlcmF0b3IgPT0gU3BsaXRbMV0pIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZmFsc2UKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZVRvU2V0ID0gQ2FsY3VsYXRlVmFsdWVzKFZhbHVlVG9TZXQsIGosIHVwZGF0ZWRfdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldEFycmF5b3JTdHJpbmdFbGVtZW50KEFycmF5RWxlbWVudCwgdXBkYXRlZF90b2tlbnMsIGl0ZXJhdG9yLCBWYWx1ZVRvU2V0LCB0b2tlbnMpCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vU2V0QXJyYXlvclN0cmluZ0VsZW1lbnQoQXJyYXlFbGVtZW50LHVwZGF0ZWRfdG9rZW5zLCBpdGVyYXRvciwgVmFsdWVUb1NldCwgdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxpbmcgQ09ORElUSU9OQUwgc3RhdGVtZW50cyBpbiBmb3IgbG9vcAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChTb3VyY2VkYXRhVG9rZW5zW2ldLnR5cGUgPT0gJ2NvbmRpdGlvbicpCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgewoKCkhhbmRsZUNvbmRpdGlvbnMoU291cmNlZGF0YVRva2VucyxpLHVwZGF0ZWRfdG9rZW5zKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIC8vRU5EIEZPUiBMT09QIEVYRUNVVElPTgoKCgoKCgoKICAgICAgICAgICAgfQoKCgoKCiAgICAgICAgICAgIAoKCgoKdmFyIHQxID0gcGVyZm9ybWFuY2Uubm93KCkKaWYodGhpcy5vdXRwdXQhPScnKQp7CnRoaXMuVGltZVRha2VuPSAiQ29tcGlsZWQgU3VjY2VzZnVsbHkgaW4gIiArICh0MSAtIHQwKS50b1ByZWNpc2lvbig0KSArICIgbXMuIgoKfQoKICAgICAgICAgICAgdGhpcy5saW5lYnlsaW5lT3V0cHV0ID0gdGhpcy5vdXRwdXQuc3BsaXQoJ1xuJykKCgogICAgICAgICAgICB0aGlzLmxpbmVieWxpbmVPdXRwdXQgPSB0aGlzLmxpbmVieWxpbmVPdXRwdXQuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHsKICAgICAgICAgICAgICAgIHJldHVybiBpdGVtICE9PSAiIgogICAgICAgICAgICB9KQoKCgoKCiAgICAgICAgICAgIC8vU0VDVElPTiAtIENhbGN1bGF0aW5nIHJlbWFpbmluZyB2YWx1ZXMKCgogICAgICAgICAgICAvL3NvIHRoYXQgcmVwbGFjZSB4IHdpdGggdmFsdWVzCgogICAgICAgICAgICAvKgogICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsLnZhbHVlCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZpbmcgdGhlICIoIiIgYW5kICIpIgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgQ2xlYW5lZEVsZW1lbnQgPSBSZW1vdmVCcmFja2V0cyhlbGVtZW50KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9ICcnCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3doeSBwdXJlZXZhbD8KICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9wZXJhdGlvbnMgbGlrZSA1MCs2MCB3ZXJlIHNldCBhcyBbNSwwLCssNiwwXSBpbnN0ZWFkIG9mIFs1MCwrLDYwXS4gYmFzaWNhbGx5IGRpcmVjdCBjYWxjdWxhdGlvbiB3YXMgbm90IHdvcmtpbmcKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcHVyZWV2YWwgZmluZHMgc3VjaCBwdXJlIG9wZXJhdGlvbnMgYW5kIHRoZW4gY2FsY3VsYXRlIHRoZW0gdG8gZGlyZWN0bHkgc2V0IHRoZWlyIHZhbHVlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgc2hpdCBpcyBvbmx5IGZvciBwdXJlb3BlcmF0aW9ucwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHB1cmV2YWwgPSAvXihbLStdP1swLTldKlwuP1swLTldK1tcL1wrXC1cKl0pKyhbLStdP1swLTldKlwuP1swLTldKykqJC9nbS50ZXN0KENsZWFuZWRFbGVtZW50KQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdXJldmFsID09IHRydWUpIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vuc1tpXS52YWx1ZSA9IGV2YWwodXBkYXRlZF90b2tlbnNbaV0udmFsdWUpCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KCgoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDYWxjdWxhdGlvbihDbGVhbmVkRWxlbWVudCkgPT0gdHJ1ZSAmJiAhcHVyZXZhbCkgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJtcyA9IENsZWFuZWRFbGVtZW50LnNwbGl0KCcnKQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgfSkKCgoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtaW5nIGNhbGN1bGF0aW9ucwoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnMuZm9yRWFjaCgoZWwsIGkpID0+IHsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXh0b0NoYW5nZSA9ICcnIC8vdG8ga25vdyB3aGljaCB2YWx1ZSB0byByZXBsYWNlIGxpa2UgImFubmErZGFkYS1iYWQiIHdpdGggIjUrNi03IgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBlbC52YWx1ZSAvLyByZWFkaW5nIHRoZSBjdXJyZW50IHZhbHVlLCBmb3IgbG9uIHN0cmluZyB2YXJpYWJsZSBuYW1lcyBpdCdzIHN0aWxsIGxpa2UgImFubmErZGFkYS1iYWQiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC50b1N0cmluZygpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgU3RyaW5nVmFyID0gW10KICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIAoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwdXJldmFsID0gL14oWy0rXT9bYS16XSpcLj9bYS16XStbXC9cK1wtXCpdKSsoWy0rXT9bYS16XSpcLj9bYS16XSspKiQvZ20udGVzdChlbGVtZW50KQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaW5jbHVkZXMoJz4nKSB8fCBlbGVtZW50LmluY2x1ZGVzKCc8JykgfHwgZWxlbWVudC5pbmNsdWRlcygnPT0nKSkgewoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNwbGl0RWxlbWVudHNBcnJheShlbGVtZW50KQoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyhTdHJpbmdWYXIsIHVwZGF0ZWRfdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRlVXBkYXRlZF90b2tlbnN3aXRoVmFsdWVzKFN0cmluZ1ZhciwgaSwgdXBkYXRlZF90b2tlbnMpCgoKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbmRpbmcgb3BlcmF0aW9ucyBsaWtlIGErYi1jCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHVyZXZhbCA9PSB0cnVlIHx8IGVsZW1lbnQuY2hhckF0KDApID09ICIoIikgewoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNwbGl0RWxlbWVudHNBcnJheShlbGVtZW50KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmluZ1ZhciA9IFNldFZhbHVlcyhTdHJpbmdWYXIsIHVwZGF0ZWRfdG9rZW5zKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVwZGF0ZVVwZGF0ZWRfdG9rZW5zd2l0aFZhbHVlcyhTdHJpbmdWYXIsIGksIHVwZGF0ZWRfdG9rZW5zKQoKCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CgoKCgogICAgICAgICAgICAgICAgICAgICAgICB9KQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgLyoKICAgICAgICAgICAgICAgICAgICAgICAgIFJlSW50aWFsaXplZFZhcmlhYmxlcy5mb3JFYWNoKGVsPT57CgogICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmxhZz0wCiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBTa2lwSW5kZXg9MAoKICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBtPTA7bTx1cGRhdGVkX3Rva2Vucy5sZW5ndGg7bSsrKQogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWwubmFtZT09dXBkYXRlZF90b2tlbnNbbV0ubmFtZSAmJiBmbGFnPT0wKQogICAgICAgICAgICAgICAgICAgICAgICB7CgoKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWwudmFsdWUuY2hhckF0KDApPT0nIicpCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IEJ1aWx0U3RyaW5nPSBCdWlsZFN0cmluZyhlbC52YWx1ZSwgKQoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWc9MTsKICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZF90b2tlbnNbbV0udmFsdWU9ZWwudmFsdWU7CgoKICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICBTa2lwSW5kZXg9bQoKCiAgICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICAgIC8vCgogICAgICAgICAgICAgICAgICAgICAgICBpZiggbSE9U2tpcEluZGV4ICYmIGZsYWc9PTEgJiYgZWwubmFtZT09dXBkYXRlZF90b2tlbnNbbV0ubmFtZSkKCiAgICAgICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRfdG9rZW5zLnNwbGljZShtLDEpCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgICAgICAgICAgfQoKCgoKICAgICAgICAgICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAgICAgICAgICAgKi8KCgoKCiAgICAgICAgICAgIC8vU0VDVElPTiAtIEl0ZXJhdGluZyBvdmVyIHRva2VucyBhbmQgdGhlbiBQUklOVElORyBGSU5BTCB1c2luZyB2YWx1ZXMgc3RvcmVkIGluIHVwZGF0ZWQgdG9rZW5zCgogICAgICAgICAgICAvKiAgICAgICAgCgogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykgewoKCiAgICAgICAgICAgICAgICB2YXIgbXV0YWJsZV90b2tlbnMgPSB0b2tlbnMKICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IG11dGFibGVfdG9rZW5zW2pdLnZhbHVlCiAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT0gJ+CkquCljeCksOCkv+CkguCknycgKQoKICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBSZW1vdmVCcmFja2V0cyhtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlKQoKCgoKICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXNfYXJyYXkucHVzaChiKQoKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgLy9TRUNUSU9OIC0gT3V0cHV0dGluZyB0aGUgY29kZQogICAgICAgICAgICAgICAgICAgIC8vIGZpbmRpbmcgdGhlIHJlbHZhbnQgdmFsdWUgYW5kIHRoZW4gb3V0cHV0IGl0IGFzIEhUTUwKICAgICAgICAgICAgICAgICAgICB1cGRhdGVkX3Rva2Vucy5mb3JFYWNoKChlbCwgaSkgPT4gewoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLm5hbWUgPT0gYiApIHsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQgKyBlbC52YWx1ZSArICJcbiI7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWduZWRfdmFyaWFibGVzLnB1c2goZWwubmFtZSk7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICB9CgoKCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdvcmsgdG8gYmUgY29udGludWVkCgogICAgICAgICAgICAgICAgICAgIH0pCgogICAgICAgICAgICAgICAgICAgIAoKICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIC8vSGFuZGxpbmcgQ29uZGl0aW9ucwoKICAgICAgICAgICAgICAgIGlmKG11dGFibGVfdG9rZW5zW2pdLnR5cGU9PSJjb25kaXRpb24iKQogICAgICAgICAgICAgICAgewoKCgogICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIGxldCB0b2tlbj0gdXBkYXRlZF90b2tlbnMuZmluZChlbD0+IGVsLm9yaWdpbmFsdmFsdWU9PW11dGFibGVfdG9rZW5zW2pdLnZhbHVlKQoKCgogICAgICAgICAgICAgICAgICAgIGxldCBDb25kaXRpb25WYWx1ZT10b2tlbi52YWx1ZQoKICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgaWYoQ29uZGl0aW9uVmFsdWU9PWZhbHNlKQogICAgICAgICAgICAgICAgICAgewoKbGV0IEluaXRpYWxpemVMb29wPSB0b2tlbnMuaW5kZXhPZihtdXRhYmxlX3Rva2Vuc1tqXSkKCgoKCgp3aGlsZShtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlIT0nfScgKQp7CgoKCiAgICBsZXQgeD0gbXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZS5sZW5ndGgKICAgIAogICAgCnRva2Vucy5zcGxpY2UoaisxLCAxKTsKIAoKICAgIGorKzsKCgp9CgoKCgogICAgICAgICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICB9CgoKICAgICAgICAgICAgICAgIGlmKHRva2VuID09ICfgpKrgpY3gpLDgpL/gpILgpJ8nICYmIC9eKFstK10/WzAtOV0qXC4/WzAtOV0rW1wvXCtcLVwqXSkrKFstK10/WzAtOV0qXC4/WzAtOV0rKSokL2dtLnRlc3QobXV0YWJsZV90b2tlbnNbaisxXS52YWx1ZSkgKQogICAgICAgICAgICAgICAgewogCiAgICAgICAgICAgICAgICBsZXQgYT0gZXZhbChtdXRhYmxlX3Rva2Vuc1tqKzFdLnZhbHVlKQoKICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy5vdXRwdXQgKyAiXG4iICsgYSArICJcbiIKCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgCgogICAgICAgIAogICAgICAgICAgICAgIAoKCgoKICAgICAgLy8gdGhpcyBpcyB0byBoYW5kbGUg4KSq4KWN4KSw4KS/4KSC4KSfICgiQWdlIGlzIisgQWdlKSBldGMuCgogICAgICAgICAgICAgICAgaWYoaXNTdHJpbmdhbmRWYWx1ZShtdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZSkpCnsKCgogICAgICAgIAoKICAgICAgICAgICAgICAgICAgICBsZXQgeD1tdXRhYmxlX3Rva2Vuc1tqXS52YWx1ZQogICAgICAgICAgICAgICAgICAgIGxldCBzdHJpbmc9JycKICAgICAgICAgICAgICAgICAgICBsZXQgbmV3ZWw9JycKCiAgICAgICAgICAgICAgICAgICAgeD1SZW1vdmVCcmFja2V0cyh4KQoKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAvL3ggPSB4LnJlcGxhY2UoLyAvZywnJykKCiAgICAgICAgICAgICAgICAgICAgeD14LnNwbGl0KCIrIikKCiAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIHguZm9yRWFjaChlbGVtZW50ID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZWxlbWVudC5jaGFyQXQoMCk9PSAiICIgfHwgZWxlbWVudC5jaGFyQXQoZWxlbWVudC5sZW5ndGgtMSk9PSIgIiAmJiAhKGVsZW1lbnQuaW5jbHVkZXMoJyInKSkpewoKICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICBuZXdlbD0gZWxlbWVudC5yZXBsYWNlKC9ccy9nLCAnJyk7CgogICAgICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3ZWw9ZWxlbWVudAogICAgICAgICAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgICAgICAgIGxldCB5PSB1cGRhdGVkX3Rva2Vucy5maW5kKGVsPT4gZWwubmFtZT09IG5ld2VsKQoKICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgIAovLwogICAgICAgICAgICAgICAgICAgICAgIGlmKHkhPXVuZGVmaW5lZCkKICAgICAgICAgICAgICAgICAgICAgICB7CgoKCiAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nPXN0cmluZyArICcgJyArIHkudmFsdWUKICAgICAgICAgICAgICAgICAgICAgICAvLwoKCiAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgIGVsc2V7CgogICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudD0gZWxlbWVudC5yZXBsYWNlKC8iL2csICcnKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nPXN0cmluZysgJyAnICsgZWxlbWVudAogICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICAgICAgCgogICAgICAgICAgICAgICAgICAgIH0pOwoKCgogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dCA9IHRoaXMub3V0cHV0ICsgIlxuIiArIHN0cmluZyArICJcbiIKfQoKCi8vVEhJUyBJUyB0byBoYW5kbGUgb3BlcmF0aW9ucyBsaWtlIOCkquCljeCksOCkv+CkguCknyAoIk5hbWUgaXMgR09BVCIpLCDgpKrgpY3gpLDgpL/gpILgpJ8gKCJHb29kYnllIikKCmVsc2V7CgoKCiAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZT0gUmVtb3ZlQnJhY2tldHMobXV0YWJsZV90b2tlbnNbal0udmFsdWUpCiAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICAgICBsZXQgQ2xlYW5lZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvIC9nLCcnKQoKICAgICAgICAgICAgICAgICAgICAKCgogICAgICAgICAgICAgICAgICAgaWYoL14oWy0rXT9bMC05XSpcLj9bMC05XStbXC9cK1wtXCpdKSsoWy0rXT9bMC05XSpcLj9bMC05XSspKiQvZ20udGVzdChDbGVhbmVkVmFsdWUpIT10cnVlKQoKICAgICAgICAgICAgICAgICAgIHsKCiAgICAgICAgICAgICAgICAgLy8gCgogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvIi9nLCAiIik7CiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8nL2csICIiKTsKCgoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm91dHB1dCArICJcbiIgKyB2YWx1ZSArICJcbiIgCiB9CiAgICAgICAgICAgICAgICAgICAgICAgIAoKfQoKCiAgICAgICAgICAgIH0KCgogICAgICAgICAgIAogICAgICAgICAgICB9KQoKICAgICAgICB9CiAgICAgICAgKi8KCgogICAgICAgIH0KCiAgICB9Cgp9Owo="},{"version":3,"sources":["HelloWorld.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;;AAGA;;;AAGA;;;;AAIA;;;;AAIA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;;;AAGA;;AAEA;AACA;;;;;AAKA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;;;AAIA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;;;AAGA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;AAOA;;;;AAIA;;AAEA;;AAEA;;;;;;;AAOA;;;AAGA;;;AAGA;;;AAGA;;;;AAIA;;AAEA;;;AAGA;;AAEA;;AAEA;;;;;;AAMA;;;;AAIA;;;AAGA;;AAEA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;;AAKA;AACA;;AAEA;AACA;;;;;AAKA;;;;;AAKA;;AAEA;;;;;;AAMA;AACA;;;AAGA;AACA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;;;AAKA;;;AAGA;;;AAGA;;;AAGA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;AAGA;;;;;;AAMA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;;;AAIA;;AAEA;;AAEA;;;;AAIA;;;AAGA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;;;;;AAKA;;;AAGA;AACA;;AAEA;;AAEA;;;AAGA;;;AAGA;;AAEA;;;AAGA;;AAEA;;;;AAIA;AACA;;;;;;AAMA;;;AAGA;;;;AAIA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;;;AAIA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;;;AAIA;;AAEA;;;;;;AAMA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;;;AAIA;AACA;;AAEA;;;;;AAKA;;;AAGA;;AAEA;;;;AAIA;;;AAGA;;;;;AAKA;;;;AAIA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;;;AAIA;;;;;AAKA;;;AAGA;;AAEA;AACA;;;AAGA;;;;;AAKA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;;;;;AAMA;;;AAGA;;;;;AAKA;AACA;;AAEA;;AAEA;;;AAGA;AACA;;;AAGA;;;AAGA;;;AAGA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;;AAIA;AACA;;;;;;AAMA;;AAEA;;;;AAIA;;;;AAIA;AACA;;AAEA;AACA;;;AAGA;;;;;AAKA;;AAEA;AACA;;;;AAIA;;;AAGA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;AAKA;;;;AAIA;;;AAGA;;AAEA;AACA;AACA;;;;;AAKA;;;AAGA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;;AAGA;;;;AAIA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;AAGA;;AAEA;;;AAGA;AACA;;;AAGA;;AAEA;;;;AAIA;;;;AAIA;AACA;;AAEA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;;AAGA;;;;AAIA;;AAEA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;;;AAKA;;;;;AAKA;;AAEA;;;AAGA;AACA;AACA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;;;;;;AAOA;;;;AAIA;;AAEA;;AAEA;;AAEA;;;;;;AAMA;AACA;;;;AAIA;;AAEA;AACA;AACA;;;AAGA;;;;AAIA;;;;AAIA;;;;AAIA;AACA;;;AAGA;;;AAGA;AACA;;;;AAIA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;AACA;AACA;;;;;;AAMA;AACA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;;;;AAIA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;;;;;AAKA;AACA;;;AAGA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;AAEA;;AAEA;;;;;AAKA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;;;;;AAKA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;AAGA;;AAEA;;;AAGA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;AAGA;;;;;;;AAOA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;;;;;AAMA;;;;;;AAMA;AACA;AACA;;;;;;AAMA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;AAEA;;AAEA;;;;;AAKA;;;AAGA;;;;;AAKA;;;;AAIA;;;AAGA;;;;;;AAMA;;AAEA;;;AAGA;AACA;;;;;;;;;;AAUA;;;;AAIA;;;;;AAKA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;AAEA;AACA;;;AAGA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;;AAGA;;AAEA;AACA;;;AAGA;;;;AAIA;;;;;AAKA;;;;AAIA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;;AAGA;;;;;;AAMA;;;;;;AAMA;AACA;;AAEA;;;;;;;AAOA;;AAEA;;AAEA;;;;AAIA;;;;;AAKA;;;;AAIA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;AAGA;;;AAGA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;;;;;;AAOA;;AAEA;;AAEA;;AAEA;;;;;AAKA;;AAEA;;;;;;AAMA;;AAEA;AACA;;AAEA;;;AAGA;;;;AAIA;AACA;;;;;AAKA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;AAIA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;AAEA;;;AAGA;;;AAGA;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;;;;;;AAMA;;;;AAIA;;AAEA;;AAEA;;;AAGA;;;;AAIA;;;AAGA;;;;AAIA;;;;;AAKA;;AAEA;;;;;;;;AAQA;;;;;;;;;;;AAWA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;;;;;;AAMA;;;AAGA;;AAEA;AACA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;;;AAGA;;;;;AAKA;;AAEA;;;;AAIA;;;;;AAKA;;;;;AAKA;;AAEA;;;;;AAKA;;AAEA;;;;AAIA;AACA;AACA;AACA;;AAEA;;;;AAIA;;;;AAIA;;;;AAIA;;;AAGA;;;;;AAKA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AACA;;;AAGA;;;;;AAKA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;;AAGA;;;AAGA;AACA;AACA;;;;;AAKA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;;;;;AAKA;AACA;;;;;AAKA;;AAEA;;AAEA;;;AAGA;AACA;;;AAGA;;AAEA;;AAEA;;;;;AAKA;;;;;AAKA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;;;;AAKA;;;;AAIA;;AAEA;;;;;;AAMA;;;AAGA;;AAEA;AACA;;;;;;AAMA;;;;AAIA;;;;AAIA;AACA;;AAEA;;;;;;AAMA;AACA;;;;AAIA;;;AAGA;;;AAGA;;;AAGA;;;;;AAKA;;;AAGA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;;;;AAUA;;AAEA;AACA;;;;;AAKA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;;;AAIA;;;;AAIA;;;AAGA;;;;;AAKA;AACA;;AAEA;AACA;;AAEA;;;;;AAKA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;;;;AAIA;AACA;;;AAGA;;AAEA;;;;AAIA;AACA;;;;AAIA;;;;;AAKA;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;;;AAGA;;;AAGA;;;;AAIA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA","file":"HelloWorld.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"hello\">\n   \n   <div id=\"compiler\">\n   <div id=\"textarea\">\n    <textarea v-model=\"code\" type=\"text\" name=\"code\" id=\"codearea\"></textarea>\n\n    <button id=\"subm\" @click=\"RUN()\">RUN</button>\n   \n   </div>\n\n    <div id=\"output\">\n\n<div id=\"bharatDIV\">\n        <p style=\"color:orange\" id=\"bharatP\">BH</p> <p id=\"bharatP\" style=\"color:white\">AR</p> <p id=\"bharatP\" style=\"color:green\">AT</p>  <p id=\"versionNumber\" >  v1.0</p>\n\n<p style=\"    text-align: left;\n    color: #2fff2f;\n    font-family: monospace;\n\">{{TimeTaken}}</p>\n        \n\n<p id=\"linebylineOutput\" v-for=\"(output,index) in this.linebylineOutput\" :key=\"index\">\n\n{{output}}\n</p>\n\n\n</div>\n\n\n    </div>\n</div>\n    <div id=\"errorstack\">\n\n<div v-for=\"(error,index) in this.error\" :key=\"index\">\n\n{{error}}\n</div>\n\n\n    </div>\n\n    \n      \n  </div>\n</template>\n\n<script>\nimport {\n    SourceDataReplaceforEasyParsing\n} from '../FunctionScripts/functions'\nimport * as TypeCheck from '../FunctionScripts/TypeChecking'\nimport * as AdvancedTypeCheck from '../FunctionScripts/AdvancedTypeChecking'\nimport * as BuildOperation from '../FunctionScripts/BuildOperations'\nimport {\n    PushArray,\n    PushCalculation,\n    PushConditionalKeyword,\n    PushCondition,\n    PushForLoop,\n    PushWhileLoop,\n    PushWhileLoopCondition,\n    PushForLoopAruguments,\n    PushExpression,\n    PushKeyword,\n    PushNumber,\n    PushOperator,\n    PushRealTimePrintOperation,\n    PushString,\n    PushStringandValueOperation,\n    PushVariable,\n    PushEmptyArrayInit\n} from '../FunctionScripts/PushFunctions'\nimport {\n    RemoveBrackets,\n    isArrayOperation,\n    CreateArrayElement,\n    CalculateValues,\n    GetArrayorStringElement,\n    SetArrayorStringElement,\n    PrintArrayElement,\n    handlemultConditions,\n    SplitElementsArray,\n    SetValues,\n    PushSetArrayIndexValue,\n    UpdateUpdated_tokenswithValues,\n    GetConditionValue,\n    ForLoopArrayorStringOutput,\n    AssignorUpdateValues,\n    HandleConditions\n} from '../FunctionScripts/MiscImportantFunctions'\n\n\nexport default {\n    name: \"HelloWorld\",\n    props: {\n        msg: String\n    },\n\n    data() {\n        return {\n            code: 'Name=\"Swanand Kadam\" Name=\"Swanand Kadam is goat\" Array=[ 20,30,\"swanand\"] Age=2020-1996 ageone=20 agetwo=30 x=ageone+agetwo City=\"Pune\" प्रिंट (x)  प्रिंट (Name)  प्रिंट (\"You live, you learn\")  प्रिंट (Age)  अगर (ageone>agetwo) {प्रिंट (\"condition worked\")} प्रिंट (Array[2] + Age + \"is young age\" + Age) अगर (ageone==20) {प्रिंट (\"condition 2 worked\") y=x+ageone प्रिंट (y) }',\n            output: '',\n            error: [],\n            OperationObjects: [],\n            linebylineOutput: '',\n            TimeTaken:''\n\n        };\n    },\n\n    methods: {\n        RUN: function() {\n\n            var t0 = performance.now()\n\n            //to stop accumulating output on succesive RUN\n            this.output = ''\n            this.linebylineOutput = this.output.split(\"\\n\")\n            this.error = []\n            this.OperationObjects = []\n            var sourcedata = this.code;\n            var cleaned_sourcedata = []\n            var i = 0;\n            var tokens = [];\n            var mixedimpurity = []\n            var updated_tokens = []\n            var variables_array = []\n            var assigned_variables = []\n            var terms = []\n            var terms2 = []\n            var operation = ''\n            var CalculationStack = []\n            var foundToken = ''\n            var ReIntializedVariables = []\n\n\n\n\n            //preparing sourcedata for easy parsing by handling new lines, enters etc.\n            //cleaning up the data to get my version of sourcedata. it's better to get version suitable for me because users can type what they wish but I need to maintain \n            //integrity of program in every possible conditio. So. I created my own condition below\n\n            function GetCleanSourcedata(sourcedata, cleaned_sourcedata, impurities) {\n\n                sourcedata = SourceDataReplaceforEasyParsing(sourcedata)\n\n                sourcedata.forEach((element, i) => {\n\n\n                    //finding the elements which has =\" in it so that to seprate them e.g. anna=\"swanand\" also finding the elements which starts with =. e.g \"=78787890\"\n\n\n                    if ((element.indexOf('=\"') > -1 || element.indexOf('=') > 0 || element.charAt(0) == \"=\") && element != '==')\n\n\n                    {\n\n\n\n                        impurities.push(element) //push such element as impurity in impurities\n\n\n\n                        let elements = element.split(\"=\")\n                        let index = cleaned_sourcedata.length\n\n\n                        cleaned_sourcedata[index] = (elements[0])\n                        cleaned_sourcedata[index + 1] = (\"=\")\n                        cleaned_sourcedata[index + 2] = (elements[1])\n\n\n                    }\n\n\n                    //as long as element is pure, push it to new and clean version of sourcedata\n                    if (!impurities.includes(element)) {\n\n\n                        cleaned_sourcedata.push(element)\n\n                    }\n\n                    //\n\n                })\n\n\n                //removing empty \"\" values for final version of sourcedata\n                //SECTION FInal sourcedata cleaning\n                cleaned_sourcedata = cleaned_sourcedata.filter(function(item) {\n                    return item !== \"\"\n                })\n\n\n\n                return cleaned_sourcedata;\n\n            }\n\n\n            let Result = GetCleanSourcedata(sourcedata, cleaned_sourcedata, mixedimpurity)\n\n            cleaned_sourcedata = Result\n            console.log('cleaned_sourcedata: ', cleaned_sourcedata);\n            \n\n\n\n            //SECTION - Start of Bharat Parser\n\n\n            //Checking for type of characters\n\n            const isVariable = TypeCheck.isVariable()\n            const isNumber = TypeCheck.isNumber()\n\n            const isOperator = TypeCheck.isOperator()\n\n            const isKeyword = TypeCheck.isKeyword()\n            const isConditionalKeyword = TypeCheck.isConditionalKeyword()\n            const isForLoop = TypeCheck.isForLoop()\n            const isWhileLoop = TypeCheck.isWhileLoop()\n\n            //needs work\n            const isExpression = TypeCheck.isExpression()\n\n            const isArray = TypeCheck.isArray()\n\n\n            const isSetArrayIndexValue = TypeCheck.isSetArrayIndexValue()\n\n            const isEmptyArrayInit = TypeCheck.isEmptyArrayInit()\n\n            const isString = TypeCheck.isString()\n\n            const isPureEval = AdvancedTypeCheck.isPureEval()\n\n            //if parser encounters anything like (\" or (, then that's a realtime print. \n            //buildstring will be applied now to create a string and push it into tokens\n\n            const isRealTimePrintMultipleString = AdvancedTypeCheck.isRealTimePrintMultipleString()\n\n\n\n            const isStringandValue = AdvancedTypeCheck.isStringandValue()\n\n            const isCalculation = AdvancedTypeCheck.isCalculation()\n\n            const isDirectPrintArithmetic = AdvancedTypeCheck.isDirectPrintArithmetic()\n\n\n\n\n            // to solve [a,n,n,a] into [anna]\n\n            //SECTION Build Operations \n\n            const BuildString = BuildOperation.BuildString()\n\n            const BuildArray = BuildOperation.BuildArray()\n\n            const BuildCondition = BuildOperation.BuildCondition()\n\n\n             //counting how many times do we have &&, || condition present\n            function Count(item, element) {\n\n                            let count = 0\n\n\n                            for (let i = 0; i < element.length; i++) {\n\n                                if (element.charAt(i) == item && element.charAt(i + 1) == item) {\n\n                                    count += 1\n\n\n\n                                }\n\n\n\n                            }\n\n                            return count;\n\n\n            }\n\n\n           \n           //This will run for every print statement encountered in the program, not just for loops\n\n            function IfTokenPrint(Tokens, j, global, iterator, OriginalIterator)\n\n\n            {\n\n\n\n\n                var token = Tokens[j].value\n                \n\n                var NextTokenValue = Tokens[j + 1].value\n\n\n                var StringVar = []\n\n                var b = RemoveBrackets(NextTokenValue)\n\n\n                if (isVariable(b)) {\n\n                    variables_array.push(b)\n                        // \n\n                }\n\n                //SECTION - Outputting the code\n                // finding the relvant value and then output it as HTML\n\n                //This loop is only for printing direct values like print(name), print(array)\n\n                updated_tokens.forEach((el, i) => {\n\n\n\n\n\n\n                    //THIS IS THE REAL GAME\n\n\n\n                    if (el.name == b) {\n\n                        //for calculations like x=ageone+agetwo\n\n                        //If we have already caluculated value, use that or else move forward\n\n\n\n\n\n\n                        if (assigned_variables.includes(el)) {\n\n\n                            global.output = global.output + el.value + \"\\n\";\n\n\n                        } else {\n\n\n                            if (isNumber(el.value)) {\n\n\n\n                                global.output = global.output + el.value + \"\\n\";\n\n                                assigned_variables.push(el);\n\n\n                            }\n\n                            //operations like age=2020-1996\n\n                            if (isPureEval(el.value)) {\n\n\n\n\n\n                                let outputpure = eval(el.value)\n\n\n\n                                el.value = outputpure\n\n\n                                global.output = global.output + outputpure + \"\\n\";\n\n                                assigned_variables.push(el);\n\n                            }\n\n\n\n                            //operations like name=\"swanand kadam\", variable assignments as strings\n\n                            if (!isPureEval(el.value) && !isNumber(el.value))\n\n\n                            {\n\n\n\n\n                                if (!(el.name.includes(']') && el.name.includes('['))) {\n                                    global.output = global.output + el.value + \"\\n\";\n\n                                    assigned_variables.push(el);\n                                }\n\n\n\n\n                            }\n\n\n\n\n                        }\n\n                    }\n\n\n\n\n\n                    // work to be continued\n                })\n\n\n                //ANCHOR - CONDITION 2\n                if (Tokens[j + 1].type == 'Array')\n\n\n\n\n                {\n\n                    //To run only if iterator is present\n\n                    //This runs on for loop - Print(Array[a]) etc\n\n                    //this runs only if for(i) and in the loop, array[i], not on array[x]. Iterator and index should be same\n\n                    if (iterator != undefined && Tokens[j + 1].IndexInput == OriginalIterator)\n\n                    {\n\n\n\n                        let Value = NextTokenValue\n\n                        let ArrayElement = CreateArrayElement(Value, iterator)\n\n\n                        let output = GetArrayorStringElement(ArrayElement, updated_tokens)\n\n\n\n\n                        global.output = global.output + output + \"\\n\";\n\n\n                        assigned_variables.push(Tokens[j + 1]);\n\n\n                    }\n\n\n                    //This runs to Print(Array[2]) like specific array values\n                    if (Tokens[j].IndexInput != OriginalIterator)\n\n                    {\n\n\n                        //\n\n                        let Value = NextTokenValue\n                        let IndexToChange = Tokens[j + 1].IndexInput\n\n\n                        let ArrayElement = CreateArrayElement(Value, IndexToChange)\n                        let output = PrintArrayElement(ArrayElement, updated_tokens)\n\n\n\n                        if (output != undefined) {\n                            global.output = global.output + output + \"\\n\";\n\n\n                        }\n\n\n\n\n\n                    }\n\n                    //This collects print(Array[a]) from for loop and normal Print(Array[2])\n\n                }\n\n\n\n\n                //printing direct numbers and direct calcultions like print(10), print(10*10)\n\n                if (token == 'प्रिंट' && (isPureEval(NextTokenValue) || isNumber(RemoveBrackets(NextTokenValue)))) {\n\n\n                    let a = eval(NextTokenValue)\n\n                    global.output = global.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n\n\n\n                //foroperations like print('you live, you learn')\n                if (Tokens[j + 1].mode == \"RealTimePrint\" && !NextTokenValue.includes('+') && !NextTokenValue.includes('='))\n\n                {\n\n                    let output = RemoveBrackets(NextTokenValue)\n\n                    output = output.replace(/\"/g, '');\n                    output = output.replace(/'/g, '');\n\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n\n\n\n                }\n\n                //operations like print(Age + 'is young age')\n\n                if (Tokens[j + 1].mode == \"RealTimePrint\" && NextTokenValue.includes('+')) {\n\n\n\n                    let x = SplitElementsArray(NextTokenValue)\n\n\n                    StringVar = SetValues(x, updated_tokens)\n\n\n\n                    StringVar = StringVar.join('')\n                    StringVar = StringVar.split(\"+\")\n\n                    let output = StringVar.join(' ')\n                    output = RemoveBrackets(output)\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n\n\n\n\n                }\n\n\n                //THIS CODE is to run print index value in loop, e.g print(i) if iterator is i. \n                //Runs only in for loop\n\n                if (OriginalIterator == RemoveBrackets(NextTokenValue)) {\n\n                    global.output = global.output + \"\\n\" + iterator + \"\\n\"\n\n\n                }\n\n\n                if (isCalculation(RemoveBrackets(NextTokenValue)) && Tokens[j + 1].mode != \"RealTimePrint\")\n\n                {\n\n\n                    let output = CalculateValues(NextTokenValue, j, updated_tokens)\n\n                    global.output = global.output + \"\\n\" + output + \"\\n\"\n\n\n\n                }\n                // \n\n\n\n\n\n            }\n\n\n            //END OF Functions and Imported Functions\n\n\n\n            //SECTION - Parsing STARTS here\n\n            //SECTION - Checking each token and adding to tokens array\n\n\n\n            let tempthis = this;\n            let variableArray = [] //TO REMOVE DUPLICATE VARIABLES, SEE 482\n\n            function Parse(cleaned_sourcedata, i) {\n\n                var element = cleaned_sourcedata[i];\n\n                var string = []\n\n\n\n\n                if (isVariable(element) == true) {\n\n                    if (cleaned_sourcedata[i + 1] == '=') {\n\n\n                        PushVariable(element, tokens)\n\n                        if (variableArray.includes(element)) {\n\n                            let UpdateElementValue = element\n\n                            let x = tokens.find(el => el.value == element)\n\n                            let index = tokens.indexOf(x)\n\n\n\n                            //\n\n\n                            ReIntializedVariables.push({\n                                name: element\n                            })\n\n                            //\n\n                            //tokens[index+2].value= cleaned_sourcedata[i+2]\n\n\n\n                        }\n\n                        variableArray.push(element)\n\n\n\n\n\n                    }\n\n                }\n\n                if (isNumber(element) == true) {\n\n                    PushNumber(element, tokens)\n\n                }\n\n                if (isOperator(element) == true) {\n                    PushOperator(element, tokens)\n\n                }\n\n                if (isKeyword(element) == true) {\n\n                    PushKeyword(element, tokens)\n\n                }\n\n                //check if it accpets Arry[2a] as index : \n                if (isArray(element) == true) {\n\n                    if (element.charAt(element.length - 1) == ']') {\n\n\n                        PushArray(element, tokens)\n\n                    } else {\n\n\n                        let BuiltArray = BuildArray(element, i, cleaned_sourcedata)\n\n                        PushArray(BuiltArray, tokens)\n\n\n\n                    }\n                }\n\n                if (isSetArrayIndexValue(element, cleaned_sourcedata, i) == true) {\n\n\n\n\n                    PushSetArrayIndexValue(element, tokens, cleaned_sourcedata, i)\n\n\n                }\n\n                if (isEmptyArrayInit(element, cleaned_sourcedata, i) == true) {\n\n\n\n                    PushEmptyArrayInit(tokens, cleaned_sourcedata, i)\n\n\n                }\n\n\n\n\n                if (isConditionalKeyword(element) == true) {\n                    \n\n\nif (isWhileLoop(element) == true) {\n\n                    PushWhileLoop(element, tokens,cleaned_sourcedata,i)\n                   // PushWhileLoopCondition(element, cleaned_sourcedata, i, tokens)\n\n\n                }\n\n                else{\n\n                    PushConditionalKeyword(element, tokens)\n                }\n                   \n                   \n                   let foundcondition = BuildCondition(element, i, cleaned_sourcedata)\n                    console.log('foundcondition: ', foundcondition);\n\n\n\n                    PushCondition(foundcondition, tokens)\n\n                \n\n\n                }\n\n\n                if (isForLoop(element) == true) {\n\n                    PushForLoop(element, tokens)\n                    PushForLoopAruguments(element, cleaned_sourcedata, i, tokens)\n\n\n                }\n\n                \n\n\n                if (isCalculation(element) == true) {\n\n\n                    let element = ''\n\n                    if (cleaned_sourcedata[i + 1] != undefined) {\n\n\n\n                        // this is to perform long operations like AverageAge=(ageone+agetwo)/2 + (ageone+agetwo)*2\n\n                        while (isCalculation(cleaned_sourcedata[i]))\n\n\n\n                        {\n\n\n                            element = element + cleaned_sourcedata[i];\n\n\n                            i++;\n\n                        }\n\n\n\n\n\n                    }\n\n\n                    //PushCalculation(element,tokens)\n\n\n\n\n                    //  \n                    terms = element.split('')\n\n                    //removing the \"(\"\" and \")\"\n\n                    var CleanedElement = RemoveBrackets(element)\n\n\n                    // to stop prevention of expressions like is\"+ getting added as a calculation\n                    if (!(CleanedElement.includes('\"')) && element.charAt(0) != '/' && element.charAt(0) != '*') {\n\n\n                        PushCalculation(element, tokens)\n\n\n                    }\n\n\n                    // terms2 = CleanedElement.split(operation)\n\n                    //checkpoint: to perform calculations \n                    //I have identified the operation(seperated) and terms (seperated)\n\n\n\n                    /*      tempthis.OperationObjects.push({\n                                  terms: terms2,\n\n\n                              }\n\n\n\n                          )\n                          */\n\n\n\n\n\n                }\n\n                //finding operations like print(\"swanand\"). The realtimeprint operations\n\n\n\n                if (isRealTimePrintMultipleString(element) == true) {\n\n\n\n                    //\n                    let foundString = ''\n\n                    let k = i\n                    let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n\n                    var flag = 0;\n\n\n\n\n                    for (k; k < cleaned_sourcedata.length; k++) {\n\n                        let element = cleaned_sourcedata[k]\n                        let conditionEnd = element.charAt(element.length - 1) + element.charAt(element.length - 2)\n\n\n\n                        if (cleaned_sourcedata[k].includes('प्रिंट') || cleaned_sourcedata[k].includes('अगर')) {\n\n\n                            //foundString=foundString+  ' '+ cleaned_sourcedata[k]\n\n                            //\n                            break;\n\n\n                        }\n\n                        if (conditionEnd == ')\"')\n\n                        {\n\n                            foundString = foundString + ' ' + cleaned_sourcedata[k];\n                            break;\n\n                        }\n\n                        if (flag == 1) {\n\n                            foundString = foundString + ' ' + cleaned_sourcedata[k]\n\n                        }\n\n                        if (flag == 0) {\n\n                            foundString = cleaned_sourcedata[k];\n\n                            flag = 1;\n\n                        }\n\n\n\n\n                    }\n\n\n\n                    if ((!foundString.includes(\">\")) && (!foundString.includes('/')) && (!foundString.includes('*')) && (!foundString.includes('<')) && (!foundString.includes('==')))\n\n\n                    {\n\n                        // \n                        PushRealTimePrintOperation(foundString, tokens)\n                    }\n\n\n\n\n                }\n\n\n                if (isStringandValue(element) == true) {\n\n\n                    //\n\n                }\n\n\n\n\n                //storing only the string values to tokens ( not the strings in print statements)\n\n                if (isString(element))\n                \n\n                {\n\n\n\n                    let calculatedString = BuildString(element, i, cleaned_sourcedata)\n\n\n\n                    calculatedString = calculatedString.replace(/['\"]+/g, '')\n\n                    if (!(calculatedString.includes(\"प्रिंट\")))\n\n                        PushString(calculatedString, tokens)\n\n                    //\n\n\n\n                }\n\n\n\n\n                //Found Solution using regexp- print(a) without space is getting accepted as expression\n\n\n                if (/^(?=.*?प्रिंट)(?=.*[a-z])/.test(element)) {\n\n                    PushKeyword(element.slice(0, 6), tokens); //Pushing print keyword only\n                    \n                    \n                    PushExpression(element.slice(6), tokens) //Pushing remaining expression like (a), (gagaks) etc\n                }\n\n\n                //error prone change made here\n\n                if (isExpression(element) == true && !isCalculation(element) && !element.includes('[') && !element.includes(']') && (!isConditionalKeyword(cleaned_sourcedata[i - 1]))&& (cleaned_sourcedata[i - 1] != 'मे' ))  {\n\n                                      \n\n                   PushExpression(element, tokens)\n\n\n\n                }\n                if (isExpression(element) == true && element.includes('[') && element.includes(']')) {\n\n                    PushArray(element, tokens)\n\n                }\n\n\n                if (!isKeyword(element) && !isNumber(element) && !isVariable(element) && !isExpression(element) && !isOperator(element)) {\n\n\n                    //ANCHOR \n                    /*Hnadling Impurity error-The main problem is figuring out how to solve \"=7000\" like things\n                    instead asking developers to add space manually\n                    Handling Alphanumeric strings to solve issues like ' anna=2362934'*/\n\n                    let impurity = element.split('=')\n\n                    let findString = impurity[1]\n\n\n                    //to accept long numbers i.e a=749374593745937\n\n                    if (isVariable(impurity[0]) && isNumber(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n                    //to accept a=STRING\n                    if (isVariable(impurity[0]) && isVariable(impurity[1])) {\n\n\n                        impurity[2] = impurity[1];\n                        impurity[1] = '=';\n\n                    }\n\n\n\n                    impurity.forEach((element, i) => {\n\n                        if (isVariable(element) == true) {\n\n\n\n                            PushVariable(element, tokens)\n\n\n                            //continue;\n                        }\n\n                        // ANCHOR \n\n                        //Issue: Right now, only isNumber is resolved, a=, =23828qw aren't resolved.\n                        //Solution: Work on all the modules\n\n\n                        if (isNumber(element) == true) {\n\n\n                            PushNumber(element, tokens)\n\n                        }\n\n                        //ANCHOR \n                        //You might have to remove this extra filters since you are only working on numbers (Future Issue)\n                        if (isOperator(element) == true) {\n                            PushOperator(element, token)\n\n                        }\n\n\n\n                        if (isKeyword(element) == true) {\n\n                            PushKeyword(element)\n\n                        }\n\n                        if (isExpression(element) == true ) {\n                            \n\n                            PushExpression(element, tokens)\n\n                        }\n\n\n\n\n                    })\n\n\n                }\n\n\n\n            }\n\n            //SECTION - Checking each token and adding to tokens array\n            // PARSING INITIATION\n\n\n            for (i; i < cleaned_sourcedata.length; i++) {\n\n\n                Parse(cleaned_sourcedata, i)\n            }\n\n            //ANCHOR \n            //CLEANING UP THE TOKENS ARRAY\n            //Removing tokens with value = '', It was generated due to \" cleaned_sourcedata = cleaned_sourcedata.replace(/(;|\\n|\\r)/gm, \" \").split(' ')\"\n            tokens = tokens.filter(el => el.value != '')\n            console.log('tokens: ', tokens);\n            \n\n\n\n\n            //To find undefined variables\n            let difference = variables_array.filter(x => !assigned_variables.includes(x))\n\n            //\n\n            if (difference.length > 0)\n\n            {\n                this.error.push(' Variable ' + difference.toString().split(',') + ' is undefined ')\n\n            }\n\n\n\n\n            //SECTION - Printing Outputs, considering conditions, finding values in updated_tokens\n\n\n\n\n            for (var j = 0; j < tokens.length; j++) {\n\n                // Checking for assignment operators\n\n\n                let mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n                let tokenType = mutable_tokens[j].type\n\n\n\n                var StringVar = []\n\n                let VarWithoutbrackets = RemoveBrackets(mutable_tokens[j].value)\n\n                VarWithoutbrackets = VarWithoutbrackets.replace(/ /g, '')\n\n\n                if (mutable_tokens[j].type == \"SetArrayIndexValue\")\n\n\n\n                {\n\n                    let ValueToSet = mutable_tokens[j].ValueToSet\n\n\n\n\n\n\n                    let x = GetArrayorStringElement(mutable_tokens[j].value, updated_tokens, ValueToSet)\n\n\n\n                }\n\n                if (mutable_tokens[j].value == '=') {\n\n                    //assigning values to variables\n\n                    let variable = mutable_tokens[j - 1].value\n\n\n\n\n\n                    //\n                    let varvalue = mutable_tokens[j + 1].value\n\n\n\n                    //\n\n                    //finding if elements is already assgined in updated tokens\n                    //to solve name='swanand' and name= 'other swanand'\n                    //both shpuld be printed accordinggly\n\n\n                    let n = updated_tokens.find((el, i) => el.name == variable)\n\n\n\n                    // \n\n\n\n                    if (n == undefined) {\n\n\n\n                        //to check if the assigned value needs to be calculated. this is futher diveded in two types\n                        if (isCalculation(varvalue))\n\n\n                        {\n\n\n                            //type 1- Age= 2020-2000 \n                            if (isPureEval(varvalue))\n\n\n\n                            {\n\n\n                                let value = eval(varvalue)\n\n                                //write function for this, so repeatable\n                                updated_tokens.push({\n                                    name: variable,\n\n                                    value: value,\n\n                                    identifier: j,\n                                    type: mutable_tokens[j + 1].type\n                                })\n\n\n                            }\n\n                            //type 2- X= ageone+agetwo\n                            else {\n\n\n                                //performing the calculation\n                                // \n                                let value = CalculateValues(varvalue, j, updated_tokens)\n\n\n\n\n\n                                updated_tokens.push({\n                                    name: variable,\n\n                                    value: value,\n\n                                    identifier: j,\n                                    type: mutable_tokens[j + 1].type\n                                })\n\n\n\n                            }\n\n\n\n                        }\n\n\n                        //if there is no need to calculate, push values as it is\n                        else {\n\n                            updated_tokens.push({\n                                name: variable,\n\n                                value: varvalue,\n\n                                identifier: j,\n                                type: mutable_tokens[j + 1].type\n                            })\n\n\n                        }\n\n\n                    }\n\n\n\n\n                    //if it's already assgined, reassign it with updated value\n                    else {\n\n\n                        if (isCalculation(varvalue)) {\n\n                            let NewValue = CalculateValues(varvalue, j, updated_tokens)\n                            n.value = NewValue\n\n\n                        } else {\n\n                            n.value = varvalue\n                        }\n\n\n\n\n\n                    }\n                    //\n                    //\n\n                    // \n\n\n                }\n\n\n\n                if (tokenType == 'condition')\n\n                {\n\n\n                   \n\n                    let element = mutable_tokens[j].value\n\n //this function is the first step to handlle operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n                \n                let ConditionValue= GetConditionValue(element,updated_tokens,j )\n                \n                \n//console.log('ConditionValue: ', ConditionValue);\n\n                   \n\n\n                    //if value is false, just skip the if loop context, if not it will be ran in final print module\n\n                    if (ConditionValue == false) {\n\n                        let InitializeLoop = tokens.indexOf(mutable_tokens[j])\n\n\n\n\n                        while (mutable_tokens[j + 1].value != '}')\n\n\n\n                        {\n\n\n\n\n                            //tokens.splice(j+1, 1);\n\n                            //No need to delete tokens, we are just skipping over the values so that they won't be printed or run\n\n                            j++;\n\n\n                        }\n\n\n\n\n                    }\n\n\n\n\n                }\n\n                if (token == 'प्रिंट')\n\n\n                {\n\n\n\n                    IfTokenPrint(mutable_tokens, j, this) //for operations like print(array[3])\n\n\n                }\n\n                if (tokenType == 'WhileLoopStart')\n                {\n\n                 \n                let TokensCurrentIndex=j+3\n\n                   let ConditionValue = false\n\n                    let element = mutable_tokens[j+1].value\n\n                    let ExtratcedVariable=[]\n                    \n                    let variable=''\n                   let WhileLoopSourcedataIndexStart =0\n                   let WhileLoopSourcedataTokens=[]\n\n                   \n\n                    for(let i=0;i<element.length;i++)\n  {\n                        let x= element.charAt(i)\n                        \n\n                        if(isVariable(x))\n                        \n                        {\n\n                            variable=variable+x\n                            \n                            \n\n                        }\n                        if(!isVariable(element.charAt(i+1)) && isVariable(x))\n                        {\n\n           let token=updated_tokens.find(el=> el.name==variable)\n            \n            ExtratcedVariable.push(\n                {\n                    variable:variable,\n                    value:token.value\n\n                }\n            )\n\n\n            variable=''\n\n\n                        }\n                        \n  }\n\n\n                    //this function is the first step to handlle operations like अगर (ageone==10 && AverageAge<1000 && agetwo>100 || ageone==10) OR (ageone==10 )\n                   \n    function getLoopIndexStart(mutable_tokens, j, check, setIndex)\n\n                    {\n\n\n                        while (mutable_tokens[j].value != check)\n\n\n\n                        {\n\n\n                            if (mutable_tokens[j + 1].value == check) {\n\n\n\n                                setIndex = j + 1\n\n\n                            }\n\n\n\n                            j++;\n\n                        }\n                        return setIndex\n  }\n\n                    function getWhileLoopSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n\n\n                        let flag = true\n\n                        while (flag) {\n\n\n\n                            if (mutable_tokens[startIndex].value == '{') {\n                                console.log('startIndex: ', startIndex);\n\n\n                                while (mutable_tokens[startIndex].value != '}' ) {\n\n\n                                  StoreResult.push(mutable_tokens[startIndex+1])\n\n\n                                    startIndex++;\n\n\n\n                                    \n\n\n                                }\n\n\n\n                            }\n\n\n\n\n                            if (mutable_tokens[startIndex].value == '}') {\n\n\n\n                                //  \n\n\n                                break;\n\n\n                            }\n\n                            startIndex++;\n\n                        }\n\n                        //this line is important. We are skipping the index of mutable tokens until forloop is completed. This is done to have seprate for loop context and othe\n                        //other fuctions should not intervene in for loop execution\n\n                        j = startIndex + 1\n\n                        return StoreResult\n                        \n\n\n\n\n                    }\n\n\n\n\n\n                    WhileLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', WhileLoopSourcedataIndexStart)\n                        //\n                    WhileLoopSourcedataTokens = getWhileLoopSourcedata(WhileLoopSourcedataIndexStart, mutable_tokens, '}', WhileLoopSourcedataTokens)\n                    \n                    \n                    \n                    \n\n//constantly accessing the conditionvalue\n                \n                while(GetConditionValue(element,updated_tokens,j+1 ))\n                {\n\n                            for(let i=0;i<WhileLoopSourcedataTokens.length;i++){\n\n\n                            //SECTION while loop context\n\n                                    if(WhileLoopSourcedataTokens[i].value=='=') {\n      \n      \n      \n\n                                AssignorUpdateValues(WhileLoopSourcedataTokens,i,updated_tokens)\n\n                                //\n\n                                // \n\n\n                            }\n\n                           \n\n                            // Handling CONDITIONAL statements in for loop\n\n                            if (WhileLoopSourcedataTokens[i].type == 'condition')\n\n                            {\n\n\n\n\nHandleConditions(WhileLoopSourcedataTokens,i,updated_tokens)\n\n\n                            }\n\n\n \n \n                                if (WhileLoopSourcedataTokens[i].value == 'प्रिंट')\n\n\n\n                                      {\n  \n\n                                           IfTokenPrint(mutable_tokens, TokensCurrentIndex+i, this) //for operations like print(array[3])\n                    \n                    \n                    \n\n\n                                             }\n            \n                            }\n\n                            \n                }\n                }\n              \n\n        \n\n                \n\n\n\n\n                if (tokenType == 'ForLoopStart')\n\n\n\n                {\n\n\n\n\n                    //Getting evry information about for loop \n\n\n                    let ForLoopMetaData = mutable_tokens[j + 1]\n\n\n                    //Splitting the forloopmetadat values individually\n                    let iterator = ForLoopMetaData.iterator\n\n                    let element = ForLoopMetaData.value\n                    var IterationStart = parseInt(ForLoopMetaData.iterationStart)\n                    var IterationEnd = parseInt(ForLoopMetaData.iterationEnd)\n                   // let ForLoopSourcedata = ForLoopMetaData.ForLoopSourcedata\n                        //\n\n\n                    var elementValue = updated_tokens.find(el => el.name == element)\n                    var elementLength = 0\n                    var FlagPrimalLoop = 0\n                    var ForLoopSourcedataIndexStart = 0\n                    var SourcedataTokens = []\n                    var OriginalIterator = ForLoopMetaData.iterator\n\n                    //\n                    function getLoopIndexStart(mutable_tokens, j, check, setIndex)\n\n                    {\n\n\n                        while (mutable_tokens[j].value != check)\n\n\n\n                        {\n\n\n                            if (mutable_tokens[j + 1].value == check) {\n\n\n\n                                setIndex = j + 1\n\n\n                            }\n\n\n\n                            j++;\n\n                        }\n                        return setIndex\n\n\n                    }\n\n                    function getSourcedata(startIndex, mutable_tokens, check, StoreResult) {\n\n\n                        let flag = true\n\n                        while (flag) {\n\n\n\n                            if (mutable_tokens[startIndex].value == '{') {\n\n\n                                while (mutable_tokens[startIndex].value != '}') {\n\n                                    StoreResult.push(mutable_tokens[startIndex + 1])\n                                    startIndex++;\n\n\n                                }\n\n\n\n                            }\n\n\n\n\n                            if (mutable_tokens[startIndex + 1].value == '}') {\n\n\n\n                                //  \n\n\n                                break;\n\n\n                            }\n\n                            startIndex++;\n\n                        }\n\n                        //this line is important. We are skipping the index of mutable tokens until forloop is completed. This is done to have seprate for loop context and othe\n                        //other fuctions should not intervene in for loop execution\n\n                        j = startIndex + 1\n\n\n                        return StoreResult\n                        \n\n\n\n\n                    }\n\n\n\n\n\n                    ForLoopSourcedataIndexStart = getLoopIndexStart(mutable_tokens, j, '{', ForLoopSourcedataIndexStart)\n                        //\n\n                    SourcedataTokens = getSourcedata(ForLoopSourcedataIndexStart, mutable_tokens, '}', SourcedataTokens)\n                    \n\n\n\n\n\n                    if (element.includes('(') && element.includes(','))\n\n                    {\n\n                        FlagPrimalLoop = 1\n\n\n\n                        //shall we ceeate a forloop context here?\n\n\n\n\n                    }\n\n\n\n                    // Run if start and end parameters are not given e.g दुहराओ a को  Name मे \n                    // This is ran just to get Start and End parameters as they are not provided\n                    if (ForLoopMetaData.iterationEnd == undefined) {\n\n\n                        //run if element is array\n                        if (elementValue.type == 'Array')\n\n\n                        {\n                            elementLength = elementValue.value.split(',').length\n\n                            IterationStart = 0\n                            IterationEnd = elementLength\n\n\n                        }\n\n                        //run if element is String\n                        else {\n                            elementLength = elementValue.value.length\n                            IterationStart = 0\n                            IterationEnd = elementLength\n\n\n                        }\n\n\n                    }\n\n\n\n\n                    let Cycle = IterationEnd\n\n\n                    //Iterating over forloop sourcedata\n\n\n                    for (iterator = IterationStart; iterator < Cycle; iterator++) {\n\n\n                        //flag to avoid running this code if loop is primal because the payload needs to be compeltely different\n                        if (FlagPrimalLoop = 0) {\n                            ForLoopArrayorStringOutput(elementValue, iterator, updated_tokens, this)\n\n                        }\n\n\n                        for (let i = 0; i < SourcedataTokens.length; i++)\n\n\n                        {\n\n\n\n\n\n\n                            if (SourcedataTokens[i].value == '=') {\n\n                                //assigning values to variables\n\n                            AssignorUpdateValues(SourcedataTokens,i,updated_tokens)\n\n                            }\n\n\n\n\n                            //Handling print statements in for loop\n\n                            if (SourcedataTokens[i].value == 'प्रिंट')\n\n\n\n\n\n                            {\n\n                                //for operations like print(array[3])\n                                IfTokenPrint(SourcedataTokens, i, this, iterator, OriginalIterator)\n\n                                //\n\n\n                            }\n\n\n\n                            //Handling set array element statements in for loop\n                            if (SourcedataTokens[i].type == \"SetArrayIndexValue\")\n\n\n\n\n                            {\n\n                                let Value = SourcedataTokens[i].value\n\n                                let ValueToSet = SourcedataTokens[i].ValueToSet\n\n                                let element = RemoveBrackets(Value);\n\n                                var ArrayElement = ''\n\n\n                                //Seprating out index identifier. xyz from Array[xyz]\n\n                                element = element.replace(']', '')\n\n\n                                let Split = element.split('[')\n\n\n                                // run if we need to set direct Array element value. like Array[2]= xyx                    \n                                if (isNumber(Split[1])) {\n\n                                    Split = Split.join('[')\n                                        //\n\n                                    Split = Split + ']'\n\n                                    ArrayElement = Split\n\n\n                                }\n\n                                // run if we need to dynamically set Array element value. like Array[i]= xyx\n                                //CreateArrayElement function will create dynamic Array values. like Array[0], Array[1] etc.                    \n                                else {\n                                    ArrayElement = CreateArrayElement(Value, iterator)\n\n\n                                }\n\n\n\n                                // this code is written to find operations like Array[a]= a*100+age*a. notice a\n                                //find a way to simplify this in long term\n\n                                let data = ValueToSet\n\n                                data = data.split('*').toString();\n                                data = data.split('+').toString();\n                                data = data.split('-').toString();\n                                data = data.split('/').toString();\n                                data = data.split(',')\n\n\n                                //building a new value to convert a*100+age*a into 5*100+age*a and then sending it to CalculateValues()\n                                let NewValueToSet = ''\n\n                                // \n\n\n                                if (data.includes(Split[1]) && data.length > 1)\n\n                                {\n\n                                    //we have operations like Array[a]= a*100+age*a. notice a\n\n\n                                    for (let m = 0; m < ValueToSet.length; m++)\n\n                                    {\n\n                                        if (ValueToSet[m] == Split[1] && !(/^[a-z]+$/i.test(ValueToSet[m + 1])))\n\n                                        {\n\n\n\n                                            // value is been set . replacing index value a with iteartor value 0,1,2, etc.   \n                                            NewValueToSet = NewValueToSet + iterator\n\n                                        } else {\n\n                                            NewValueToSet = NewValueToSet + ValueToSet[m]\n\n\n                                        }\n\n\n\n                                    }\n\n                                    let iterat = false\n                                        //gave it a different name so it would not fuck up with for loop iterator\n\n                                    NewValueToSet = CalculateValues(NewValueToSet, j, updated_tokens, )\n\n                                    // \n\n                                    SetArrayorStringElement(ArrayElement, updated_tokens, iterat, NewValueToSet, tokens)\n\n\n\n\n                                }\n\n\n                                // this condition enables program to only run  Array[a]= xyz when iterator is a. It disallows running Array[blablabla]=xyz\n                                if (OriginalIterator == Split[1]) {\n\n                                    if (Split[1] == ValueToSet) {\n\n\n                                        let iterator = true\n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    // for operations like Array[a]=ageone*100\n\n\n                                    if (!data.includes(Split[1]) && OriginalIterator == Split[1]) {\n\n\n                                        let iterator = false\n\n                                        ValueToSet = CalculateValues(ValueToSet, j, updated_tokens)\n                                            // \n\n                                        SetArrayorStringElement(ArrayElement, updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                    }\n\n                                    //SetArrayorStringElement(ArrayElement,updated_tokens, iterator, ValueToSet, tokens)\n\n\n\n                                }\n\n\n\n\n\n                            }\n\n\n\n                            // Handling CONDITIONAL statements in for loop\n\n                            if (SourcedataTokens[i].type == 'condition')\n\n                            {\n\n\nHandleConditions(SourcedataTokens,i,updated_tokens)\n\n\n\n                            }\n\n\n                        }\n\n\n\n                    }\n\n\n\n\n                }\n\n                //END FOR LOOP EXECUTION\n\n\n\n\n\n\n\n            }\n\n\n\n\n\n            \n\n\n\n\nvar t1 = performance.now()\nif(this.output!='')\n{\nthis.TimeTaken= \"Compiled Succesfully in \" + (t1 - t0).toPrecision(4) + \" ms.\"\n\n}\n\n            this.linebylineOutput = this.output.split('\\n')\n\n\n            this.linebylineOutput = this.linebylineOutput.filter(function(item) {\n                return item !== \"\"\n            })\n\n\n\n\n\n            //SECTION - Calculating remaining values\n\n\n            //so that replace x with values\n\n            /*\n                        updated_tokens.forEach((el, i) => {\n\n\n                            let element = el.value\n\n\n                            //removing the \"(\"\" and \")\"\n\n\n                            var CleanedElement = RemoveBrackets(element)\n\n                            operation = ''\n\n\n\n                            //why pureeval?\n                            // operations like 50+60 were set as [5,0,+,6,0] instead of [50,+,60]. basically direct calculation was not working\n                            //pureeval finds such pure operations and then calculate them to directly set their value\n                            //this shit is only for pureoperations\n                            let pureval = /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedElement)\n\n                            if (pureval == true) {\n\n\n\n                                updated_tokens[i].value = eval(updated_tokens[i].value)\n\n\n                            }\n\n\n\n\n                            if (isCalculation(CleanedElement) == true && !pureval) {\n\n                                terms = CleanedElement.split('')\n\n\n\n                            }\n\n\n\n\n                        })\n\n\n\n\n                        //\n\n                        // performing calculations\n\n\n\n\n                        updated_tokens.forEach((el, i) => {\n\n                            var indextoChange = '' //to know which value to replace like \"anna+dada-bad\" with \"5+6-7\"\n\n\n\n                            let element = el.value // reading the current value, for lon string variable names it's still like \"anna+dada-bad\"\n                            element = element.toString()\n                            var StringVar = []\n                            // \n\n                            let pureval = /^([-+]?[a-z]*\\.?[a-z]+[\\/\\+\\-\\*])+([-+]?[a-z]*\\.?[a-z]+)*$/gm.test(element)\n\n\n\n                            if (element.includes('>') || element.includes('<') || element.includes('==')) {\n\n\n\n                                StringVar = SplitElementsArray(element)\n\n\n\n                                StringVar = SetValues(StringVar, updated_tokens)\n\n\n                                UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n\n\n                            }\n\n\n                            //finding operations like a+b-c\n                            if (pureval == true || element.charAt(0) == \"(\") {\n\n                                // \n\n\n                                StringVar = SplitElementsArray(element)\n                                StringVar = SetValues(StringVar, updated_tokens)\n                                UpdateUpdated_tokenswithValues(StringVar, i, updated_tokens)\n\n\n                            }\n\n\n\n\n                        })\n\n\n\n\n                        /*\n                         ReIntializedVariables.forEach(el=>{\n\n                        let flag=0\n                        let SkipIndex=0\n\n                        for(let m=0;m<updated_tokens.length;m++)\n                        {\n                            \n                        if(el.name==updated_tokens[m].name && flag==0)\n                        {\n\n\n                        if(el.value.charAt(0)=='\"')\n                        {\n\n\n                            let BuiltString= BuildString(el.value, )\n\n                            \n                        }\n                        flag=1;\n                        updated_tokens[m].value=el.value;\n\n\n                        \n\n                        SkipIndex=m\n\n\n                        }\n\n                        //\n\n                        if( m!=SkipIndex && flag==1 && el.name==updated_tokens[m].name)\n\n                        {\n\n                        updated_tokens.splice(m,1)\n\n                        }\n\n\n                        }\n\n\n\n\n                        })\n                        */\n\n\n\n\n            //SECTION - Iterating over tokens and then PRINTING FINAL using values stored in updated tokens\n\n            /*        \n\n            for (var j = 0; j < tokens.length; j++) {\n\n\n                var mutable_tokens = tokens\n                var token = mutable_tokens[j].value\n             \n\n                if (token == 'प्रिंट' )\n\n                {\n\n                    var b = RemoveBrackets(mutable_tokens[j+1].value)\n\n\n\n\n                    variables_array.push(b)\n\n                    \n\n                 \n                    //SECTION - Outputting the code\n                    // finding the relvant value and then output it as HTML\n                    updated_tokens.forEach((el, i) => {\n\n                        if (el.name == b ) {\n\n\n\n                            this.output = this.output + el.value + \"\\n\";\n\n                            assigned_variables.push(el.name);\n\n                           \n\n\n                        }\n\n\n\n                        // work to be continued\n\n                    })\n\n                    \n\n                    \n\n                }\n\n\n                //Handling Conditions\n\n                if(mutable_tokens[j].type==\"condition\")\n                {\n\n\n\n                   \n\n                    let token= updated_tokens.find(el=> el.originalvalue==mutable_tokens[j].value)\n\n\n\n                    let ConditionValue=token.value\n\n                  \n\n                   if(ConditionValue==false)\n                   {\n\nlet InitializeLoop= tokens.indexOf(mutable_tokens[j])\n\n\n\n\n\nwhile(mutable_tokens[j+1].value!='}' )\n{\n\n\n\n    let x= mutable_tokens[j+1].value.length\n    \n    \ntokens.splice(j+1, 1);\n \n\n    j++;\n\n\n}\n\n\n\n\n                   }\n\n\n                }\n\n\n                if(token == 'प्रिंट' && /^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(mutable_tokens[j+1].value) )\n                {\n \n                let a= eval(mutable_tokens[j+1].value)\n\n                this.output = this.output + \"\\n\" + a + \"\\n\"\n\n                }\n\n                \n\n        \n              \n\n\n\n\n      // this is to handle प्रिंट (\"Age is\"+ Age) etc.\n\n                if(isStringandValue(mutable_tokens[j].value))\n{\n\n\n        \n\n                    let x=mutable_tokens[j].value\n                    let string=''\n                    let newel=''\n\n                    x=RemoveBrackets(x)\n\n                    \n                    //x = x.replace(/ /g,'')\n\n                    x=x.split(\"+\")\n\n                    \n\n                    x.forEach(element => {\n                        \n\n                        \n                        if(element.charAt(0)== \" \" || element.charAt(element.length-1)==\" \" && !(element.includes('\"'))){\n\n                          \n                       newel= element.replace(/\\s/g, '');\n\n                        \n\n\n                        }\n                        else{\n\n                            newel=element\n                        }\n\n                       let y= updated_tokens.find(el=> el.name== newel)\n\n                      \n                       \n//\n                       if(y!=undefined)\n                       {\n\n\n\n                       string=string + ' ' + y.value\n                       //\n\n\n                       }\n                       else{\n\n                           \n                           element= element.replace(/\"/g, '');\n                           string=string+ ' ' + element\n                       }\n                       \n\n                       \n\n                    });\n\n\n\n                        this.output = this.output + \"\\n\" + string + \"\\n\"\n}\n\n\n//THIS IS to handle operations like प्रिंट (\"Name is GOAT\"), प्रिंट (\"Goodbye\")\n\nelse{\n\n\n\n                  let value= RemoveBrackets(mutable_tokens[j].value)\n                 // \n\n                  \n\n                   let CleanedValue = value.replace(/ /g,'')\n\n                    \n\n\n                   if(/^([-+]?[0-9]*\\.?[0-9]+[\\/\\+\\-\\*])+([-+]?[0-9]*\\.?[0-9]+)*$/gm.test(CleanedValue)!=true)\n\n                   {\n\n                 // \n\n                    value = value.replace(/\"/g, \"\");\n                    value = value.replace(/'/g, \"\");\n\n\n\n                        this.output = this.output + \"\\n\" + value + \"\\n\" \n }\n                        \n\n}\n\n\n            }\n\n\n           \n            })\n\n        }\n        */\n\n\n        }\n\n    }\n\n};\n</script>\n\n<!-- Add \"scoped\" attribute to limit CSS to this component only -->\n<style scoped>\n\n#bharatP{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace\n}\n#versionNumber{\n\n\ntext-align: left;\n  display: table-cell;\n    font-family: monospace;\n    padding-left: 6%\n}\n\n#bharatDIV{\n\n    padding-top: 2%;\n    padding-left: 2%\n\n}\n\n#linebylineOutput\n{\n\n\n\nheight: 10px;\n    text-align: left;\n    \n\n\n}\n#errorstack{\n\ntext-align: left;\npadding-left: 2.5%;\npadding-top: 6%;\nfont-weight: bold;\ncolor:rgb(231, 83, 83);\n\n}\n\n#compiler{\n\n  display: flex;\n}\n\n#textarea{\n\n  width: 50%\n}\n#output{\n\n  height: 400px;\n  width: 50%;\n  background-color: black;\n    color: white;\n    overflow: auto\n  \n}\nh3 {\n  margin: 40px 0 0;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\na {\n  color: #42b983;\n}\n\n.hello {\n  display: grid;\n}\n\n#codearea {\n  width: 90%;\n  height: 400px;\n  background-color: whitesmoke;\n    font-family: monospace;\n    font-size: medium;\n    border: none\n}\n\n#subm {\n  width: 10%;\n  height: 50px;\n}\n</style>"]}]}